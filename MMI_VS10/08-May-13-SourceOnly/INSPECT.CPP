// Inspect.cpp : implementation file
// start: 01/14/00
/*
Revised:
    01/17/00    Blue on top(od) Magenta on bottom (id).  Pens in Class def
                GetPipeStatus, GetInspectStatusAma called from each drawing
                routine.
    01/25/00    RECORD, PLAY BACK DATA  Msg01 only!
    01/31/00    How to stop recursion in play back.  Remove playback from
                timer interrupt and stop timer when playback function
                is in use.
    02/01/00    Add windows message handler for post messsage to erase
                graph areas.  Goes just at end of message map outside map
                generated by app wizard
    03/03/00    1st snaky code.  Put routine which builds flaw report text
                here.  Called from TscanDlg print screen function which can
                be invoked with Alt-P key combination.
    05/03/00    Show map as clock positions instead of degrees.
                Limit x position to m_nScale range
    06/27/00    Move flaw list compression code from asi project
                Changing mapping names from ama/sono/iso to 
                wall/long/tran/oblq
    10/23/00    Enable/disable hardware TOP clock/angle
    12/01/00    Change xtick y axis to 120 to facilitate clock ticks
                on far right side
    03/19/02    3 cats of obliq
    04/24/02    AddFlawTextToDib now returns number of flaws printed on each page
*/

#include "stdafx.h"
#include "Truscan.h"
#include "TscanDlg.h"
#include "..\include\Truscan_version.h"

//#include "Inspect.h"  included in asidlg.h

#include "Extern.h"

CString szFlaw;
int maporg,wallorg,longorg,tranorg,q1org,q2org,q3org,lamorg;
int mapoff,walloff,longoff,tranoff,q1off,q2off,q3off;
CString ss;

#define REPLAY_IS_MODELESS      1

#define N_FLAW_TYPES            7
//how many types of flaws, wall, long, tran, Q1, Q2, Q3
extern CString sconfig;


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#define MAPYPOS -540
#define WALLYPOS MAPYPOS-340
#define LONGYPOS MAPYPOS-640
#define TRANYPOS MAPYPOS-940
#define OBQ1YPOS MAPYPOS-1240
#define OBQ2YPOS MAPYPOS-1540
#define OBQ3YPOS MAPYPOS-1840
#define PRINTERFACTOR   0
#define REFRESH_TIMER 1010
int pageWidth,pageHeight;

extern CPtrList g_pTcpListUtData;  /* linked list holding the IData for the first inspect window */
extern CPtrList g_pTcpListUtData2;  /* linked list holding the IData for the second inspect window */
extern CCriticalSection g_CriticalSection;  /* Critical section for mutual exclusion access of g_pTcpListUtData */
extern CCriticalSection g_CriticalSection2;  /* Critical section for mutual exclusion access of g_pTcpListUtData2 */
extern int g_nLostIdataCnt;
CPtrList g_pTcpListUtDataChnls;  /* linked list holding the IData for the Channel Traces window */
CCriticalSection g_CriticalSectionChnls;  /* Critical section for mutual exclusion access of g_pTcpListUtDataChnls */

ECHO_BITS CInspect::m_EchoBits;
WORD CInspect::m_nMotionBus = 0;
    CPen *penOld,*penId,*penOd;
    CPen *penIdp, *penOdp,*penIdt, *penOdt,*penBlack;
    CFont xFont,tFont,hFont,h1Font;

/////////////////////////////////////////////////////////////////////////////
// CInspect dialog
BOOL FtextON,FtextON2 ;

CInspect::CInspect(CWnd* pParent /*=NULL*/, int nID)
    : CDialog(CInspect::IDD, pParent)
{
    //{{AFX_DATA_INIT(CInspect)
    m_nControlSel = -1;
    m_nTimeMotion = ConfigRec.bMotionTime &1;
    m_nScaleSel = -1;
    m_bIdCheck = TRUE;
    m_bOdCheck = TRUE;
    m_bMetric = FALSE;
    m_bPrint = FALSE;
    m_bLongCheck = TRUE;
    m_bTranCheck = TRUE;
    m_bWallCheck = TRUE;
    m_nTholdLid = 1;
    m_nTholdLod = 1;
    m_nTholdTid = 1;
    m_nTholdTod = 1;
    m_nTholdThick = 1;
    m_nTholdThin = -1;
    m_bNoClock = FALSE;
    m_bOblq1Check = TRUE;
    m_bOblq2Check = TRUE;
    m_bOblq3Check = TRUE;
    m_nTholdQ1id = 0;
    m_nTholdQ2id = 0;
    m_nTholdQ3id = 0;
    m_nTholdQ3od = 0;
    m_nTholdQ1od = 0;
    m_nTholdQ2od = 0;
    m_nNcLid = 0;
    m_nNcLod = 0;
    m_nNx = 0;
    m_nNcQ1id = 0;
    m_nNcQ1od = 0;
    m_nNcQ2id = 0;
    m_nNcQ2od = 0;
    m_nNcQ3id = 0;
    m_nNcQ3od = 0;
    m_nNcTid = 0;
    m_nNcTod = 0;
    m_bPrntFlw = FALSE;
    m_bAutoPrint = -1;
	m_bRunCalJoint = FALSE;
	m_bAllFlaw = FALSE;
	m_nTholdLamid = 0;
	m_nTholdLamod = 0;
	m_nNcLamid = 0;
	m_nNcLamod = 0;
	m_bLaminCheck = TRUE;
	m_bRealTimeReport = FALSE;
	//}}AFX_DATA_INIT

    m_nID = nID;
    penBlack1Dot.CreatePen(PS_DOT,1, RGB(0,0,0));
    penBlack2.CreatePen(PS_SOLID,3, RGB(0,0,0));
    penRed4.CreatePen(PS_SOLID,4, RGB(255,0,0));
    penBlue4.CreatePen(PS_SOLID,4, RGB(0,0,255));
    penMagenta4.CreatePen(PS_SOLID,4,RGB(255,0,0));
    penBlue2.CreatePen(PS_SOLID,2, RGB(0,0,255));
    penMagenta2.CreatePen(PS_SOLID,2,RGB(255,0,0));
    penBlack1.CreatePen(PS_SOLID,1, RGB(0,0,0));
    penBlack1Dash.CreatePen(PS_DASH,1, RGB(0,0,0));
    penWhite2.CreatePen(PS_SOLID,2, RGB(255,255,255));
    penRed1.CreatePen(PS_SOLID,1, RGB(255,000,00));
    penBlue1.CreatePen(PS_SOLID,1, RGB(0,00,255));
    penRed1Dash.CreatePen(PS_DASH,1, RGB(255,000,00));
    penBlue1Dash.CreatePen(PS_DASH,1, RGB(0,00,255));
    penRed2.CreatePen(PS_SOLID,2, RGB(255,0,0));
	penBlack3.CreatePen(PS_SOLID,8, RGB(0,0,0));

    m_nNumExistWall = 0;

    m_bRcvrStation1 = FALSE;
    m_bRcvrStation2 = FALSE;
    m_bShowStation1 = FALSE;
    m_bShowStation2 = FALSE;

    EraseExistPts();

    m_wOldStatMap = 0;
    m_wOldStatWall = 0;
    m_wOldStatLong = 0;
    m_wOldStatTran = 0;
    m_wOldStatObq1 = 0;
    m_wOldStatObq2 = 0;
    m_wOldStatObq3 = 0;

    m_bDrawProgressS1Once = FALSE;
    m_bDrawProgressS2Once = FALSE;
    m_bDrawProgressTranOnce = FALSE;
    m_bDrawProgressObq2Once = FALSE;

    m_pFlawReport = NULL;

	m_bBackward = FALSE;
	m_bWriteToFile = FALSE;

	m_bPipeJustLeft = FALSE;

	m_nHomeAway = 1;

	m_nInvalidWallTimer = 0;

	m_bAllFlaw = FALSE;

	m_nMapRect = 0;
}

CInspect::~CInspect()
    {

//  I_MSG_RUN *pErase;

    if (m_nID == 0)
    {
        if (m_pDataFile)
        {
            m_pDataFile->Close();
            delete m_pDataFile;
        }

        if (m_pDataIndexFile)
        {
            m_pDataIndexFile->Close();
            delete m_pDataIndexFile;
        }

        if (m_pDataCsvFile)
        {
            m_pDataCsvFile->Close();
            delete m_pDataCsvFile;
        }
	}
#if 0           
    while (!plistReplayData.IsEmpty())
        {
        pErase = (I_MSG_RUN *)plistReplayData.RemoveHead();
        delete pErase;
        }
#endif

    //AfxMessageBox("CloseInspect");
    if ( ((m_nControlSel== INSPECT_RUN) || (m_nControlSel== INSPECT_RECORD)) && (m_nID == 0) )
        m_pTcpThreadRxList->SendSlaveMsg(NOP_MODE, 0,0,0,0,0,0);

    EraseExistPts();
    EraseFlawLists();
    }



void CInspect::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CInspect)
	DDX_Control(pDX, IDC_INSP_LAMIN, m_cbInspLamin);
    DDX_Control(pDX, IDC_STATIC_STATION2, m_stStation2);
    DDX_Control(pDX, IDC_STATIC_STATION1, m_stStation1);
    DDX_Control(pDX, IDC_INSP_OBLQ3, m_cbInspOblq3);
    DDX_Control(pDX, IDC_INSP_OBLQ2, m_cbInspOblq2);
    DDX_Control(pDX, IDC_INSP_OBLQ1, m_cbInspOblq1);
    DDX_Control(pDX, IDC_INSP_WALL, m_cbInspWall);
    DDX_Control(pDX, IDC_INSP_TRAN, m_cbInspTran);
    DDX_Control(pDX, IDC_INSP_LONG, m_cbInspLong);
    DDX_Control(pDX, IDC_CURSORY_EN, m_ceCursorY);
    DDX_Control(pDX, IDC_CURSORX_EN, m_ceCursorX);
    DDX_Control(pDX, IDC_MAP, m_cbMap);
    DDX_Radio(pDX, IDC_STOP, m_nControlSel);
    DDX_Radio(pDX, IDC_MOTION, m_nTimeMotion);
    DDX_Radio(pDX, IDC_SCALE50, m_nScaleSel);
    DDX_Check(pDX, IDC_ID_CHECK, m_bIdCheck);
    DDX_Check(pDX, IDC_OD_CHECK, m_bOdCheck);
    DDX_Check(pDX, IDC_CK_METRIC, m_bMetric);
    DDX_Check(pDX, IDC_PrntScrn, m_bPrint);
    DDX_Check(pDX, IDC_CK_LONG, m_bLongCheck);
    DDX_Check(pDX, IDC_CK_TRAN, m_bTranCheck);
    DDX_Check(pDX, IDC_CK_WALL, m_bWallCheck);
    DDX_Text(pDX, IDC_EN_LID, m_nTholdLid);
    DDV_MinMaxInt(pDX, m_nTholdLid, 0, 100);
    DDX_Text(pDX, IDC_EN_LOD, m_nTholdLod);
    DDV_MinMaxInt(pDX, m_nTholdLod, 0, 100);
    DDX_Text(pDX, IDC_EN_TID, m_nTholdTid);
    DDV_MinMaxInt(pDX, m_nTholdTid, 0, 100);
    DDX_Text(pDX, IDC_EN_TOD, m_nTholdTod);
    DDV_MinMaxInt(pDX, m_nTholdTod, 0, 100);
    DDX_Text(pDX, IDC_EN_THK, m_nTholdThick);
    DDV_MinMaxInt(pDX, m_nTholdThick, 1, 25);
    DDX_Text(pDX, IDC_EN_THN, m_nTholdThin);
    DDV_MinMaxInt(pDX, m_nTholdThin, -25, -1);
    DDX_Check(pDX, IDC_NO_CLOCK, m_bNoClock);
    DDX_Check(pDX, IDC_CK_OBLQ1, m_bOblq1Check);
    DDX_Check(pDX, IDC_CK_OBLQ2, m_bOblq2Check);
    DDX_Check(pDX, IDC_CK_OBLQ3, m_bOblq3Check);
    DDX_Text(pDX, IDC_EN_Q1ID, m_nTholdQ1id);
    DDV_MinMaxInt(pDX, m_nTholdQ1id, 0, 100);
    DDX_Text(pDX, IDC_EN_Q2ID, m_nTholdQ2id);
    DDV_MinMaxInt(pDX, m_nTholdQ2id, 0, 100);
    DDX_Text(pDX, IDC_EN_Q3ID, m_nTholdQ3id);
    DDV_MinMaxInt(pDX, m_nTholdQ3id, 0, 100);
    DDX_Text(pDX, IDC_EN_Q3OD, m_nTholdQ3od);
    DDV_MinMaxInt(pDX, m_nTholdQ3od, 0, 100);
    DDX_Text(pDX, IDC_EN_Q1OD, m_nTholdQ1od);
    DDV_MinMaxInt(pDX, m_nTholdQ1od, 0, 100);
    DDX_Text(pDX, IDC_EN_Q2OD, m_nTholdQ2od);
    DDV_MinMaxInt(pDX, m_nTholdQ2od, 0, 100);
    DDX_Text(pDX, IDC_EN_LID_NC, m_nNcLid);
    DDV_MinMaxInt(pDX, m_nNcLid, 1, 10);
    DDX_Text(pDX, IDC_EN_LOD_NC, m_nNcLod);
    DDV_MinMaxInt(pDX, m_nNcLod, 1, 10);
    DDX_Text(pDX, IDC_EN_NX, m_nNx);
	DDV_MinMaxInt(pDX, m_nNx, 1, 10);
    DDX_Text(pDX, IDC_EN_Q1ID_NC, m_nNcQ1id);
    DDV_MinMaxInt(pDX, m_nNcQ1id, 1, 10);
    DDX_Text(pDX, IDC_EN_Q1OD_NC, m_nNcQ1od);
    DDV_MinMaxInt(pDX, m_nNcQ1od, 1, 10);
    DDX_Text(pDX, IDC_EN_Q2ID_NC, m_nNcQ2id);
    DDV_MinMaxInt(pDX, m_nNcQ2id, 1, 10);
    DDX_Text(pDX, IDC_EN_Q2OD_NC, m_nNcQ2od);
    DDV_MinMaxInt(pDX, m_nNcQ2od, 1, 10);
    DDX_Text(pDX, IDC_EN_Q3ID_NC, m_nNcQ3id);
    DDV_MinMaxInt(pDX, m_nNcQ3id, 1, 10);
    DDX_Text(pDX, IDC_EN_Q3OD_NC, m_nNcQ3od);
    DDV_MinMaxInt(pDX, m_nNcQ3od, 1, 10);
    DDX_Text(pDX, IDC_EN_TID_NC, m_nNcTid);
    DDV_MinMaxInt(pDX, m_nNcTid, 1, 10);
    DDX_Text(pDX, IDC_EN_TOD_NC, m_nNcTod);
    DDV_MinMaxInt(pDX, m_nNcTod, 1, 10);
    DDX_Check(pDX, IDC_PrntFlw, m_bPrntFlw);
    DDX_Radio(pDX, IDC_Print, m_bAutoPrint);
	DDX_Check(pDX, IDC_CHECK_CALRUN, m_bRunCalJoint);
	DDX_Check(pDX, IDC_ALL_FLAW, m_bAllFlaw);
	DDX_Text(pDX, IDC_EN_LAMID, m_nTholdLamid);
	DDV_MinMaxInt(pDX, m_nTholdLamid, 0, 100);
	DDX_Text(pDX, IDC_EN_LAMOD, m_nTholdLamod);
	DDX_Text(pDX, IDC_EN_LAMID_NC, m_nNcLamid);
	DDV_MinMaxInt(pDX, m_nNcLamid, 1, 10);
	DDX_Text(pDX, IDC_EN_LAMOD_NC, m_nNcLamod);
	DDV_MinMaxInt(pDX, m_nNcLamod, 1, 10);
	DDX_Check(pDX, IDC_CK_LAMIN, m_bLaminCheck);
	DDX_Check(pDX, IDC_CHECK_REPORT, m_bRealTimeReport);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInspect, CDialog)
    //{{AFX_MSG_MAP(CInspect)
    ON_WM_TIMER()
    ON_BN_CLICKED(IDC_INSP_ERASE, OnButtonErase)
    ON_BN_CLICKED(IDC_MOTION, OnMotion)
    ON_BN_CLICKED(IDC_PLAY, OnPlay)
    ON_BN_CLICKED(IDC_RECORD, OnRecord)
    ON_BN_CLICKED(IDC_RUN, OnRun)
    ON_BN_CLICKED(IDC_SCALE50, OnScale50)
    ON_BN_CLICKED(IDC_SCALE75, OnScale75)
    ON_BN_CLICKED(IDC_STOP, OnStop)
    ON_BN_CLICKED(IDC_TIME, OnTime)
    ON_BN_CLICKED(IDC_ID_CHECK, OnIdCheck)
    ON_BN_CLICKED(IDC_OD_CHECK, OnOdCheck)
    ON_WM_CTLCOLOR()
    ON_WM_CONTEXTMENU()
    ON_COMMAND(ID__THOLDS, OnTholds)
    ON_WM_MOUSEMOVE()
    ON_BN_CLICKED(IDC_CK_METRIC, OnCkMetric)
    ON_BN_CLICKED(IDC_AUTO_PRINT, OnAutoPrint)
    ON_BN_CLICKED(IDC_INSP_REFRESH, OnInspRefresh)
    ON_BN_CLICKED(IDC_CK_LONG, OnCkLong)
    ON_BN_CLICKED(IDC_CK_OBLQ1, OnCkOblq1)
    ON_BN_CLICKED(IDC_CK_OBLQ2, OnCkOblq2)
    ON_BN_CLICKED(IDC_CK_OBLQ3, OnCkOblq3)
    ON_BN_CLICKED(IDC_CK_TRAN, OnCkTran)
    ON_BN_CLICKED(IDC_CK_WALL, OnCkWall)
    ON_COMMAND(ID__NCNX, OnNcnx)
    ON_COMMAND(ID__IPXSTATS, OnIpxstats)
    ON_BN_CLICKED(IDC_NO_CLOCK, OnNoClock)
    ON_BN_CLICKED(IDC_MEM_BN, OnMemBn)
    ON_COMMAND(ID__CHART_ASSIGN, OnChartAssign)
    ON_BN_CLICKED(IDC_PrntFlw, OnPrintFlw)
    ON_BN_CLICKED(IDC_Print, OnPrint)
    ON_WM_PAINT()
    ON_BN_CLICKED(IDC_BTN_REFRESH, OnBtnRefresh)
    ON_BN_CLICKED(IDC_INSPREPORT, OnINSPreport)
	ON_BN_CLICKED(IDC_CHECK_CALRUN, OnCheckCalRun)
	ON_BN_CLICKED(IDC_ALL_FLAW, OnAllFlaw)
	ON_BN_CLICKED(IDC_CK_LAMIN, OnCkLamin)
    ON_WM_KEYDOWN()
    ON_BN_CLICKED(IDC_PrntScrn, OnAutoPrint2)
	ON_BN_CLICKED(IDC_CHECK_REPORT, OnCheckRealTimeReport)
	//}}AFX_MSG_MAP

//	ON_MESSAGE(WM_USER_ACAL_ERASE, VS10_EraseBars)  // this required to go from Visual Studio 6 to Visual Studio 2010
//  add to header file
//	afx_msg LRESULT VS10_EraseBars(WPARAM, LPARAM);	// this foolishness required to go from Visual Studio to Visual NET
// IN this cpp file call EraseBars from inside VS10_EraseBars

    //Manually add message to kill window  .. jeh
//    ON_MESSAGE(WM_USER_KILL_INSPECT, OnCancel)
    ON_MESSAGE(WM_USER_KILL_INSPECT, VS10_OnCancel)
    ON_MESSAGE(WM_USER_INSPECT_ERASE, VS10_OnInspEraseAll)
    ON_MESSAGE(WM_USER_INSPECT_STOP, VS10_OnStop)
    ON_MESSAGE(WM_USER_PLAY_ONE_PIPE,VS10_PlayOnePipe)
    ON_MESSAGE(WM_USER_SET_ENGLISH_METRIC, VS10_OnUpdateData)
END_MESSAGE_MAP()

// Wrappers to get from VC6 to Visual Studio 10
// this foolishness required to go from Visual Studio to Visual NET
afx_msg LRESULT CInspect::VS10_OnCancel(WPARAM, LPARAM)
	{	OnCancel();	return 0;	}

afx_msg LRESULT CInspect::VS10_OnInspEraseAll(WPARAM, LPARAM)
	{	OnInspEraseAll();	return 0;	}

afx_msg LRESULT CInspect::VS10_OnStop(WPARAM, LPARAM)
	{	OnStop();	return 0;	}

afx_msg LRESULT CInspect::VS10_PlayOnePipe(WPARAM, LPARAM)
	{	PlayOnePipe();	return 0;	}

afx_msg LRESULT CInspect::VS10_OnUpdateData(WPARAM, LPARAM)
	{	OnUpdateData();	return 0;	}


/////////////////////////////////////////////////////////////////////////////
// CInspect message handlers

void CInspect::OnCancel() 
    {
    // TODO: Add extra cleanup here
    // Need this to get to PostNcDestroy which nulls ptr to the routine
    if (m_nControlSel != INSPECT_STOP)
        return;


//TRACE("\n\nSize of I_MSG_RUN=%d\n\n", sizeof(I_MSG_RUN));

    WINDOWPLACEMENT wp;

    StopTimer();

    EraseExistPts();

    if (m_pFlawReport)
        m_pFlawReport->KillMe();

    // Save closing location of window
    GetWindowPlacement(&wp);
    if (m_nID == 0)
    {
        pCTscanDlg->SaveWindowLastPosition(_T("INSPECT"), &wp);
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
        if (pCTscanDlg->m_pInspectDlg2)
            pCTscanDlg->m_pInspectDlg2->KillMe();
#endif
    }
    else
        pCTscanDlg->SaveWindowLastPosition(_T("INSPECT2"), &wp);
    
    CDialog::OnCancel();
    CDialog::DestroyWindow();
    
    }

void CInspect::OnOK() 
    {
    // TODO: Add extra validation here
    WINDOWPLACEMENT wp;

    StopTimer();
    
    // Save closing location of window
    GetWindowPlacement(&wp);
    if (m_nID == 0)
        pCTscanDlg->SaveWindowLastPosition(_T("INSPECT"), &wp);
    else
        pCTscanDlg->SaveWindowLastPosition(_T("INSPECT2"), &wp);
    
    CDialog::OnOK();
    CDialog::DestroyWindow();
    
    }

void CInspect::PostNcDestroy() 
    {
    // TODO: Add your specialized code here and/or call the base class

    switch(m_nID)
    {
        case 0:
            if ( CTholds::m_pDlg) CTholds::m_pDlg->KillMe();    // close tholds
            if ( CNc::m_pDlg) CNc::m_pDlg->KillMe();    // close tholds
            if ( CIpxStat::m_pDlg) CIpxStat::m_pDlg->KillMe();  // close tholds
#if REPLAY_IS_MODELESS
            if ( CReplay::m_pDlg) CReplay::m_pDlg->KillMe();    // close replay
#endif

            if ( CEcho::m_pDlg && (m_nID == 0) ) CEcho::m_pDlg->KillMe();   // close score board






            if (pCTscanDlg->m_pInspectDlg1)
                pCTscanDlg->m_pInspectDlg1 = NULL;
            break;

         case 1:
            if (pCTscanDlg->m_pInspectDlg2)
                pCTscanDlg->m_pInspectDlg2 = NULL;
            break;

        default:
            break;


    }
    //if ( m_pFlawReport) m_pFlawReport->KillMe();// close score board
    CDialog::PostNcDestroy();
    // Let the top level dialog TscanDlg know we are now dead
    CDialog::OnDestroy();

    delete this;
    }



BOOL CInspect::OnInitDialog() 
    {

    CDialog::OnInitDialog();
    WINDOWPLACEMENT wp;
    RECT rect;
    int dx, dy;     // width and height of original window
    
    // TODO: Add extra initialization here
    FtextON = FALSE;
    GetWindowPlacement(&wp);
    dx = wp.rcNormalPosition.right - wp.rcNormalPosition.left;
    dy = wp.rcNormalPosition.bottom - wp.rcNormalPosition.top;
    if (m_nID)
        pCTscanDlg->GetWindowLastPosition(_T("INSPECT2"), &rect);
    else
        pCTscanDlg->GetWindowLastPosition(_T("INSPECT"), &rect);

    if ( ( (rect.right - rect.left) >= dx ) &&
         ( (rect.bottom - rect.top) >= dy ))
        {
        wp.rcNormalPosition = rect;
        SetWindowPlacement(&wp);
        }
    sconfig = _T("");
    m_pDataFile = NULL;
    m_pDataIndexFile = NULL;    // No exitsing file
    m_pDataCsvFile = NULL;  // No exitsing file
	m_pDataFileCD = NULL;
    m_nRefresh = FALSE;
    penOd = &penBlue1;
    penId = &penRed1;


    // Start timer
    // which will process ipx data msg's collected from OnIpxRXRDY
    // procedure in TscanDlg
    m_uIpxTimer = 0;
    m_nDelayedErase = 0;
    StartTimer();
    
  //  Initialize some member variables
    m_nControlSel = INSPECT_STOP;
    m_nScaleSel = INSPECT_SCALE_50;
    m_nScale = 50*12;       // scale size in INCHES.  50 ft.
    m_bDrawTicks = TRUE;
    m_ptLastWallMax = m_ptLastWallMin = (0,0);  // previous amalog id, od values
    m_ptLastLOd = m_ptLastLId = (0,0);  // previous sono id, od values
    m_ptLastTid = m_ptLastTod = (0,0);  // previous iso thru values
    m_ptLastQ2id = m_ptLastQ2od = (0,0);    // previous iso chord values
    
    m_bIdCheck  = m_bOdCheck = TRUE;
    m_uTimerTick = 0;
    m_wInspEnable = 0;

    m_nWallMaxCnt = m_nWallMinCnt = 0;
    m_nLodFlawCnt = m_nLidFlawCnt = 0;
    m_nTodFlawCnt = m_nTidFlawCnt= 0;
    m_nQ1odFlawCnt = m_nQ1idFlawCnt= 0;
    m_nQ2odFlawCnt = m_nQ2idFlawCnt= 0;
    m_nQ3odFlawCnt = m_nQ3idFlawCnt= 0;
	m_nLamodFlawCnt = m_nLamidFlawCnt= 0;
    m_nTotalFlawCnt = m_nTotalWallCnt = 0;

    GetConfigRecValues();       // update member variables with config.rec

    // Make sure in Inspection mode and not cal mode
    SendMsg(NOP_MODE);


    m_nTholdWodLast = -2;       // Initial thold levels for erasing purpose
    m_nTholdWidLast = 2;
    m_nTholdTodLast = -2;
    m_nTholdTidLast = -2;
    m_nTholdLidLast = -2;
    m_nTholdLodLast = -2;
    m_nTholdQ1idLast = -2;
    m_nTholdQ1odLast = -2;
    m_nTholdQ2idLast = -2;
    m_nTholdQ2odLast = -2;
    m_nTholdQ3idLast = -2;
    m_nTholdQ3odLast = -2;
    m_nTholdLamidLast = -2;
    m_nTholdLamodLast = -2;

    m_nTholdThin = ConfigRec.UtRec.TholdWall[0];
    m_nTholdThick = ConfigRec.UtRec.TholdWall[1];

    m_nTholdLid = ConfigRec.UtRec.TholdLong[0][0];
    m_nTholdLod = ConfigRec.UtRec.TholdLong[0][1];

    m_nTholdTid = ConfigRec.UtRec.TholdLong[1][0];
    m_nTholdTod = ConfigRec.UtRec.TholdLong[1][1];

    m_nTholdQ1id = ConfigRec.UtRec.TholdLong[2][0];
    m_nTholdQ1od = ConfigRec.UtRec.TholdLong[2][1];
    m_nTholdQ2id = ConfigRec.UtRec.TholdLong[3][0];
    m_nTholdQ2od = ConfigRec.UtRec.TholdLong[3][1];
    m_nTholdQ3id = ConfigRec.UtRec.TholdLong[4][0];
    m_nTholdQ3od = ConfigRec.UtRec.TholdLong[4][1];
    m_nTholdLamid = ConfigRec.UtRec.TholdLong[5][0];
    m_nTholdLamod = ConfigRec.UtRec.TholdLong[5][1];

    // Show NC values
    m_nNx    = ConfigRec.UtRec.NxWall[0];
    m_nNcLid = ConfigRec.UtRec.NcLong[0];
    m_nNcLod = ConfigRec.UtRec.NcLong[1];

    m_nNcTid = ConfigRec.UtRec.NcTran[0];
    m_nNcTod = ConfigRec.UtRec.NcTran[1];

    m_nNcQ1id = ConfigRec.UtRec.NcOblq1[0];
    m_nNcQ1od = ConfigRec.UtRec.NcOblq1[1];
    m_nNcQ2id = ConfigRec.UtRec.NcOblq2[0];
    m_nNcQ2od = ConfigRec.UtRec.NcOblq2[1];
    m_nNcQ3id = ConfigRec.UtRec.NcOblq3[0];
    m_nNcQ3od = ConfigRec.UtRec.NcOblq3[1];
    m_nNcLamid = ConfigRec.UtRec.NcLamin[0];
    m_nNcLamod = ConfigRec.UtRec.NcLamin[1];
    
    ConfigRec.UtRec.bClockFlag &= 1;
    m_bNoClock = ConfigRec.UtRec.bClockFlag ^ 1;// opposite polarity

    UpdateData(FALSE);  // Copy variables to screen

    MakeMouseRect();
    ShowDlgTitle();

    // 10/30/00 display transducer activity modeless  dailog
    if ( CEcho::m_pDlg == NULL)
        {
        CEcho::m_pDlg = new CEcho;
#if (LOCATION_ID == BESSEMER)
        if (CEcho::m_pDlg) CEcho::m_pDlg->Create(IDD_XDCR_ACTIVITY_BESSEMER);
#else
        if (CEcho::m_pDlg) CEcho::m_pDlg->Create(IDD_XDCR_ACTIVITY);
#endif
        }

    if (m_nID != 0)
        DisableControls();

    m_stStation1.SetWindowText(_T(""));
    m_stStation2.SetWindowText(_T(""));

	SetOblqName();

	m_pTcpThreadRxList->SendSlaveMsg(SET_X_SCALE, m_nScale,0,0,0,0,0);

    // Post a windows message which will perform the initial erase
    // of the graph areas.  Can't call erase directly and get real
    // erase of screen.  Post this to ourself
//  ::PostMessage(m_hWnd, WM_USER_INSPECT_ERASE,0,0);

    SetDefID(-1);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
    }

void CInspect::OnTimer(UINT nIDEvent) 
	{
	if ( nIDEvent == REFRESH_TIMER )
		{
		KillTimer(REFRESH_TIMER);
		RefreshWindow();
		CDialog::OnTimer(nIDEvent);
		return;
		}

    // TODO: Add your message handler code here and/or call default
    // IPX timer to empty data messages from data msg queue

    I_MSG_RUN   *pImsg01;
    CString s;
    short xloc1=0, xloc2=0;
    static WORD  Period;
    static int VelocityDt;

    // copy inspection data from g_pListUtData to plistUtdata
    I_MSG_RUN *pImsgRun;
	int nPipeGoneCnt = 0;
    switch (m_nID)
		{
    case 0:  // first inspect window
        //if (pCTscanDlg->m_pInspectDlg2)
            //pCTscanDlg->m_pInspectDlg2->UpdateDisplay();

        // g_CriticalSection.Lock();
        while (!g_pTcpListUtData.IsEmpty() )
			{
			g_CriticalSection.Lock();
            pImsgRun = (I_MSG_RUN *) g_pTcpListUtData.RemoveHead();
			g_CriticalSection.Unlock();
			if (nPipeGoneCnt && (pImsgRun->InspHdr.wLineStatus & PIPE_PRESENT) )
				{
				g_CriticalSection.Lock();
				g_pTcpListUtData.AddHead((void *) pImsgRun);
				g_CriticalSection.Unlock();
				// could get stuck here forever. If GoneCnt!= 0 and pipe present, then put packet back into list
				// hence, list can never empty because next time thru, the same condition will exist. Can't get out of while()
				break;	// break from while () in case 0
				}
			m_plistUtData.AddTail((void *) pImsgRun);
            if ( pImsgRun->InspHdr.nStation == 0 )
				{
                m_bRcvrStation1 = TRUE;
                //xloc1 = pImsgRun->InspHdr.xloc;
                xloc1 = pImsgRun->InspHdr.JointLength;
                if (pImsgRun->InspHdr.JointLength > 0)
                    m_nJointLength = pImsgRun->InspHdr.JointLength;
				}
            else
				{
                m_bRcvrStation2 = TRUE;
                //xloc2 = pImsgRun->InspHdr.xloc;
                xloc2 = pImsgRun->InspHdr.JointLength;
				}
            Period = pImsgRun->InspHdr.Period;
            VelocityDt = (int) pImsgRun->InspHdr.VelocityDt;
            m_nMotionBus = pImsgRun->InspHdr.status[2];
			if ( (pImsgRun->InspHdr.wLineStatus & PIPE_PRESENT) == 0 )
				{
#if ( (SYSTEM_ID == RAW_WALL_SYS) || (SYSTEM_SUB_ID == BESSEMER_SYS) )
				if (nPipeGoneCnt == 0)
					{
					m_nHomeAway = pImsgRun->InspHdr.status[2] & 0x4000;
					m_nAwayStopXloc = pImsgRun->InspHdr.JointLength;
					}
#endif
				nPipeGoneCnt++;
				}
			}	// while (!g_pTcpListUtData.IsEmpty() )
        //g_CriticalSection.Unlock();
        break;

    case 1:  // second inspect window
        //g_CriticalSection2.Lock();
        while (!g_pTcpListUtData2.IsEmpty() )
			{
			g_CriticalSection2.Lock();
            pImsgRun = (I_MSG_RUN *) g_pTcpListUtData2.RemoveHead();
			g_CriticalSection2.Unlock();
			if (nPipeGoneCnt && (pImsgRun->InspHdr.wLineStatus & PIPE_PRESENT) )
				{
				g_CriticalSection2.Lock();
				g_pTcpListUtData2.AddHead((void *) pImsgRun);
				g_CriticalSection2.Unlock();
				break;
				}
            m_plistUtData.AddTail((void *) pImsgRun);
            if ( pImsgRun->InspHdr.nStation == 0 )
            {
                m_bRcvrStation1 = TRUE;
                //xloc1 = pImsgRun->InspHdr.xloc;
                xloc1 = pImsgRun->InspHdr.JointLength;
                if (pImsgRun->InspHdr.JointLength > 0)
                    m_nJointLength = pImsgRun->InspHdr.JointLength;
            }
            else
            {
                m_bRcvrStation2 = TRUE;
                //xloc2 = pImsgRun->InspHdr.xloc;
                xloc2 = pImsgRun->InspHdr.JointLength;
            }
            Period = pImsgRun->InspHdr.Period;
            VelocityDt = (int) pImsgRun->InspHdr.VelocityDt;
            m_nMotionBus = pImsgRun->InspHdr.status[2];
			if ( (pImsgRun->InspHdr.wLineStatus & PIPE_PRESENT) == 0 )
				nPipeGoneCnt++;

	        }	// while (!g_pTcpListUtData2.IsEmpty() )
        // g_CriticalSection2.Unlock();
        break;

    default:
        break;
    }	// switch (m_nID)

    ShowRcvrStation(xloc1, xloc2);

#if 0 //(SYSTEM_ID == RAW_WALL_SYS)
	if (m_nInvalidWallTimer>0)
		ShowInvalidWallClassification();
#endif

#if FOR_TEST
    SetDlgItemInt(IDC_EDIT_LOSTIDATA, g_nLostIdataCnt, TRUE);
#endif

    if ( m_nDelayedErase)
        {   // allow redraws before erasing
        m_nDelayedErase--;
        if ( m_nDelayedErase == 0) DelayedErase();
        }

//    if ( m_bDrawTicks)
        {
        DrawXTicks();
//        m_bDrawTicks = FALSE;
        }

    m_uTimerTick++;
    // Every 8th timer tick, capture the system time
    if ( (m_uTimerTick & 0x7 ) == 0)
        {
        time(&m_tTimeNow);
        if ( m_nControlSel != INSPECT_PLAY)
            {
            pCTscanDlg->UpdateTimeDate(&m_tTimeNow);
            pCTscanDlg->m_nRpm = Period;
            pCTscanDlg->m_nFpm = VelocityDt;
            if (m_nJointLength > 0)
                pCTscanDlg->m_nJointLength = m_nJointLength;
            pCTscanDlg->m_wLineStatus = m_nMotionBus;
            //m_nMotionBus = 0;
#ifdef MAKE_IT_CRASH
            pCTscanDlg->UpdateRpm();    // also displays linear speed, joint length and line status
#endif
            //RefreshWindow();
#if 0
            if ( m_bHome) s = _T("Home");
            else s = _T("Away");
            GetDlgItem(IDC_HOME_EN)->SetWindowText(s);
#endif
            }
        }



    switch(m_nControlSel)
        {
    case INSPECT_STOP:
        // Empty list and return
        while (!m_plistUtData.IsEmpty())
            {
            pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();
            delete pImsg01;
            }
        CDialog::OnTimer(nIDEvent);
        return;

    case INSPECT_PLAY:
        // Should not be here if timer really stopped
        StopTimer();
        m_nControlSel = INSPECT_STOP;
        CDialog::OnTimer(nIDEvent);
        return;


    case INSPECT_RUN:
    case INSPECT_RECORD:
    default:
        if (m_plistUtData.IsEmpty() )
            {   // nothing to do here
            CDialog::OnTimer(nIDEvent);
            return;
            }
        break;
        }

    // Find the 1st element of the queue.  Then draw each plot
    //  Complete one plot before moving to the next.
    if (m_plistUtData.IsEmpty() ) return ;

    // DO NOT change the calling order of the following functions
	m_bWriteToFile = FALSE;
	m_bBackward = FALSE;
	m_bPipeJustLeft = FALSE;
    DrawMap();
    if ( m_bWallCheck)  DrawWall();
    if ( m_bLongCheck)  DrawLong();
    if ( m_bTranCheck)  DrawTran();
    if ( m_bOblq1Check) DrawOblq1();
    if ( m_bOblq2Check) DrawOblq2();
    if ( m_bOblq3Check) DrawOblq3();
	if ( m_bLaminCheck) DrawLamin();
	if (m_bBackward)
	{
		RefreshWindow();
		m_bBackward = FALSE;
	}
	if (m_bPipeJustLeft)
	{
		m_bPipeJustLeft = FALSE;

#if ( (SYSTEM_ID == RAW_WALL_SYS) || (SYSTEM_SUB_ID == BESSEMER_SYS) )
		if (m_nHomeAway == 0)
			ReverseReport((short) m_nAwayStopXloc, (short) SiteDefault.nDefaultXOffset2);
#endif

		if (m_bPrint)  // autoprint
			PrintReportNow();
	}

    int nOnlyOnce = 0;

    // If recording, do it now
#if 1   
	I_MSG_RUN *pImsgChnl;
    if ( (m_nControlSel == INSPECT_RECORD) && 
         (m_pDataFile) )
    {
		g_CriticalSectionChnls.Lock();
        while (!m_plistUtData.IsEmpty())
        {
            pImsg01 = (I_MSG_RUN *) m_plistUtData.RemoveHead();
            if (nOnlyOnce == 0)
            {
                SetDlgItemInt (IDC_EDIT_JOINTNUM, pImsg01->InspHdr.JointNumber, FALSE);
                nOnlyOnce++;
            }
            // Put the last OBSERVED time into the data record
            pImsg01->InspHdr.time = m_tTimeNow;
			m_plistUtDataFile.AddTail( (void *) pImsg01 );

			if ( (pCTscanDlg->m_pChnlTraceDlg != NULL) && (pImsg01->MstrHdr.MsgId == RUN_MODE) )
			{
				pImsgChnl = new I_MSG_RUN;
				memcpy( (void *) pImsgChnl, (void *) pImsg01, sizeof(I_MSG_RUN) );
				g_pTcpListUtDataChnls.AddTail( (void *) pImsgChnl );
			}
        }
		g_CriticalSectionChnls.Unlock();

		if (m_bWriteToFile)
		{
			WriteJointToFile();
			m_bWriteToFile = FALSE;
		}
    }
#endif

    // Now that all samples in list have been drawn on all 
    // display areas, empty list.

	g_CriticalSectionChnls.Lock();
    while (!m_plistUtData.IsEmpty() )
    {
        pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();
        if (nOnlyOnce == 0)
        {
            SetDlgItemInt (IDC_EDIT_JOINTNUM, pImsg01->InspHdr.JointNumber, FALSE);
            nOnlyOnce++;
        }

		if ( (pCTscanDlg->m_pChnlTraceDlg != NULL) && (pImsg01->MstrHdr.MsgId == RUN_MODE) )
			g_pTcpListUtDataChnls.AddTail( (void *) pImsg01 );
		else
			delete pImsg01;
    }
	g_CriticalSectionChnls.Unlock();

	TRACE("CInspect::OnTimer\n");
    CDialog::OnTimer(nIDEvent);

	}	// CInspect::OnTimer(UINT nIDEvent)

void CInspect::KillMe() 
	{
    // Public access to OnCancel
    OnCancel();
	}


/**************  Drawing Routines *********************************/

void CInspect::DrawThold(int nGraph)
    {
    // nGraph select which graph the thresholds are for
    // nID and nR are the percent levels for the thresholds
    // 0=wall, 1=long, 2=tran, 3=oblq1, 4= oblq2, 5= oblq3

    CPen *penOld;
    CRect rect;
    CClientDC dc_wall(&m_cbInspWall);
    CClientDC dc_long(&m_cbInspLong);
    CClientDC dc_tran(&m_cbInspTran);
    // oblq1
    CClientDC dc_oblq1(&m_cbInspOblq1);
    // oblq2
    CClientDC dc_oblq2(&m_cbInspOblq2);
    // oblq3
    CClientDC dc_oblq3(&m_cbInspOblq3);
	CClientDC dc_lamin(&m_cbInspLamin);

    CClientDC *pdc;
    CButton *pb;
    int *TholdIdLast, *TholdOdLast;
    int nID, nOD;       // current ID/OD reject levels
    int dummy = -11;
	int nBias = 0;

    switch (nGraph)
        {
    case 0:
        // Wall
        pdc = &dc_wall;     // which device context
        pb = &m_cbInspWall; // which button resource
        TholdIdLast = &m_nTholdWidLast; // min
        TholdOdLast = &m_nTholdWodLast;
        nID = m_nTholdThin = ConfigRec.UtRec.TholdWall[0];
        nOD = m_nTholdThick = ConfigRec.UtRec.TholdWall[1];
        break;

    case 1:
        // Long
        pdc = &dc_long;
        pb = &m_cbInspLong; // which button resource
        TholdIdLast = &m_nTholdLidLast;
        TholdOdLast = &m_nTholdLodLast;
        nID = m_nTholdLid = ConfigRec.UtRec.TholdLong[0][0];
        nOD = m_nTholdLod = ConfigRec.UtRec.TholdLong[0][1];
    
        break;

    case 2:
        // Tran
        pdc = &dc_tran;
        pb = &m_cbInspTran; // which button resource
        TholdIdLast = &m_nTholdTidLast;
        TholdOdLast = &m_nTholdTodLast;
        nID = m_nTholdTid = ConfigRec.UtRec.TholdLong[1][0];
        nOD = m_nTholdTod = ConfigRec.UtRec.TholdLong[1][1];
        break;

    case 3:
        // Oblq1
        pdc = &dc_oblq1;
        pb = &m_cbInspOblq1;    // which button resource
        TholdIdLast = &m_nTholdQ1idLast;
        TholdOdLast = &m_nTholdQ1odLast;
        nID = m_nTholdQ1id = ConfigRec.UtRec.TholdLong[2][0];
        nOD = m_nTholdQ1od = ConfigRec.UtRec.TholdLong[2][1];
        break;

    case 4:
        // Oblq2
        pdc = &dc_oblq2;
        pb = &m_cbInspOblq2;    // which button resource
        TholdIdLast = &m_nTholdQ2idLast;
        TholdOdLast = &m_nTholdQ2odLast;
        nID = m_nTholdQ2id = ConfigRec.UtRec.TholdLong[3][0];
        nOD = m_nTholdQ2od = ConfigRec.UtRec.TholdLong[3][1];
        break;

    case 5:
        // Oblq3
        pdc = &dc_oblq3;
        pb = &m_cbInspOblq3;    // which button resource
        TholdIdLast = &m_nTholdQ3idLast;
        TholdOdLast = &m_nTholdQ3odLast;
        nID = m_nTholdQ3id = ConfigRec.UtRec.TholdLong[4][0];
        nOD = m_nTholdQ3od = ConfigRec.UtRec.TholdLong[4][1];
        break;

    case 6:
        // laminar
        pdc = &dc_lamin;
        pb = &m_cbInspLamin;    // which button resource
        TholdIdLast = &m_nTholdLamidLast;
        TholdOdLast = &m_nTholdLamodLast;
        nID = m_nTholdLamid = ConfigRec.UtRec.TholdLong[5][0];
        nOD = m_nTholdLamod = ConfigRec.UtRec.TholdLong[5][1];
        break;

    default:
        TholdIdLast = &dummy;
        TholdOdLast = &dummy;
        return;     // do nothing

        }

    // Get the client rectangle boundaries for the Image Map graph (Button)
    pb->GetClientRect(&rect);
    rect.NormalizeRect();




    if(nGraph) 
        {//Draw threshold line other than Wall
        // Erase previous tholds if they exist

        // Move the coordinate origin to the lower left corner
        pdc->SetViewportOrg( 0, rect.Height());

        // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
        pdc->SetMapMode(MM_ANISOTROPIC);

#if (SYSTEM_ID == RAW_WALL_SYS)
		if (nGraph == 4)  //oblq2
			pdc->SetWindowExt(m_nScale,-40);   // define size of window in logical units
		else
			pdc->SetWindowExt(m_nScale,-200);   // define size of window in logical units
#else
        pdc->SetWindowExt(m_nScale,-200);   // define size of window in logical units
#endif
        // 750  1 INCH  x increments, 200 % on y axis

        // tell windows how big this box is physically in pixels
        pdc->SetViewportExt( rect.Width(), rect.Height());

        // OD on top.  Biased by 100%
        penOld = pdc->SelectObject(&penWhite2);
        if ( *TholdOdLast > 0)
        {
#if (SYSTEM_ID == RAW_WALL_SYS)
			if (nGraph == 4)  //oblq2
				nBias = 20;
			else
				nBias = 100;
#else
			nBias = 100;
#endif
            pdc->MoveTo(2, *TholdOdLast + nBias);
            pdc->LineTo(m_nScale-2, *TholdOdLast + nBias);
        }
        *TholdOdLast = nOD;
        dummy = -12;

        // ID on bottom of chart.  No bias
        if ( *TholdIdLast > 0)
            {
            pdc->MoveTo(2, *TholdIdLast);
            pdc->LineTo(m_nScale-2, *TholdIdLast);
            }
        *TholdIdLast = nID;

        // Draw OD line as solid blue
        pdc->SelectObject(&penBlue1);

        pdc->MoveTo(2, nOD + nBias);
        pdc->LineTo(m_nScale-2, nOD + nBias);

        // Draw ID as red line
        pdc->SelectObject(&penRed1);
        pdc->MoveTo(2, nID);
        pdc->LineTo(m_nScale-2, nID);

        // Draw center dividing line separating Od from Id
        pdc->SelectObject(&penBlack1);

        pdc->MoveTo(2, nBias);
        pdc->LineTo(m_nScale-2, nBias);


        }

    else
        {//Draw threshold line for Wall
        // Erase previous tholds if they exist
#if 1

        // Move the coordinate origin to the center left edge
        pdc->SetViewportOrg( 0, rect.Height()/2);

        // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
        pdc->SetMapMode(MM_ANISOTROPIC);

        pdc->SetWindowExt(m_nScale,-(2*MAX_DELTA_WALL) );   // define size of window in logical units
        // 750  1 INCH  x increments, 40 % on y axis
        // tell windows how big this box is physically in pixels
        pdc->SetViewportExt( rect.Width(), rect.Height());

        
        penOld = pdc->SelectObject(&penWhite2);

        if ( *TholdOdLast > 0)
            {
            pdc->MoveTo(2, *TholdOdLast);
            pdc->LineTo(m_nScale-2, *TholdOdLast);
            }
        *TholdOdLast = nOD;
        dummy = -12;

        if ( *TholdIdLast < 0)
            {
            pdc->MoveTo(2, *TholdIdLast);
            pdc->LineTo(m_nScale-2, *TholdIdLast);
            }
        *TholdIdLast = nID;

        // Draw black nominal wall line in center of graph
        penOld = pdc->SelectObject(&penBlack1);
        pdc->MoveTo(2, 0);
        pdc->LineTo(m_nScale-2, 0);


        // Draw OD line as solid blue
        pdc->SelectObject(&penBlue1);

        pdc->MoveTo(2, nOD);
        pdc->LineTo(m_nScale-2, nOD);

        // Draw ID as red line
        pdc->SelectObject(&penRed1);
        pdc->MoveTo(2, nID);
        pdc->LineTo(m_nScale-2, nID);
#endif      
        }

    // Display textual thold value
    UpdateData(FALSE);// Copy variables to screen

	}

/**************  Drawing Routines *********************************/

//BOOL CInspect::AddFlaw(short x, int radial, int y, 
//                  BYTE ChnlType, BYTE ChnlNum)
//{   
    
//}


BOOL CInspect::AddFlaw2(short x, int radial, int y, 
                  BYTE ChnlType, BYTE ChnlNum, I_MSG_RUN *pImsg01)
{   // create memory for flaw, add to appropriate list
	if (m_bAllFlaw)
		return AddAllFlaws(x, radial, y, ChnlType, ChnlNum, pImsg01);

    FLAW_REC *pFlaw, *pFlaw2;
	FLAW_REC tmpFlaw;
    FLAW_REC *pF;
    POSITION pos,lpos;
    CString  szTmp, szChnl;
    float xx, fwall;
    int amp, rad, nx;

    pFlaw = new FLAW_REC;
    pFlaw->pipenum = m_dwJointNum;
    pFlaw->xloc = x;
    pFlaw->radial = radial; // which segment

    pFlaw->ChnlType = ChnlType;
    pFlaw->ChnlNum = ChnlNum;
    pFlaw->amp = y;
    pFlaw->wall = 0;

	pFlaw2 = &tmpFlaw;
	memcpy( (void *) pFlaw2, (void *) pFlaw, sizeof(FLAW_REC));
	
//    if ( !(pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) )
    {                //process consolidated data only
        switch (ChnlType)
        {
         case IS_WALL_MIN:
         case IS_WALL_MAX:
			 //if ( (ChnlType == IS_WALL_MAX) && !m_bThickWall )
				 //break;

            pFlaw->amp = pFlaw2->amp = 0;
            if (y<0) y=0;
            pFlaw->wall = pFlaw2->wall = y;
        // Add info to flaw list 
            if (m_plistWallFlaw.GetCount()==0)
                    m_plistWallFlaw.AddTail( (void *) pFlaw);
            else
            {
				/* do peak hold for the same flaw (same xloc, clock, and type) */
				pos = m_plistWallFlaw.GetHeadPosition();
				while ( pos != NULL )
				{
					pF = (FLAW_REC *) m_plistWallFlaw.GetNext(pos);
					if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
						&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
					{
						if ( (ChnlType == IS_WALL_MIN) && (pFlaw->wall < pF->wall) ) 
						{
							pF->wall = pFlaw->wall;
							pF->ChnlNum = pFlaw->ChnlNum;
						}
						if ( (ChnlType == IS_WALL_MAX) && (pFlaw->wall > pF->wall) ) 
						{
							pF->wall = pFlaw->wall;
							pF->ChnlNum = pFlaw->ChnlNum;
						}
						delete pFlaw;
						goto sortend;
					}
				}

                for (pos=m_plistWallFlaw.GetHeadPosition();pos != NULL; )
                {
                    lpos=pos;
                    pF = (FLAW_REC *) m_plistWallFlaw.GetNext(pos);
					if ( pFlaw->xloc < pF->xloc) 
                    {
						m_plistWallFlaw.InsertBefore(lpos, (void *) pFlaw);
						m_nTotalWallCnt++;
                        goto sortend;
					}
				} 
				{
					m_plistWallFlaw.AddTail( (void *) pFlaw);
				}
            }
					m_nTotalWallCnt++;
        break;


        case IS_LONG_ID:
        case IS_LONG_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistLongFlaw.GetCount()==0)
                        m_plistLongFlaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistLongFlaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistLongFlaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistLongFlaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistLongFlaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistLongFlaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						//if (j >= m_plistLongFlaw.GetCount())
						m_plistLongFlaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
        break;


        case IS_TRAN_ID:
        case IS_TRAN_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistTranFlaw.GetCount()==0)
                        m_plistTranFlaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistTranFlaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistTranFlaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistTranFlaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistTranFlaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistTranFlaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						m_plistTranFlaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
        break;


        case IS_OBQ1_ID:
        case IS_OBQ1_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistOblq1Flaw.GetCount()==0)
                        m_plistOblq1Flaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistOblq1Flaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistOblq1Flaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistOblq1Flaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistOblq1Flaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistOblq1Flaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						m_plistOblq1Flaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
        break;

        case IS_OBQ2_ID:
        case IS_OBQ2_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistOblq2Flaw.GetCount()==0)
                        m_plistOblq2Flaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistOblq2Flaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistOblq2Flaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistOblq2Flaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistOblq2Flaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistOblq2Flaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						m_plistOblq2Flaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
       break;


        case IS_OBQ3_ID:
        case IS_OBQ3_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistOblq3Flaw.GetCount()==0)
                        m_plistOblq3Flaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistOblq3Flaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistOblq3Flaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistOblq3Flaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistOblq3Flaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistOblq3Flaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
				m_plistOblq3Flaw.AddTail( (void *) pFlaw);
                }
				m_nTotalFlawCnt++;
        break;

        case IS_LAM_LOG:
        case IS_LAM_AMP:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistLaminFlaw.GetCount()==0)
                        m_plistLaminFlaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistLaminFlaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistLaminFlaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlType == pF->ChnlType)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG))
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistLaminFlaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistLaminFlaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistLaminFlaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
				m_plistLaminFlaw.AddTail( (void *) pFlaw);
                }
				m_nTotalFlawCnt++;
        break;

        default:
			break;
        }   // end switch
    }
sortend:

	//        if (m_plistUtData.IsEmpty() ) return TRUE;

    //pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();

    //TRACE("AddFlaw: wLineStatus = 0x%08X\n",pImsg01->InspHdr.wLineStatus);
    //TRACE("AddFlaw: xloc        = %d\n\n",pImsg01->InspHdr.xloc);
    if ( (pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) ) 
        {       //real time flaw report on display screen only
        //erase box
            nx = pFlaw2->xloc;       // from home or always on replay

            xx =  ((float)nx) / 12.0f;      // feet
            if ( m_bMetric) xx *= 0.3048f;  // meters
            amp =  (BYTE)pFlaw2->amp;
            if ( amp > 100) amp = 100;      // no over range allowed
            if ( amp < 0) amp = 0;
            if (pFlaw2->wall < 0) pFlaw2->wall =0;

            rad = (BYTE)pFlaw2->radial*12/N_SEG;
            if ( rad == 0) rad = 12;

            szFlaw.Format(_T("%5.2f %4d "), xx, rad);

            switch (pFlaw2->ChnlType)
            {
            case IS_WALL_MIN:
            case IS_WALL_MAX:
                    // wall
                    fwall = (float)pFlaw2->wall;
                    fwall /= 1000.0f;       // to inches
                    if (m_bMetric)
                            {
                            fwall *= 25.4f; // to millimeters
                            szTmp.Format(_T(" %6.2f   "), fwall);
                            }
                    else    // English
                            szTmp.Format(_T("%6.3f   "), fwall);

                    szFlaw += szTmp;
                    szFlaw += _T("W");
                    break;

            case IS_LONG_ID:
            case IS_LONG_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("L");
                    break;
            case IS_TRAN_ID:
            case IS_TRAN_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("T");
                    break;
            case IS_OBQ1_ID:
            case IS_OBQ1_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("Q1");
                    break;
            case IS_OBQ2_ID:
            case IS_OBQ2_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("Q2");
                    break;
            case IS_OBQ3_ID:
            case IS_OBQ3_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("Q3");
                    break;
            case IS_LAM_LOG:
            case IS_LAM_AMP:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("LA");
                    break;
            default:
                    break;
            }

                if ((pFlaw2->ChnlType == IS_LAM_LOG) || 
                    (pFlaw2->ChnlType == IS_LAM_AMP))
                {
                    if (pFlaw2->ChnlType & 1) szFlaw += _T("A-");
                    else  szFlaw += _T("L-");
                }
                else
                {
                    if (pFlaw2->ChnlType >= IS_LONG)
                        {
                        if (pFlaw2->ChnlType & 1) szFlaw += _T("OD-");
                        else  szFlaw += _T("ID-");
                        }
                    else
                        {
                        if (pFlaw2->ChnlType & 1) szFlaw += _T("K-");
                        else  szFlaw += _T("N-");
                        }
                }
            szChnl.Format(_T("%02d"),pFlaw2->ChnlNum+1);
            szFlaw += szChnl;             // add chnl number 1-80

			if (m_bRealTimeReport)
			{
				if (m_pFlawReport == NULL)
				{
					m_pFlawReport = new Ftext(this, m_nID);
					if (m_pFlawReport) m_pFlawReport->Create(IDD_Dtext);
					m_pFlawReport->m_LBtext.AddString(szFlaw);
					m_pFlawReport->ShowWindow(SW_SHOW);
				}
    			else
				{

					//TRACE("%s\n",szFlaw);
					m_pFlawReport->m_LBtext.AddString(szFlaw);
					m_pFlawReport->ShowWindow(SW_SHOW);
					(m_pFlawReport->m_LBtext).PostMessage(WM_VSCROLL, SB_BOTTOM, 0);
				}
			}

			}
           return TRUE;
}


BOOL CInspect::AddAllFlaws(short x, int radial, int y, 
                  BYTE ChnlType, BYTE ChnlNum, I_MSG_RUN *pImsg01)
{   // create memory for flaw, add to appropriate list
    FLAW_REC *pFlaw, *pFlaw2;
	FLAW_REC tmpFlaw;
    FLAW_REC *pF;
    POSITION pos,lpos;
    CString  szTmp, szChnl;
    float xx, fwall;
    int amp, rad, nx;

    pFlaw = new FLAW_REC;
    pFlaw->pipenum = m_dwJointNum;
    pFlaw->xloc = x;
    pFlaw->radial = radial; // which segment

    pFlaw->ChnlType = ChnlType;
    pFlaw->ChnlNum = ChnlNum;
    pFlaw->amp = y;
    pFlaw->wall = 0;

	pFlaw2 = &tmpFlaw;
	memcpy( (void *) pFlaw2, (void *) pFlaw, sizeof(FLAW_REC));
	
//    if ( !(pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) )
    {                //process consolidated data only
        switch (ChnlType)
        {
         case IS_WALL_MIN:
         case IS_WALL_MAX:
			 //if ( (ChnlType == IS_WALL_MAX) && !m_bThickWall )
				 //break;

            pFlaw->amp = pFlaw2->amp = 0;
            if (y<0) y=0;
            pFlaw->wall = pFlaw2->wall = y;
        // Add info to flaw list 
            if (m_plistWallFlaw.GetCount()==0)
                    m_plistWallFlaw.AddTail( (void *) pFlaw);
            else
            {
				/* do peak hold for the same flaw (same xloc, clock, and type) */
				pos = m_plistWallFlaw.GetHeadPosition();
				while ( pos != NULL )
				{
					pF = (FLAW_REC *) m_plistWallFlaw.GetNext(pos);
					if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
						&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
						&& (pFlaw->ChnlType == pF->ChnlType) )
					{
						if ( (ChnlType == IS_WALL_MIN) && (pFlaw->wall < pF->wall) ) 
						{
							pF->wall = pFlaw->wall;
						}
						if ( (ChnlType == IS_WALL_MAX) && (pFlaw->wall > pF->wall) ) 
						{
							pF->wall = pFlaw->wall;
						}
						delete pFlaw;
						goto sortend;
					}
				}

                for (pos=m_plistWallFlaw.GetHeadPosition();pos != NULL; )
                {
                    lpos=pos;
                    pF = (FLAW_REC *) m_plistWallFlaw.GetNext(pos);
					if ( pFlaw->xloc < pF->xloc) 
                    {
						m_plistWallFlaw.InsertBefore(lpos, (void *) pFlaw);
						m_nTotalWallCnt++;
                        goto sortend;
					}
				} 
				{
					m_plistWallFlaw.AddTail( (void *) pFlaw);
				}
            }
					m_nTotalWallCnt++;
        break;


        case IS_LONG_ID:
        case IS_LONG_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistLongFlaw.GetCount()==0)
                        m_plistLongFlaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistLongFlaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistLongFlaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
							&& (pFlaw->ChnlType == pF->ChnlType) )
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistLongFlaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistLongFlaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistLongFlaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						//if (j >= m_plistLongFlaw.GetCount())
						m_plistLongFlaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
        break;


        case IS_TRAN_ID:
        case IS_TRAN_OD:
					//if ( (x>=30) && (x<=36) && (ChnlType==IS_TRAN_ID) )
						//TRACE("x=%d, Chnl=%d, amp=%d\n", x, ChnlNum+1, y);

            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistTranFlaw.GetCount()==0)
                        m_plistTranFlaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistTranFlaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistTranFlaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
							&& (pFlaw->ChnlType == pF->ChnlType) )
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistTranFlaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistTranFlaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistTranFlaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						m_plistTranFlaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
        break;


        case IS_OBQ1_ID:
        case IS_OBQ1_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistOblq1Flaw.GetCount()==0)
                        m_plistOblq1Flaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistOblq1Flaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistOblq1Flaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
							&& (pFlaw->ChnlType == pF->ChnlType) )
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistOblq1Flaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistOblq1Flaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistOblq1Flaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						m_plistOblq1Flaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
        break;

        case IS_OBQ2_ID:
        case IS_OBQ2_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistOblq2Flaw.GetCount()==0)
                        m_plistOblq2Flaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistOblq2Flaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistOblq2Flaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
							&& (pFlaw->ChnlType == pF->ChnlType) )
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistOblq2Flaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistOblq2Flaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistOblq2Flaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
					{
						m_plistOblq2Flaw.AddTail( (void *) pFlaw);
					}
                }
						m_nTotalFlawCnt++;
       break;


        case IS_OBQ3_ID:
        case IS_OBQ3_OD:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistOblq3Flaw.GetCount()==0)
                        m_plistOblq3Flaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistOblq3Flaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistOblq3Flaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
							&& (pFlaw->ChnlType == pF->ChnlType) )
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistOblq3Flaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistOblq3Flaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistOblq3Flaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
				m_plistOblq3Flaw.AddTail( (void *) pFlaw);
                }
				m_nTotalFlawCnt++;
        break;

        case IS_LAM_LOG:
        case IS_LAM_AMP:
            pFlaw->amp = y;
            pFlaw->wall = 0;
        // Add info to flaw list 
                if (m_plistLaminFlaw.GetCount()==0)
                        m_plistLaminFlaw.AddTail( (void *) pFlaw);
                else
                {
					/* do peak hold for the same flaw (same xloc, clock, and type) */
					pos = m_plistLaminFlaw.GetHeadPosition();
					while ( pos != NULL )
					{
						pF = (FLAW_REC *) m_plistLaminFlaw.GetNext(pos);
						if (( pFlaw->xloc == pF->xloc) && (pFlaw->ChnlNum == pF->ChnlNum)
							&& (pFlaw->radial*12/N_SEG == pF->radial*12/N_SEG)
							&& (pFlaw->ChnlType == pF->ChnlType) )
						{
							if (pFlaw->amp > pF->amp) 
							{
								pF->amp = pFlaw->amp;
								pF->ChnlNum = pFlaw->ChnlNum;
							}
							delete pFlaw;
							goto sortend;
						}
					}

                    for (pos=m_plistLaminFlaw.GetHeadPosition();pos != NULL; )
                    {
                        lpos=pos;
                        pF = (FLAW_REC *) m_plistLaminFlaw.GetNext(pos);
						if ( pFlaw->xloc < pF->xloc) 
                        {
							m_plistLaminFlaw.InsertBefore(lpos, (void *) pFlaw);
							m_nTotalFlawCnt++;
                            goto sortend;
						}
					} 
				m_plistLaminFlaw.AddTail( (void *) pFlaw);
                }
				m_nTotalFlawCnt++;
        break;

        default:
			break;
        }   // end switch
    }
sortend:

	//        if (m_plistUtData.IsEmpty() ) return TRUE;

    //pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();

    //TRACE("AddFlaw: wLineStatus = 0x%08X\n",pImsg01->InspHdr.wLineStatus);
    //TRACE("AddFlaw: xloc        = %d\n\n",pImsg01->InspHdr.xloc);
    if ( (pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) ) 
        {       //real time flaw report on display screen only
        //erase box
            nx = pFlaw2->xloc;       // from home or always on replay

            xx =  ((float)nx) / 12.0f;      // feet
            if ( m_bMetric) xx *= 0.3048f;  // meters
            amp =  (BYTE)pFlaw2->amp;
            if ( amp > 100) amp = 100;      // no over range allowed
            if ( amp < 0) amp = 0;
            if (pFlaw2->wall < 0) pFlaw2->wall =0;

            rad = (BYTE)pFlaw2->radial*12/N_SEG;
            if ( rad == 0) rad = 12;

            szFlaw.Format(_T("%5.2f %4d "), xx, rad);

            switch (pFlaw2->ChnlType)
            {
            case IS_WALL_MIN:
            case IS_WALL_MAX:
                    // wall
                    fwall = (float)pFlaw2->wall;
                    fwall /= 1000.0f;       // to inches
                    if (m_bMetric)
                            {
                            fwall *= 25.4f; // to millimeters
                            szTmp.Format(_T(" %6.2f   "), fwall);
                            }
                    else    // English
                            szTmp.Format(_T("%6.3f   "), fwall);

                    szFlaw += szTmp;
                    szFlaw += _T("W");
                    break;

            case IS_LONG_ID:
            case IS_LONG_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("L");
                    break;
            case IS_TRAN_ID:
            case IS_TRAN_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("T");
                    break;
            case IS_OBQ1_ID:
            case IS_OBQ1_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("Q1");
                    break;
            case IS_OBQ2_ID:
            case IS_OBQ2_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("Q2");
                    break;
            case IS_OBQ3_ID:
            case IS_OBQ3_OD:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("LA");
                    break;
            case IS_LAM_LOG:
            case IS_LAM_AMP:
                    // flaw
                    szTmp.Format(_T("    %3d   "), amp);
                    szFlaw += szTmp;
                    szFlaw += _T("LA");
                    break;
            default:
                    break;
            }

                if ((pFlaw2->ChnlType == IS_LAM_LOG) || 
                    (pFlaw2->ChnlType == IS_LAM_AMP))
                {
                    if (pFlaw2->ChnlType & 1) szFlaw += _T("A-");
                    else  szFlaw += _T("L-");
                }
                else
                {
                    if (pFlaw2->ChnlType >= IS_LONG)
                        {
                        if (pFlaw2->ChnlType & 1) szFlaw += _T("OD-");
                        else  szFlaw += _T("ID-");
                        }
                    else
                        {
                        if (pFlaw2->ChnlType & 1) szFlaw += _T("K-");
                        else  szFlaw += _T("N-");
                        }
                }
            szChnl.Format(_T("%02d"),pFlaw2->ChnlNum+1);
            szFlaw += szChnl;             // add chnl number 1-80

			if (m_bRealTimeReport)
			{
				if (m_pFlawReport == NULL)
				{
					m_pFlawReport = new Ftext(this, m_nID);
					if (m_pFlawReport) m_pFlawReport->Create(IDD_Dtext);
					m_pFlawReport->m_LBtext.AddString(szFlaw);
					m_pFlawReport->ShowWindow(SW_SHOW);
				}
    			else
				{

					//TRACE("%s\n",szFlaw);
					m_pFlawReport->m_LBtext.AddString(szFlaw);
					m_pFlawReport->ShowWindow(SW_SHOW);
					(m_pFlawReport->m_LBtext).PostMessage(WM_VSCROLL, SB_BOTTOM, 0);
				}
			}

			}
           return TRUE;
}


void CInspect::DrawMap()
{
    CRect MapRect;

    CClientDC dc(&m_cbMap); // get drawing context for map 
    int i,j;

    int x,y;
    BYTE ChnlNum;

    CString s,t;
    I_MSG_RUN *pImsg01;

    EXIST_MAP_RECT *pMapRect;

	int   nBackupToXlocS1 = 2000;   // station 1
	int   nBackupToXlocS2 = 2000;   // station 2

    // debug hardware
    static int n;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbMap.GetClientRect(&MapRect);
    MapRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, MapRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    // UT machines operate with N_SEG radial segements.  Scale for twice that many
    // and put Od indications in even seg's, Id indications in odd segs.

    dc.SetWindowExt(m_nScale,-2*N_SEG); // define size of window in logical units
    // 750  1 INCH  x increments, 30 radial locations on y axis

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( MapRect.Width(), MapRect.Height());



    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();


    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
//      if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;

		nBackupToXlocS1 = 2000;   // station 1
		nBackupToXlocS2 = 2000;   // station 2
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
			if ( pImsg01->InspHdr.nStation == 0 )
				nBackupToXlocS1 = pImsg01->InspHdr.JointLength;
			else
				nBackupToXlocS2 = pImsg01->InspHdr.JointLength;
			BackwardEraseMap(&dc, nBackupToXlocS1, nBackupToXlocS2);
			m_bBackward = TRUE;
		}

        // Check line status to determine when to erase
        i = 0;

        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) i |= 1;
        if (m_wOldStatMap & PIPE_PRESENT) i |= 2;
        m_wOldStatMap = pImsg01->InspHdr.wLineStatus;

        if (1)  //pImsg01->InspHdr.wLineStatus) // & FORWARD) 
            switch (i)
			{ 
             case 0:
                // no pipe but encoders running
                if ( m_nNoPipeCnt < 2)
                    {
                    m_nNoPipeCnt++;
                    if ( m_nNoPipeCnt == 2)
                        {
                        // erase previous flaw lists
/*12-18-02*/
                        EraseFlawLists();
                        }

                    }
                break;  // no pipe in system

            case 1:
                // just arrived
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
                pCTscanDlg->SwitchInspectWindows(m_nID);
#endif
                //TRACE("just arrived, m_nID = %d\n\n", m_nID);
                m_nNoPipeCnt = 0;
				m_nMapRect = 0;
                InspMapErase() ;
                EraseExistPts();
                EraseFlawLists();
                if (m_pFlawReport != NULL)
                    (m_pFlawReport->m_LBtext).ResetContent();
                InitWallStatistics();   // prep for Exxon statistics

                m_dwJointNum = (DWORD) pImsg01->InspHdr.JointNumber;

                //if ( pCTscanDlg) 
                    //pCTscanDlg->SetJointNumber(m_dwJointNum);
 
                break;  // just arrived

            case 2:
                // pipe just left system
                //m_nJointLength = pImsg01->InspHdr.JointLength;
                //TRACE("just left, m_nID = %d\n\n", m_nID);
                //These values displayed by UpdateRPM routine
                if (m_nTotalFlawCnt || m_nTotalWallCnt)
                    {   // pipe had reject, count with rejects
                    pCTscanDlg->m_lRJnt++;
                    pCTscanDlg->m_fRLen += (float)pImsg01->InspHdr.JointLength;
                    }
                else
                    {   // no flaw, good pipe
                    pCTscanDlg->m_lOKJnt++;
                    }

                pCTscanDlg->m_fTotalLen += (float)pImsg01->InspHdr.JointLength;

                UpdateStatusQRTotals();

				m_bPipeJustLeft = TRUE;

				m_nWallDifference = pImsg01->UtInsp.WallDiff;

				//m_nWallClassification = pImsg01->UtInsp.WallClassification;
#if 0 //(SYSTEM_ID == RAW_WALL_SYS)
				if (m_nWallClassification == 0.0f)
					m_nInvalidWallTimer = 45;
#endif
                // Update the wall statistics file if one is being generated
                if ( (m_nControlSel == INSPECT_RECORD) && 
                     (m_pDataCsvFile) && (pImsg01->InspHdr.JointLength >= 60) )
				{
					//if ( MessageBox(_T("Save Wall Data?"), _T("Wall Statistics"), MB_YESNO) == IDYES )
						UpdateWallStatFile(pImsg01->InspHdr.JointLength);
				}

				m_bWriteToFile = TRUE;

                break;
            case 3:
                m_nNoPipeCnt = 0;
                break;  // been here for a while
           }   // pipestatus


        // Same x Location for all radial elements of UT
        x = pImsg01->InspHdr.xloc % m_nScale;
        for ( i = 0; i < MAX_SHOES; i++) CInspect::m_EchoBits.Shoe[i] |= pImsg01->InspHdr.EchoBit[i];

        // Only if Inspect status is true
        if (!(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE))
		{
            //  get next in data list
            goto ENDLOOP;
        }

        /**** HORIZONTAL RECTANGLES ****/

        /*********** WALL ************/ 
        // Even if wall not plotted, compute averages
        switch  ( ConfigRec.JobRec.WallStatFlag)
			{
			case WALL_OPT_NONE:
				default:
				break;

			case WALL_OPT_EXXON:
				if ( (pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) )
					break;
				if ( (pImsg01->InspHdr.status[1] & WALL_INCLUDED) )
					ExxonWallMovingAverage (pImsg01);
				break;

			case WALL_OPT_TUBO:
				if ( (pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) )
					break;
				if ( (pImsg01->InspHdr.status[1] & WALL_INCLUDED) )
					AccumulateTuboWallStats(pImsg01);
				break;

			}	//end switch


        if ( m_bWallCheck && (x > 1)  && (pImsg01->InspHdr.status[1] & WALL_INCLUDED) )
        {   // Display wall

           // Look at Wall Max map
           if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
		   {
                y = pImsg01->UtInsp.SegWallMax[i];
                if ( y >= ConfigRec.UtRec.TholdWallThds[1] )
					{  // y above map thold
                       // Od in odd seg location to avoid over writing Od indications
                       j = 2*i + 1;
                       if ( j >= 2*N_SEG) j = 2*(N_SEG) - 1;

					   if (m_nMapRect < MAP_RECT_LIMIT)
					   {
						   m_nMapRect++;
						   dc.FillSolidRect(x+1,j,(m_nScale/100),1, RGB(0,0,255));

						   pMapRect = new EXIST_MAP_RECT;
						   pMapRect->bIdOd = 1;
						   pMapRect->x = (short) x+1;
						   pMapRect->y = (BYTE) j;
						   pMapRect->nType = 0;
						   m_pListExistMapRect.AddTail ( (void *) pMapRect);
					   }

                       ChnlNum = pImsg01->UtInsp.SegMaxChnl[i];
                       AddFlaw2(x, i, y, IS_WALL_MAX,ChnlNum, pImsg01);
                   }   // y above map thold
		   }  // i loop OD

            // Look at Wall Min map
            // ID offset 1,1 in x,y directions from actual to show next to od

           if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
           {
                y = pImsg01->UtInsp.SegWallMin[i];
                if ( y <= ConfigRec.UtRec.TholdWallThds[0] )
                {   // below min wall thold [0]
                    // Id in even seg location to avoid over writing Od indications
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					    m_nMapRect++;
						dc.FillSolidRect(x,2*i,(m_nScale/100),1, RGB(255,0,0));

						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 0;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }
                    ChnlNum = pImsg01->UtInsp.SegMinChnl[i];
                    AddFlaw2(x, i, y, IS_WALL_MIN, ChnlNum, pImsg01);
                }   // Below thold
            }   // i loop ID
        }   // Display wall
        /*********** WALL ************/ 


        /*********** LONG ************/ 
        if (m_bLongCheck && (x > 1))
        {   // Display long

            // Look at Long OD
            if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegLodFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[0][1] )
                {   // y above OD thold[1]
                    // Od in odd seg location to avoid over writing Od indications
                    j = 2*i + 1;
                    if ( j >= 2*N_SEG) j = 2*(N_SEG) - 1;

				    if (m_nMapRect < MAP_RECT_LIMIT)
					{
					    m_nMapRect++;
						dc.FillSolidRect(x+1,j,(m_nScale/100),1, RGB(0,0,255));

						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 1;
						pMapRect->x = (short) x+1;
						pMapRect->y = (BYTE) j;
						pMapRect->nType = 1;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
					}

                    ChnlNum = pImsg01->UtInsp.SegLodChnl[i];

                    //TRACE("DrawLong OD: wLineStatus = 0x%08X\n",pImsg01->InspHdr.wLineStatus);
                    //TRACE("DrawLong OD: xloc        = %d\n\n",pImsg01->InspHdr.xloc);

                    AddFlaw2(x, i, y, IS_LONG_OD, ChnlNum, pImsg01);
                }   // y above map thold
            }   // i loop OD

            // Look at Long map
            // ID offset 1,1 in x,y directions from actual to show next to od

            if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegLidFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[0][0] )
                {   // above ID thold [0]
                    // Id in even seg location to avoid over writing Od indications

				    if (m_nMapRect < MAP_RECT_LIMIT)
					{
					    m_nMapRect++;
						dc.FillSolidRect(x,2*i,(m_nScale/100),1, RGB(255,0,0));

						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 1;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
					}

                    ChnlNum = pImsg01->UtInsp.SegLidChnl[i];

                    //TRACE("DrawLong ID: wLineStatus = 0x%08X\n",pImsg01->InspHdr.wLineStatus);
                    //TRACE("DrawLong ID: xloc        = %d\n",pImsg01->InspHdr.xloc);
    
                    AddFlaw2(x, i, y, IS_LONG_ID, ChnlNum, pImsg01);
                }
            }   // i loop ID
        }   // Display Long
        /*********** LONG ************/ 

        /**** VERTICAL RECTANGLES ****/

        /*********** TRAN ************/ 
        if (m_bTranCheck && (x > 1))
        {   // Display Tran

            // Look at Tran OD
            if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegTodFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[1][1] )
                {   // y above OD thold[1]
                    // Od in odd seg location to avoid over writing Od indications

				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x,2*i,3,-3, RGB(0,0,255));
						else
							dc.FillSolidRect(x,2*i,3,3, RGB(0,0,255));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 1;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 2;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegTodChnl[i];
                    AddFlaw2(x, i, y, IS_TRAN_OD, ChnlNum, pImsg01);
                }   // y above  thold
            }   // i loop OD

            // Look at Tran map

            if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
                {
                y = pImsg01->UtInsp.SegTidFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[1][0] )
                {   // above ID thold [0]

				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x+3,2*i,3,-3, RGB(255,0,0));
						else
							dc.FillSolidRect(x+3,2*i,3,3, RGB(255,0,0));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x+3;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 2;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegTidChnl[i];
					//if ( (x>=30) && (x<=36) )
						//TRACE("x=%d, Chnl=%d, amp=%d\n", x, ChnlNum+1, y);
                    AddFlaw2(x, i, y, IS_TRAN_ID, ChnlNum, pImsg01);
                }
            }   // i loop ID
        }   // Display Tran
        /*********** TRAN ************/ 

        /*********** OBLQ1 ************/    
        if (m_bOblq1Check && (x > 1))
        {   // Display Oblq1

            // Look at Oblq1 OD
            if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegQ1odFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[2][1] )
                {   // y above OD thold[1]
                    // Od in odd seg location to avoid over writing Od indications

				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x,2*i,3,-3, RGB(0,0,255));
						else
							dc.FillSolidRect(x,2*i,3,3, RGB(0,0,255));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 1;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 3;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegQ1odChnl[i];
                    AddFlaw2(x, i, y, IS_OBQ1_OD, ChnlNum, pImsg01);
                }   // y above  thold
            }   // i loop OD

            // Look at Oblq1 map

            if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegQ1idFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[2][0] )
                {   // above ID thold [0]

				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x+3,2*i,3,-3, RGB(255,0,0));
						else
							dc.FillSolidRect(x+3,2*i,3,3, RGB(255,0,0));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x+3;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 3;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegQ1idChnl[i];
                    AddFlaw2(x, i, y, IS_OBQ1_ID, ChnlNum, pImsg01);
                }
            }   // i loop ID
        }   // Display Oblq1

        /*********** OBLQ1 ************/    

#if 1  //(SYSTEM_ID != RAW_WALL_SYS)
        /*********** OBLQ2 ************/    
        if (m_bOblq2Check && (x > 1))
        {   // Display Oblq2

            // Look at Oblq2 OD
            if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegQ2odFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[3][1] )
                {   // y above OD thold[1]
                    // Od in odd seg location to avoid over writing Od indications
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x,2*i,3,-3, RGB(0,0,255));
						else
							dc.FillSolidRect(x,2*i,3,3, RGB(0,0,255));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 1;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 4;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegQ2odChnl[i];
                    AddFlaw2(x, i, y, IS_OBQ2_OD, ChnlNum, pImsg01);
                }   // y above  thold
            }   // i loop OD

            // Look at Oblq2 map

            if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegQ2idFlaw[i];
#if 0 //(SYSTEM_ID == RAW_WALL_SYS)
				if (y == 100)
					m_nInvalidWallTimer = 45;
#endif
                if ( y >= ConfigRec.UtRec.TholdLong[3][0] )
                {   // above ID thold [0]
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x+3,2*i,3,-3, RGB(255,0,0));
						else
							dc.FillSolidRect(x+3,2*i,3,3, RGB(255,0,0));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x+3;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 4;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegQ2idChnl[i];
                    AddFlaw2(x, i, y, IS_OBQ2_ID, ChnlNum, pImsg01);
                }
            }   // i loop ID
        }   // Display Oblq2

        /*********** OBLQ2 ************/    
#endif

        /*********** OBLQ3 ************/    
        if (m_bOblq3Check && (x > 1))
        {   // Display Oblq3

            // Look at Oblq3 OD
            if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegQ3odFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[4][1] )
                {   // y above OD thold[1]
                    // Od in odd seg location to avoid over writing Od indications
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x,2*i,3,-3, RGB(0,0,255));
						else
							dc.FillSolidRect(x,2*i,3,3, RGB(0,0,255));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 1;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 5;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegQ3odChnl[i];
                    AddFlaw2(x, i, y, IS_OBQ3_OD, ChnlNum, pImsg01);
                }   // y above  thold
            }   // i loop OD

            // Look at Oblq3 map

            if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegQ3idFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[4][0] )
                {   // above ID thold [0]
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x+3,2*i,3,-3, RGB(255,0,0));
						else
							dc.FillSolidRect(x+3,2*i,3,3, RGB(255,0,0));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x+3;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 5;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegQ3idChnl[i];
                    AddFlaw2(x, i, y, IS_OBQ3_ID, ChnlNum, pImsg01);
                }
            }   // i loop ID
        }   // Display Oblq3

        /*********** OBLQ3 ************/    

        /*********** LAMINAR ************/    
        if (m_bLaminCheck && (x > 1))
        {   // Display Oblq3

            // Look at Laminar Amplitude only (OD)
            if ( m_bOdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegLamAFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[5][1] )
                {   // y above OD thold[1]
                    // Od in odd seg location to avoid over writing Od indications
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x,2*i,3,-3, RGB(0,0,255));
						else
							dc.FillSolidRect(x,2*i,3,3, RGB(0,0,255));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 1;
						pMapRect->x = (short) x;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 6;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegLamAChnl[i];
                    AddFlaw2(x, i, y, IS_LAM_AMP, ChnlNum, pImsg01);
                }   // y above  thold
            }   // i loop OD

            // Look at Oblq3 map

            if ( m_bIdCheck)    for ( i = 0; i < N_SEG; i++)    // look at all 30 radial slots
            {
                y = pImsg01->UtInsp.SegLamLFlaw[i];
                if ( y >= ConfigRec.UtRec.TholdLong[5][0] )
                {   // above ID thold [0]
				   if (m_nMapRect < MAP_RECT_LIMIT)
				   {
					   m_nMapRect++;
						if ( i== N_SEG - 1)
							dc.FillSolidRect(x+3,2*i,3,-3, RGB(255,0,0));
						else
							dc.FillSolidRect(x+3,2*i,3,3, RGB(255,0,0));
						pMapRect = new EXIST_MAP_RECT;
						pMapRect->bIdOd = 0;
						pMapRect->x = (short) x+3;
						pMapRect->y = (BYTE) 2*i;
						pMapRect->nType = 6;
						m_pListExistMapRect.AddTail ( (void *) pMapRect);
				   }

                    ChnlNum = pImsg01->UtInsp.SegLamLChnl[i];
                    AddFlaw2(x, i, y, IS_LAM_LOG, ChnlNum, pImsg01);
                }
            }   // i loop ID
        }   // Display Oblq3

        /*********** LAMINAR ************/    

        /*********** ALL FLAWS ************/ 

		if (m_bAllFlaw)
		{
			WORD *pWord;
			for (j=0; j<40; j++)
			{
				switch(ConfigRec.UtRec.Shoe[j/10].Ch[j%10].Type)
				{
				default:
					break;
				case IS_WALL:
					if ( m_bWallCheck && (x > 1)  && (pImsg01->InspHdr.status[1] & WALL_INCLUDED) )
					{   // Display wall
						// Look at Wall Min map

					   if ( m_bIdCheck)
					   {
							pWord = (WORD *) &pImsg01->UtInsp.GateMaxAmp[j*2];
							y = *pWord;
							i = pImsg01->UtInsp.GateMaxClk[j*2];
							if ( y <= ConfigRec.UtRec.TholdWallThds[0] )
							{   // below min wall thold [0]
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_WALL_MIN, ChnlNum, pImsg01);
							}   // Below thold
						}   // i loop ID
					}   // Display wall
					break;
				case IS_LONG:
					if ( m_bLongCheck && (x > 1) )
					{
					   if ( m_bOdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2+1];
							i = pImsg01->UtInsp.GateMaxClk[j*2+1];
							if ( y >= ConfigRec.UtRec.TholdLong[0][1] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_LONG_OD, ChnlNum, pImsg01);
							}
						}

					   if ( m_bIdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2];
							i = pImsg01->UtInsp.GateMaxClk[j*2];
							if ( y >= ConfigRec.UtRec.TholdLong[0][0] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_LONG_ID, ChnlNum, pImsg01);
							}
						}
					}
					break;
				case IS_TRAN:
					if ( m_bTranCheck && (x > 1) )
					{
					   if ( m_bOdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2+1];
							i = pImsg01->UtInsp.GateMaxClk[j*2+1];
							if ( y >= ConfigRec.UtRec.TholdLong[1][1] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_TRAN_OD, ChnlNum, pImsg01);
							}
						}

					   if ( m_bIdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2];
							i = pImsg01->UtInsp.GateMaxClk[j*2];
							if ( y >= ConfigRec.UtRec.TholdLong[1][0] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_TRAN_ID, ChnlNum, pImsg01);

								if ( (x>=30) && (x<=36) )
									TRACE("x=%d, Chnl=%d, Amp=%d\n", x, ChnlNum+1, y);
							}
						}
					}
					break;
				case IS_OBQ1:
					if ( m_bOblq1Check && (x > 1) )
					{
					   if ( m_bOdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2+1];
							i = pImsg01->UtInsp.GateMaxClk[j*2+1];
							if ( y >= ConfigRec.UtRec.TholdLong[2][1] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_OBQ1_OD, ChnlNum, pImsg01);
							}
						}

					   if ( m_bIdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2];
							i = pImsg01->UtInsp.GateMaxClk[j*2];
							if ( y >= ConfigRec.UtRec.TholdLong[2][0] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_OBQ1_ID, ChnlNum, pImsg01);
							}
						}
					}
					break;
				case IS_OBQ2:
					if ( m_bOblq2Check && (x > 1) )
					{
					   if ( m_bOdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2+1];
							i = pImsg01->UtInsp.GateMaxClk[j*2+1];
							if ( y >= ConfigRec.UtRec.TholdLong[3][1] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_OBQ2_OD, ChnlNum, pImsg01);
							}
						}

					   if ( m_bIdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2];
							i = pImsg01->UtInsp.GateMaxClk[j*2];
							if ( y >= ConfigRec.UtRec.TholdLong[3][0] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_OBQ2_ID, ChnlNum, pImsg01);
							}
						}
					}
					break;
				case IS_OBQ3:
					if ( m_bOblq3Check && (x > 1) )
					{
					   if ( m_bOdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2+1];
							i = pImsg01->UtInsp.GateMaxClk[j*2+1];
							if ( y >= ConfigRec.UtRec.TholdLong[4][1] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_OBQ3_OD, ChnlNum, pImsg01);
							}
						}

					   if ( m_bIdCheck)
					   {
							y = pImsg01->UtInsp.GateMaxAmp[j*2];
							i = pImsg01->UtInsp.GateMaxClk[j*2];
							if ( y >= ConfigRec.UtRec.TholdLong[4][0] )
							{ 
								ChnlNum = j;
								AddFlaw2(x, i, y, IS_OBQ3_ID, ChnlNum, pImsg01);
							}
						}
					}
					break;

				}
			}
		}
        /*********** ALL FLAWS ************/    


ENDLOOP:
        if (rPosition == NULL ) break;
//      pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
  
    }   //  End while (1)

}   // end DrawMap


/******************************************************************/

void CInspect::DrawWall()
{

    CPoint ptNewOd, ptNewId;    // new  values for amalog id/od
    CRect InspWallRect;
    CPen *penOld;
    CPen *penId, *penOd;
    short NomWall;      // Nominal wall in 1/1000th inch
    short WallRange;    // delta wall max-min in 1/1000ths
    WORD PipeStatus;
	int  nBackupToXlocS1;
	CString sMinWall=" ";

    CClientDC dc(&m_cbInspWall);    // get drawing context for Wall
    //  Set up reference area for graphing

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspWall.GetClientRect(&InspWallRect);
    InspWallRect.NormalizeRect();

    // Move the coordinate origin to the center left edge
    dc.SetViewportOrg( 0, InspWallRect.Height()/2);

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);


    NomWall = (short) (1000.0f * ConfigRec.JobRec.Wall + 0.5f);
    WallRange = (short) (20.0f * ConfigRec.JobRec.Wall * 
                            (float) MAX_DELTA_WALL);

    dc.SetWindowExt(m_nScale,-WallRange);   // define size of window in logical units
    // 750  1 INCH  x increments,

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspWallRect.Width(), InspWallRect.Height());

    if (m_plistUtData.IsEmpty() ) 
		return ;

    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();


    switch (m_nScaleSel)
    {
      case 0:
          // 50 ft
          penOd = &penBlue2;
          penId = &penMagenta2;
          break;

      case 1:
      default:
          penOd = &penBlue4;
          penId = &penMagenta4;
          break;
    } //end switch

    penOd = &penBlue1;
    penId = &penRed1;

    penOld = dc.SelectObject(penOd);    // OD is blue


    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        //if (  (pImsg01->InspHdr.status[1] & WALL_INCLUDED) != WALL_INCLUDED ) goto ENDLOOP;
        // if inspect enable just went true, erase graph

		nBackupToXlocS1 = 2000;   // station 1
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
			if ( pImsg01->InspHdr.nStation == 0 )
				nBackupToXlocS1 = pImsg01->InspHdr.JointLength;
			BackwardEraseWall(&dc, nBackupToXlocS1);
			m_bBackward = TRUE;
		}
        if (  (pImsg01->InspHdr.status[1] & WALL_INCLUDED) != WALL_INCLUDED ) goto ENDLOOP;

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatWall & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatWall = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspWallErase();
				m_ptLastWallMax.x = m_ptLastWallMin.x = 0;
				m_ptLastWallMax.y = m_ptLastWallMin.y = 0;//-WallRange/2;

				SetDlgItemText(IDC_EN_MINWALL, sMinWall);
				break;  // just arrived
			case 2:
				if ( (mTubo.nMinWall >= 0) && (mTubo.nMinWall <= 2000) )
				{
					sMinWall.Format(_T("%d"), mTubo.nMinWall);
					SetDlgItemText(IDC_EN_MINWALL, sMinWall);
				}
				break;  // just left system
			case 3:
				break;  // been here for a while
        }  // end switch


        // Only if Inspect status is true
        // Check line status to determine when to erase

        // Only if Inspect status is true
        if ( !(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE ) ||
             (pImsg01->InspHdr.wLineStatus & REAL_TIME_DATA) )
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of Amalog
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;
        if (m_bOdCheck && (ptNewOd.x > 0) && ( (pImsg01->UtInsp.MaxWall > 0) || (pImsg01->UtInsp.MinWall < 0x3FFF) ) )
        {
            dc.SelectObject(penOd);
            // Look at Wall Max map
            //  Can not go below nominal wall line... y=0
            if (1)  //( PipeStatus & 1)
            {   // pipe in machine now
                ptNewOd.y = max(pImsg01->UtInsp.MaxWall - NomWall,-WallRange/2);
				if (pImsg01->UtInsp.MaxWall == 0)
					ptNewOd.y = 0;
                ptNewOd.y = min(ptNewOd.y, WallRange/2);
            }
            else
                ptNewOd.y = WallRange/2;

            if (m_ptLastWallMax.x == 0)
                m_ptLastWallMax = ptNewOd;
            dc.MoveTo(m_ptLastWallMax);
            dc.LineTo(ptNewOd);
            m_ptLastWallMax = ptNewOd;  // remember last point location

            if (m_nNumExistWall<900) 
            {
                m_ptExistWall[m_nNumExistWall][1] = ptNewOd;
                if (!m_bIdCheck)
                    m_nNumExistWall++;
            }
        }
        //else
            //m_ptLastWallMax = (0,0);

        // Look at Wall min trace
        // ID can not be above nom wall

        if ( m_bIdCheck && (ptNewId.x > 0 ) && (pImsg01->UtInsp.MinWall < 0x3FFF) )   
        {
            dc.SelectObject(penId);
            if (1)  //( PipeStatus & 1)
            {   // pipe in machine now
                ptNewId.y = min(pImsg01->UtInsp.MinWall - NomWall,WallRange/2);
				if (pImsg01->UtInsp.MinWall == 0x3FFF)
					ptNewId.y = 0;
                ptNewId.y = max(ptNewId.y,-WallRange/2);
            }
            else
                ptNewId.y = -WallRange/2;

            if (m_ptLastWallMin.x == 0)
                m_ptLastWallMin = ptNewId;
            dc.MoveTo(m_ptLastWallMin);
            dc.LineTo(ptNewId);
            m_ptLastWallMin = ptNewId;  // remember last point location

            if (m_nNumExistWall<900) 
            {
                m_ptExistWall[m_nNumExistWall][0] = ptNewId;

                m_nNumExistWall++;
            }
        }
        //else
            //m_ptLastWallMin = (0,0);


ENDLOOP:
        if ( pImsg01->InspHdr.nStation == 0 )
        {
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x0401) == 0x0401 )
				m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#else
			m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#endif
        }

        if (rPosition == NULL ) break;
//      pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
  
    }   //  End while (1)


    dc.SelectObject(penOld);

    if (m_nProgressS1 != m_nLastProgressS1)
    {
        DrawProgressLine(&dc, m_nProgressS1, 0, TRUE);
		if ( !m_bLongCheck && !m_bLaminCheck && !m_bOblq3Check)
		{
			m_bDrawProgressS1Once = TRUE;
			m_nLastProgressS1 = m_nProgressS1;
		}
    }

}


/******************************************************************/

void CInspect::DrawLong()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    WORD PipeStatus;
	int nBackupToXlocS1;

    CClientDC dc(&m_cbInspLong);    // get drawing context for  Long graph
    //  Set up reference area for graphing

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspLong.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());

    if (m_plistUtData.IsEmpty() ) return ;


    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();

    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        // Only if Inspect status is true
        // Check line status to determine when to erase
        // if inspect enable just went true, erase graph

		nBackupToXlocS1 = 2000;   // station 1
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
			if ( pImsg01->InspHdr.nStation == 0 )
				nBackupToXlocS1 = pImsg01->InspHdr.JointLength;
			BackwardEraseLong(&dc, nBackupToXlocS1);
			m_bBackward = TRUE;
		}

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatLong & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatLong = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspLongErase();
				m_ptLastLId = m_ptLastLOd = (0,0);
				break;  // just arrived
			case 2:
				break;  // just left system
			case 3:
				break;  // been here for a while
        } //end switch


        // Only if Inspect status is true
        if (!(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE) )
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of UT
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;

        if ( m_bOdCheck && (ptNewOd.x > 0) )
        {
            // Look at Long  OD map
            ptNewOd.y = min(pImsg01->UtInsp.MaxLodFlaw, 100)+100;
            if (ptNewOd.y > 100) 
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);
                dc.LineTo(ptNewOd);
                if ( (ptNewOd.x < 900) && (ptNewOd.x >= 0) )
					m_ptExistLong[ptNewOd.x][1] = ptNewOd;
            }

        }
        else
        {
            m_ptLastLOd = (0,100);
        }

        // Look at Long  ID map

        if ( m_bIdCheck && (ptNewId.x > 0)) 
        {
            ptNewId.y = min(pImsg01->UtInsp.MaxLidFlaw, 100);
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
                if ( (ptNewId.x < 900) && (ptNewId.x >= 0) )
					m_ptExistLong[ptNewId.x][0] = ptNewId;
            }

        }
        else
		{
			m_ptLastLId = (0,0);
		}


ENDLOOP:

#if 1
		if ( !m_bWallCheck && (pImsg01->InspHdr.nStation == 0) )
		{
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x0401) == 0x0401 )
				m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#else
			m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#endif
		}
#endif

        if (rPosition == NULL ) break;
  
    }   //  End while (1)

    dc.SelectObject(penOld);

    if (m_nProgressS1 != m_nLastProgressS1)
    {
        DrawProgressLine(&dc, m_nProgressS1, 0, FALSE);
		if ( !m_bOblq3Check && !m_bLaminCheck )
		{
			m_bDrawProgressS1Once = TRUE;
			m_nLastProgressS1 = m_nProgressS1;
		}
    }
}


void CInspect::DrawProgressLine(CClientDC *pDC, int nXloc, int nStation, BOOL bWall)
{
    int     nOldMode = pDC->SetROP2(R2_XORPEN);
    CPen    pen;
    CPen    *penOld;
    int     y1, y2;
    int     nLastProgress;
    BOOL    bDrawProgressOnce;

    switch (nStation)
    {
    case 0:
        nLastProgress = m_nLastProgressS1;
        bDrawProgressOnce = m_bDrawProgressS1Once;
        break;
    case 1:
        nLastProgress = m_nLastProgressS2;
        bDrawProgressOnce = m_bDrawProgressS2Once;
        break;
    case 2:
        nLastProgress = m_nLastProgressTran;
        bDrawProgressOnce = m_bDrawProgressTranOnce;
		break;
    case 3:
        nLastProgress = m_nLastProgressObq2;
        bDrawProgressOnce = m_bDrawProgressObq2Once;
		break;
    default:
        return;
    }

    if (bWall)
    {
        short WallRange = (short) (20.0f * ConfigRec.JobRec.Wall * 
                                (float) MAX_DELTA_WALL);

        y1 = -WallRange/2;
        y2 = WallRange/2;
    }
    else
    {
        y1 = 0;
        y2 = 200;
    }
    
    pen.CreatePen(PS_SOLID,1, RGB(255,64,255));

    penOld = pDC->SelectObject(&pen);

    if ( bDrawProgressOnce && (nLastProgress < m_nScale) )
    {
        pDC->MoveTo(nLastProgress, y1);
        pDC->LineTo(nLastProgress, y2);
    }

    if ( nXloc < m_nScale )
    {
        pDC->MoveTo(nXloc, y1);
        pDC->LineTo(nXloc, y2);
    }

    pDC->SelectObject(&penOld);
    pDC->SetROP2(nOldMode);
}


/******************************************************************/

void CInspect::DrawTran()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspTranRect;
    CPen *penOld;
    CPen *penId, *penOd;
    WORD PipeStatus;
	int  nBackupToXlocS1;

    CClientDC dc(&m_cbInspTran);    // get drawing context for Tran button

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspTran.GetClientRect(&InspTranRect);
    InspTranRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspTranRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspTranRect.Width(), InspTranRect.Height());

    if (m_plistUtData.IsEmpty() ) return ;


    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();


    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue



    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        // Only if Inspect status is true
        // Check line status to determine when to erase

		nBackupToXlocS1 = 2000;   // station 1
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
			if ( pImsg01->InspHdr.nStation == 0 )
				nBackupToXlocS1 = pImsg01->InspHdr.JointLength;
			BackwardEraseTran(&dc, nBackupToXlocS1);
			m_bBackward = TRUE;
		}

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatTran & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatTran = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspTranErase();
				m_ptLastTid = m_ptLastTod = (0,0);
				break;  // just arrived
			case 2:
				break;  // just left system
			case 3:
				break;  // been here for a while
        } //end switch


        // Only if Inspect status is true
        if ( !(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE ) )
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of UT
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;
        if ( m_bOdCheck && (ptNewOd.x > 0) )
        {
            // Look at Tran OD map
            ptNewOd.y = min(pImsg01->UtInsp.MaxTodFlaw, 100)+100;
            if (ptNewOd.y > 100) 
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);
                dc.LineTo(ptNewOd);
                if ( (ptNewOd.x < 900) && (ptNewOd.x >= 0) )
					m_ptExistTran[ptNewOd.x][1] = ptNewOd;
            }
//          dc.LineTo(ptNewOd.x, ptNewOd.y + 100);
//          m_ptLastTod = ptNewOd;  // remember last point location
        }
        else
        {
            m_ptLastTod = (0,0);
        }

        // Look at Tran ID map

        if ( m_bIdCheck && (ptNewId.x > 0)) 
        {
            ptNewId.y = min(pImsg01->UtInsp.MaxTidFlaw, 100);
            //dc.MoveTo(m_ptLastTid);
            if (ptNewId.y > 0) 
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
                if ( (ptNewId.x < 900) && (ptNewId.x >= 0) )
					m_ptExistTran[ptNewId.x][0] = ptNewId;
            }
            //m_ptLastTid = ptNewId;    // remember last point location
        }
        else
		{
			m_ptLastTid = (0,0);
		}

ENDLOOP:

#if 1
		if ( (pImsg01->InspHdr.nStation == 0) )
		{
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x0801) == 0x0801 )
			{
				int dx = ConfigRec.UtRec.Shoe[1].Ch[0].cXOffset - ConfigRec.UtRec.Shoe[3].Ch[0].cXOffset;
				m_nProgressTran = pImsg01->InspHdr.JointLength + 2 - dx;
			}
#else
				m_nProgressTran = pImsg01->InspHdr.JointLength + 1;
#endif
		}
#endif

		if (rPosition == NULL ) break;
//		pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
  
		}   //  End while (1)


	dc.SelectObject(penOld);

	if (m_nProgressTran != m_nLastProgressTran)
	{
		DrawProgressLine(&dc, m_nProgressTran, 2, FALSE);
		m_bDrawProgressTranOnce = TRUE;
		m_nLastProgressTran = m_nProgressTran;
	}
}

    
/******************************************************************/

void CInspect::DrawOblq1()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspOblqRect;
    CPen *penOld;
    CPen *penId, *penOd;
    WORD PipeStatus;
	int  nBackupToXlocS2;

    CClientDC dc(&m_cbInspOblq1);   // get drawing context for 
    //  Set up reference area for graphing

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspOblq1.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspOblqRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());

    if (m_plistUtData.IsEmpty() ) return ;


    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();


    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue



    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        // Only if Inspect status is true
        // Check line status to determine when to erase

		nBackupToXlocS2 = 2000;   // station 2
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
#if ( SYSTEM_SUB_ID == LORAINE_SYS)
			if ( pImsg01->InspHdr.nStation == 1 )
#else
			if ( pImsg01->InspHdr.nStation == 0 )
#endif
				nBackupToXlocS2 = pImsg01->InspHdr.JointLength;
			BackwardEraseOblq1(&dc, nBackupToXlocS2);
			m_bBackward = TRUE;
		}

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatObq1 & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatObq1 = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspOblq1Erase();
				m_ptLastQ1id = m_ptLastQ1od = (0,0);
				break;  // just arrived
			case 2:
				break;  // just left system
			case 3:
				break;  // been here for a while
        } //end switch


        // Only if Inspect status is true
        if ( !(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE ))
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of UT
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;
        if ( m_bOdCheck && (ptNewOd.x > 0) )
        {
            // Look at Oblq OD map
            ptNewOd.y = min(pImsg01->UtInsp.MaxQ1odFlaw, 100)+100;
            if (ptNewOd.y > 100) 
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);
                dc.LineTo(ptNewOd);
                if ( (ptNewOd.x < 900) && (ptNewOd.x >= 0) )
					m_ptExistOblq1[ptNewOd.x][1] = ptNewOd;
            }
            //dc.MoveTo(m_ptLastQ1od.x, m_ptLastQ1od.y + 100);  // bias od by 100%
            //dc.LineTo(ptNewOd.x, ptNewOd.y + 100);
            //m_ptLastQ1od = ptNewOd;   // remember last point location
        }
        else
        {
            m_ptLastQ1od = (0,0);
        }

        // Look at Oblq ID map

        if ( m_bIdCheck && (ptNewId.x > 0)) 
        {
            ptNewId.y = min(pImsg01->UtInsp.MaxQ1idFlaw, 100);
            //dc.MoveTo(m_ptLastQ1id);
            if (ptNewId.y > 0) 
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
                if ( (ptNewId.x < 900) && (ptNewId.x >= 0) )
					m_ptExistOblq1[ptNewId.x][0] = ptNewId;
            }
            //m_ptLastQ1id = ptNewId;   // remember last point location
        }
        else 
		{
			m_ptLastQ1id = (0,0);
		}


        if ( pImsg01->InspHdr.nStation == 1 )
        {
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x1002) == 0x1002 )
				m_nProgressS2 = pImsg01->InspHdr.JointLength + 1;
#else
            m_nProgressS2 = pImsg01->InspHdr.JointLength + 1;
#endif
        }


ENDLOOP:
        if (rPosition == NULL ) break;
  
    }   //  End while (1)


    dc.SelectObject(penOld);

#if ( SYSTEM_SUB_ID != LORAINE_SYS)
	m_nProgressS2 = m_nProgressS1;
#endif

    if (m_nProgressS2 != m_nLastProgressS2)
    {
        DrawProgressLine(&dc, m_nProgressS2, 1, FALSE);
		m_bDrawProgressS2Once = TRUE;
		m_nLastProgressS2 = m_nProgressS2;
    }
}

    
/******************************************************************/
// oblq2

void CInspect::DrawOblq2()
{
    CPoint ptNewOd, ptNewId;
    CRect InspOblqRect;
    CPen *penOld;
    CPen *penId, *penOd;
    WORD PipeStatus;
	int  nBackupToXlocS2;
	int  nBias = 0;

    CClientDC dc(&m_cbInspOblq2);   // get drawing context for 
    //  Set up reference area for graphing

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspOblq2.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspOblqRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

#if (SYSTEM_ID == RAW_WALL_SYS)
	dc.SetWindowExt(m_nScale,-40);   // define size of window in logical units
	nBias = 20;
#else
    dc.SetWindowExt(m_nScale,-200);   // define size of window in logical units
	nBias = 100;
#endif
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());

    if (m_plistUtData.IsEmpty() ) 
		return ;


    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();


    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue



    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        // Only if Inspect status is true
        // Check line status to determine when to erase

		nBackupToXlocS2 = 2000;   // station 2
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
#if ( SYSTEM_SUB_ID == LORAINE_SYS)
			if ( pImsg01->InspHdr.nStation == 1 )
#else
			if ( pImsg01->InspHdr.nStation == 0 )
#endif
				nBackupToXlocS2 = pImsg01->InspHdr.JointLength;
			BackwardEraseOblq2(&dc, nBackupToXlocS2);
			m_bBackward = TRUE;
		}

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatObq2 & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatObq2 = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspOblq2Erase();
				m_ptLastQ2id = m_ptLastQ2od = (0,0);
				break;  // just arrived
			case 2:
				break;  // just left system
			case 3:
				break;  // been here for a while
        }  //end switch


        // Only if Inspect status is true
        if ( !(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE ))
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of UT
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;
        if ( m_bOdCheck && (ptNewOd.x > 0) )
        {
            // Look at Oblq OD map
            ptNewOd.y = min(pImsg01->UtInsp.MaxQ2odFlaw, nBias)+ nBias;
            if (ptNewOd.y > nBias) 
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,nBias);
                dc.LineTo(ptNewOd);
                if ( (ptNewOd.x < 900) && (ptNewOd.x >= 0) )
					m_ptExistOblq2[ptNewOd.x][1] = ptNewOd;
            }
            //dc.MoveTo(m_ptLastQ2od.x, m_ptLastQ2od.y + 100);  // bias od by 100%
            //dc.LineTo(ptNewOd.x, ptNewOd.y + 100);
            //m_ptLastQ2od = ptNewOd;   // remember last point location
        }
        else
        {
            m_ptLastQ2od = (0,0);
        }

        // Look at Oblq ID map

        if ( m_bIdCheck && (ptNewId.x > 0)) 
        {
            ptNewId.y = min(pImsg01->UtInsp.MaxQ2idFlaw, nBias);
            //dc.MoveTo(m_ptLastQ2id);
            if (ptNewId.y > 0) 
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
                if ( (ptNewId.x < 900) && (ptNewId.x >= 0) )
					m_ptExistOblq2[ptNewId.x][0] = ptNewId;
            }
        }
        else 
		{
			m_ptLastQ2id = (0,0);
		}

#if 1
		if ( (pImsg01->InspHdr.nStation == 1) )
		{
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x2002) == 0x2002 )
			{
				int dx = ConfigRec.UtRec.Shoe[5].Ch[0].cXOffset - ConfigRec.UtRec.Shoe[7].Ch[0].cXOffset;
				m_nProgressObq2 = pImsg01->InspHdr.JointLength + 2 - dx;
			}
#else
			m_nProgressObq2 = pImsg01->InspHdr.JointLength + 1;
#endif
		}
#endif

ENDLOOP:
        if (rPosition == NULL ) break;
  
    }   //  End while (1)


    dc.SelectObject(penOld);

#if ( SYSTEM_SUB_ID != LORAINE_SYS)
	m_nProgressObq2 = m_nProgressS1;
#endif

    if (m_nProgressObq2 != m_nLastProgressObq2)
    {
        DrawProgressLine(&dc, m_nProgressObq2, 3, FALSE);
        m_bDrawProgressObq2Once = TRUE;
        m_nLastProgressObq2 = m_nProgressObq2;
    }
}

    
/******************************************************************/
// oblq3    

void CInspect::DrawOblq3()
{
    CPoint ptNewOd, ptNewId;
    CRect InspOblqRect;
    CPen *penOld;
    CPen *penId, *penOd;
    WORD PipeStatus;
	int  nBackupToXlocS1;

    CClientDC dc(&m_cbInspOblq3);   // get drawing context for 
    //  Set up reference area for graphing

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspOblq3.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspOblqRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());
    if (m_plistUtData.IsEmpty() ) return ;


    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();

    penOd = &penBlue2;
    penId = &penRed2;
    penOld = dc.SelectObject(penOd);    // OD is blue

    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        // Only if Inspect status is true
        // Check line status to determine when to erase

		nBackupToXlocS1 = 2000;   // station 1
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
			if ( pImsg01->InspHdr.nStation == 0 )
				nBackupToXlocS1 = pImsg01->InspHdr.JointLength;
			BackwardEraseOblq3(&dc, nBackupToXlocS1);
			m_bBackward = TRUE;
		}

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatObq3 & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatObq3 = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspOblq3Erase();
				m_ptLastQ3id = m_ptLastQ3od = (0,0);
				break;  // just arrived
			case 2:
				break;  // just left system
			case 3:
				break;  // been here for a while
        }  //end switch


        // Only if Inspect status is true
        if ( !(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE ) )
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of UT
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;
        if ( m_bOdCheck && (ptNewOd.x > 0) )
        {
            // Look at Oblq OD map
            ptNewOd.y = min(pImsg01->UtInsp.MaxQ3odFlaw, 100)+ 100;
            if (ptNewOd.y > 100) 
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);
                dc.LineTo(ptNewOd);
                if ( (ptNewOd.x < 900) && (ptNewOd.x >= 0) )
					m_ptExistOblq3[ptNewOd.x][1] = ptNewOd;
            }
            //dc.MoveTo(m_ptLastQ3od.x, m_ptLastQ3od.y + 100);  // bias od by 100%
            //dc.LineTo(ptNewOd.x, ptNewOd.y + 100);
            //m_ptLastQ3od = ptNewOd;   // remember last point location
        }
        else
        {
            m_ptLastQ3od = (0,0);
        }

        // Look at Oblq ID map

        if ( m_bIdCheck && (ptNewId.x > 0)) 
        {
            ptNewId.y = min(pImsg01->UtInsp.MaxQ3idFlaw, 100);
            if (ptNewId.y > 0) 
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
                if ( (ptNewId.x < 900) && (ptNewId.x >= 0) )
					m_ptExistOblq3[ptNewId.x][0] = ptNewId;
            }
        }
        else 
		{
			m_ptLastQ3id = (0,0);
		}

ENDLOOP:
#if 1
		if ( !m_bWallCheck && !m_bLongCheck && (pImsg01->InspHdr.nStation == 0) )
		{
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x0401) == 0x0401 )
				m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#else
			m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#endif
		}
#endif

		if (rPosition == NULL ) break;
  
		}   //  End while (1)


	dc.SelectObject(penOld);

	if (m_nProgressS1 != m_nLastProgressS1)
	{
		DrawProgressLine(&dc, m_nProgressS1, 0, FALSE);
		if ( !m_bLaminCheck )
		{
			m_bDrawProgressS1Once = TRUE;
			m_nLastProgressS1 = m_nProgressS1;
		}
	}
}


/******************************************************************/
// laminar    

void CInspect::DrawLamin()
{
    CPoint ptNewOd, ptNewId;
    CRect InspOblqRect;
    CPen *penOld;
    CPen *penId, *penOd;
    WORD PipeStatus;
	int  nBackupToXlocS1;

    CClientDC dc(&m_cbInspLamin);   // get drawing context for 
    //  Set up reference area for graphing

    I_MSG_RUN *pImsg01;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspLamin.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspOblqRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());
    if (m_plistUtData.IsEmpty() ) return ;


    POSITION rPosition = m_plistUtData.GetHeadPosition();

    pImsg01 = (I_MSG_RUN *) m_plistUtData.GetHead();

    penOd = &penBlue2;
    penId = &penRed2;
    penOld = dc.SelectObject(penOd);    // OD is blue

    while (1)
    {
        pImsg01 = (I_MSG_RUN *) m_plistUtData.GetNext(rPosition);
        if (pImsg01->MstrHdr.MsgId != RUN_MODE) goto ENDLOOP;
        // Only if Inspect status is true
        // Check line status to determine when to erase

		nBackupToXlocS1 = 2000;   // station 1
		if ( (pImsg01->InspHdr.status[2] & 0x0010) != 0x0010 )  //going backward
		{
			if ( pImsg01->InspHdr.nStation == 0 )
				nBackupToXlocS1 = pImsg01->InspHdr.JointLength;
			BackwardEraseLamin(&dc, nBackupToXlocS1);
			m_bBackward = TRUE;
		}

        PipeStatus = 0;
        if (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) PipeStatus = 1; 
        if (m_wOldStatLamin & PIPE_PRESENT) PipeStatus |= 2;
        m_wOldStatLamin = pImsg01->InspHdr.wLineStatus;

        switch ( PipeStatus)
        {   // pipe transitions
			case 0:
				break;  // no pipe in system
			case 1:
				InspLaminErase();
				m_ptLastLamid = m_ptLastLamod = (0,0);
				break;  // just arrived
			case 2:
				break;  // just left system
			case 3:
				break;  // been here for a while
        }  //end switch


        // Only if Inspect status is true
        if ( !(pImsg01->InspHdr.wLineStatus & INSPECT_ENABLE_TRUSCOPE ) )
        {
            //  get next in data list
            goto ENDLOOP;
        }

        // Same x Location for all radial elements of UT
        ptNewOd.x = ptNewId.x = (int) pImsg01->InspHdr.xloc % m_nScale;
        if ( m_bOdCheck && (ptNewOd.x > 0) )
        {
            // Look at Oblq OD map
            ptNewOd.y = min(pImsg01->UtInsp.MaxLamAFlaw, 100)+ 100;
            if (ptNewOd.y > 100) 
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);
                dc.LineTo(ptNewOd);
                if ( (ptNewOd.x < 900) && (ptNewOd.x >= 0) )
					m_ptExistLamin[ptNewOd.x][1] = ptNewOd;
            }
            //dc.MoveTo(m_ptLastQ3od.x, m_ptLastQ3od.y + 100);  // bias od by 100%
            //dc.LineTo(ptNewOd.x, ptNewOd.y + 100);
            //m_ptLastQ3od = ptNewOd;   // remember last point location
        }
        else
        {
            m_ptLastLamod = (0,0);
        }

        // Look at Oblq ID map

        if ( m_bIdCheck && (ptNewId.x > 0)) 
        {
            ptNewId.y = min(pImsg01->UtInsp.MaxLamLFlaw, 100);
            if (ptNewId.y > 0) 
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
                if ( (ptNewId.x < 900) && (ptNewId.x >= 0) )
					m_ptExistLamin[ptNewId.x][0] = ptNewId;
            }
        }
        else 
		{
			m_ptLastLamid = (0,0);
		}

ENDLOOP:
#if 1
		if ( !m_bWallCheck && !m_bLongCheck && !m_bOblq3Check && (pImsg01->InspHdr.nStation == 0) )
		{
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			if ( (pImsg01->InspHdr.status[2] & 0x0401) == 0x0401 )
				m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#else
			m_nProgressS1 = pImsg01->InspHdr.JointLength + 1;
#endif
		}
#endif

		if (rPosition == NULL ) break;
  
		}   //  End while (1)


	dc.SelectObject(penOld);

	if (m_nProgressS1 != m_nLastProgressS1)
	{
		DrawProgressLine(&dc, m_nProgressS1, 0, FALSE);
		m_bDrawProgressS1Once = TRUE;
		m_nLastProgressS1 = m_nProgressS1;
	}
}

    
/******************************************************************/

void CInspect::DrawXTicks()
{
        // x axis ticks drawn on bottom of image map
    CRect MapRect;
    CPen *penOld;
    CPen penBlue(PS_SOLID,2, RGB(0,0,255));
    TEXTMETRIC tm;

    CClientDC dc(&m_cbMap); // get drawing context for 

    int i,m;
    int xChar;
    int yChar;
    CString s;
    float fmeter;

    m_cbMap.GetClientRect(&MapRect);
    MapRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, MapRect.Height());
    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-120); // define size of window in logical units
    // 750 in 1 INCH x increments, 120 percent y scale
    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( MapRect.Width(), MapRect.Height());

    dc.GetTextMetrics (&tm);    // put after setting viewport/window ext

    yChar = 3*(tm.tmHeight + tm.tmExternalLeading)/4;
    xChar = 3*tm.tmAveCharWidth/2;

    penOld = dc.SelectObject(&penBlue);


    switch (m_bMetric & 1)
    {
      case 0:
        // English
        // draw ticks and number every 10 ft., ie., 10, 20, 30 etc
        for ( i = 120; i < m_nScale; i += 120)
        {
            dc.MoveTo(i,0);
            dc.LineTo(i,7);
            dc.SetBkMode(TRANSPARENT);
            s.Format(_T("%2d"), i/12);
            dc.TextOut( i+2, yChar,s);
        }
        // draw 2 ft marks
        for ( i = 24; i < m_nScale; i += 24)
        {
            dc.MoveTo(i,0);
            dc.LineTo(i,3);
        }
        break;

      case 1:
        // Metric
        // draw ticks and number every 5 meters ... still 50 or 75 ft scale
        fmeter = 5.0f;
        m = 5;
        i = (int) (fmeter * 39.37f  + 0.5f);
        while ( i < m_nScale)
        {
            dc.MoveTo(i,0);
            dc.LineTo(i,7);
            s.Format(_T("%2d"), m);
            if ( i < (m_nScale - 30) )
                {
                dc.SetBkMode(TRANSPARENT);
                dc.TextOut( i+2, yChar,s);
                }
            fmeter += 5.0f;
            m += 5;
            i = (int) (fmeter * 39.37f  + 0.5f);
        }

        // draw 1 meter marks
        fmeter = 1.0f;
        m = 1;
        i = (int) (fmeter * 39.37f  + 0.5f);
        while ( i < m_nScale)
        {
            dc.MoveTo(i,0);
            dc.LineTo(i,3);
            fmeter += 1.0f;
            m += 1;
            i = (int) (fmeter * 39.37f  + 0.5f);
        }
        break;

      default:
        break;
    }  //end switch

    // 12/01/00 Put clock ticks on far right side
    for ( i = 10; i < 120; i += 10)
    {
        dc.MoveTo(m_nScale - 4, i);
        dc.LineTo(m_nScale, i);
        if ( (i % 30) == 0)
        {
            s.Format(_T("%d"), i/10);
            dc.TextOut(m_nScale -(xChar+4), i+5,s);
        }
    }

    dc.SelectObject(penOld);
}


/**************  Screen Erase Functions *******************/
#define DEBUG_SONO_MAP  0


void CInspect::InspMapErase() 
{

    CString s,t;

    CRect MapRect;
    CRect MouseRect;


    //  Set up reference area for graphing
    CClientDC dcMap(&m_cbMap);  // get drawing context for Map

    // Get the client rectangle boundaries for the Image Map graph (Button)

    m_cbMap.GetClientRect(&MapRect);
    MapRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dcMap.SetViewportOrg( 0, MapRect.Height());
    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dcMap.SetMapMode(MM_ANISOTROPIC);

    dcMap.SetWindowExt(m_nScale,-100);  // define size of window in logical units
    // 750 in 1 INCH x increments, 100 PERCENT y scale
    // tell windows how big this box is physically in pixels
    dcMap.SetViewportExt( MapRect.Width(), MapRect.Height());

    // White out the button
    dcMap.FillSolidRect(1,-2,m_nScale,101,RGB(255,255,255)); // WAS -1

    
    m_bDrawTicks = TRUE;

    time(&m_tTimeNow);
    // Update time and data on status screen
    // If status dlg window didn't exist, we wouldn't be here
    if (m_nControlSel != INSPECT_PLAY)
    {
        pCTscanDlg->UpdateTimeDate(&m_tTimeNow);
    }

}


void CInspect::InspWallErase() 
{
    CRect InspWallRect; 

    //  Set up reference area for graphing
    CClientDC dcInspWall(&m_cbInspWall);        // get drawing context for Amalog Graph 


    /****** Wall Graph Area Erase  ******/

    m_cbInspWall.GetClientRect(&InspWallRect);
    InspWallRect.NormalizeRect();
    // Move the coordinate origin to the center left edge
    dcInspWall.SetViewportOrg( 0, InspWallRect.Height()/2);
    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dcInspWall.SetMapMode(MM_ANISOTROPIC);

    dcInspWall.SetWindowExt(m_nScale,-(2*MAX_DELTA_WALL));  // define size of window in logical units
    // 750 in 1 INCH x increments, 40 PERCENT y scale
    // tell windows how big this box is physically in pixels
    dcInspWall.SetViewportExt( InspWallRect.Width(), InspWallRect.Height());
//  dcInspWall.DPtoLP(&TestRect);

    // White out the button
    dcInspWall.FillSolidRect(1,-MAX_DELTA_WALL,m_nScale,2*MAX_DELTA_WALL,RGB(255,255,255));

    
    m_bDrawTicks = TRUE;
    m_ptLastWallMax = m_ptLastWallMin = (0,0);  // previous amalog id, od  values

    
    // Erase previous tholds if they exist
    dcInspWall.SelectObject(&penWhite2);
    if ( m_nTholdWidLast < 0)
    {
        dcInspWall.MoveTo(2, m_nTholdWidLast);
        dcInspWall.LineTo(m_nScale-2, m_nTholdWidLast);
    }

    if ( m_nTholdWodLast > 0)
    {
        dcInspWall.MoveTo(2, m_nTholdWodLast);
        dcInspWall.LineTo(m_nScale-2, m_nTholdWodLast);
    }

    m_nTholdWidLast = ConfigRec.UtRec.TholdWall[0];
    m_nTholdWodLast = ConfigRec.UtRec.TholdWall[1];
        
    // Draw black nominal wall line in center of graph
    dcInspWall.SelectObject(&penBlack1);
    dcInspWall.MoveTo(2, 0);
    dcInspWall.LineTo(m_nScale-2, 0);


    // Draw OD line as solid blue
    dcInspWall.SelectObject(&penBlue1);

    dcInspWall.MoveTo(2, m_nTholdWodLast);
    dcInspWall.LineTo(m_nScale-2, m_nTholdWodLast);

    // Draw ID as red line
    dcInspWall.SelectObject(&penRed1);
    dcInspWall.MoveTo(2, m_nTholdWidLast);
    dcInspWall.LineTo(m_nScale-2, m_nTholdWidLast);

    m_bDrawProgressS1Once = FALSE;
}


void CInspect::InspLongErase() 
{

    CRect InspLongRect;
    CClientDC dcInspLong(&m_cbInspLong);

    /****** Long Graph Area Erase  ******/
    m_cbInspLong.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();
    dcInspLong.SetViewportOrg( 0, InspLongRect.Height());
    dcInspLong.SetMapMode(MM_ANISOTROPIC);

    dcInspLong.SetWindowExt(m_nScale,-200); // define size of window in logical units
    dcInspLong.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());

    // White out the button
    dcInspLong.FillSolidRect(1,-1,m_nScale,200,RGB(255,255,255));
    
    m_bDrawTicks = TRUE;
    m_ptLastLOd = m_ptLastLId = (0,0);
    
    // Erase previous tholds if they exist
    // OD signals biased by 100% to be in top half of graph

    dcInspLong.SelectObject(&penWhite2);
    if ( m_nTholdLodLast > 0)
    {
        dcInspLong.MoveTo(2, m_nTholdLodLast + 100);
        dcInspLong.LineTo(m_nScale-2, m_nTholdLodLast + 100);
    }

    if ( m_nTholdLidLast > 0)
    {
        dcInspLong.MoveTo(2, m_nTholdLidLast);
        dcInspLong.LineTo(m_nScale-2, m_nTholdLidLast);
    }


    m_nTholdLidLast = ConfigRec.UtRec.TholdLong[0][0];
    m_nTholdLodLast = ConfigRec.UtRec.TholdLong[0][1];

    
    // Draw OD line as solid blue
    dcInspLong.SelectObject(&penBlue1);

    dcInspLong.MoveTo(2, m_nTholdLodLast + 100);
    dcInspLong.LineTo(m_nScale-2, m_nTholdLodLast + 100);


    // Draw ID line as red
    dcInspLong.SelectObject(&penRed1);
    dcInspLong.MoveTo(2, m_nTholdLidLast);
    dcInspLong.LineTo(m_nScale-2, m_nTholdLidLast);

    // Draw center dividing line separating Od from Id
    dcInspLong.SelectObject(&penBlack1);

    dcInspLong.MoveTo(2, 100);
    dcInspLong.LineTo(m_nScale-2, 100);


    // Draw a solid base line at bottom of graph
    dcInspLong.MoveTo(2, 0);
    dcInspLong.LineTo(m_nScale-2, 0);

    m_bDrawProgressS1Once = FALSE;
}


void CInspect::InspTranErase() 
{
    CRect InspTranRect;

    CClientDC dcInspTran(&m_cbInspTran);        


    m_cbInspTran.GetClientRect(&InspTranRect);
    InspTranRect.NormalizeRect();
    dcInspTran.SetViewportOrg( 0, InspTranRect.Height());
    dcInspTran.SetMapMode(MM_ANISOTROPIC);


    dcInspTran.SetWindowExt(m_nScale,-200); // define size of window in logical units
        // 750  1 INCH  x increments, 100 % on y axis
        // tell windows how big this box is physically in pixels

    dcInspTran.SetViewportExt( InspTranRect.Width(), InspTranRect.Height());

    // White out the button
    dcInspTran.FillSolidRect(1,-1,m_nScale,200,RGB(255,255,255));

    
    m_bDrawTicks = TRUE;
    
    m_ptLastTod = m_ptLastTid = (0,0);
    
    // Erase previous tholds if they exist
    dcInspTran.SelectObject(&penWhite2);
    if ( m_nTholdTodLast > 0)
    {
        dcInspTran.MoveTo(2, m_nTholdTodLast + 100);
        dcInspTran.LineTo(m_nScale-2, m_nTholdTodLast + 100);
    }

    if ( m_nTholdTidLast > 0)
    {
        dcInspTran.MoveTo(2, m_nTholdTidLast);
        dcInspTran.LineTo(m_nScale-2, m_nTholdTidLast);
    }


    m_nTholdTidLast = ConfigRec.UtRec.TholdLong[1][0];
    m_nTholdTodLast = ConfigRec.UtRec.TholdLong[1][1];

    
    // Draw OD line as solid blue
    dcInspTran.SelectObject(&penBlue1);

    dcInspTran.MoveTo(2, m_nTholdTodLast + 100);
    dcInspTran.LineTo(m_nScale-2, m_nTholdTodLast + 100);


    // Draw ID line as red
    dcInspTran.SelectObject(&penRed1);
    dcInspTran.MoveTo(2, m_nTholdTidLast);
    dcInspTran.LineTo(m_nScale-2, m_nTholdTidLast);

    // Draw center dividing line separating Od from Id
    dcInspTran.SelectObject(&penBlack1);

    dcInspTran.MoveTo(2, 100);
    dcInspTran.LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    dcInspTran.MoveTo(2, 0);
    dcInspTran.LineTo(m_nScale-2, 0);

    m_bDrawProgressTranOnce = FALSE;
}


void CInspect::InspOblq1Erase()
{
    CRect InspOblqRect;
    CClientDC dcInspOblq(&m_cbInspOblq1);       // get drawing context for Sono Graph 

    /****** Obliques Graph Area Erase  ******/
    m_cbInspOblq1.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();
    dcInspOblq.SetViewportOrg( 0, InspOblqRect.Height());
    dcInspOblq.SetMapMode(MM_ANISOTROPIC);

    dcInspOblq.SetWindowExt(m_nScale,-200); // define size of window in logical units
    dcInspOblq.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());

    // White out the button
    dcInspOblq.FillSolidRect(1,-1,m_nScale,200,RGB(255,255,255));
    
    m_bDrawTicks = TRUE;
    m_ptLastQ1od = m_ptLastQ1id = (0,0);

    
    // Erase previous tholds if they exist
    dcInspOblq.SelectObject(&penWhite2);
    if ( m_nTholdQ1odLast > 0)
    {
        dcInspOblq.MoveTo(2, m_nTholdQ1odLast + 100);
        dcInspOblq.LineTo(m_nScale-2, m_nTholdQ1odLast + 100);
    }

    if ( m_nTholdQ1idLast > 0)
    {
        dcInspOblq.MoveTo(2, m_nTholdQ1idLast);
        dcInspOblq.LineTo(m_nScale-2, m_nTholdQ1idLast);
    }


    m_nTholdQ1idLast = ConfigRec.UtRec.TholdLong[2][0];
    m_nTholdQ1odLast = ConfigRec.UtRec.TholdLong[2][1];

    
    // Draw OD line as solid blue
    dcInspOblq.SelectObject(&penBlue1);

    dcInspOblq.MoveTo(2, m_nTholdQ1odLast + 100);
    dcInspOblq.LineTo(m_nScale-2, m_nTholdQ1odLast + 100);


    // Draw ID line as red
    dcInspOblq.SelectObject(&penRed1);
    dcInspOblq.MoveTo(2, m_nTholdQ1idLast);
    dcInspOblq.LineTo(m_nScale-2, m_nTholdQ1idLast);

    // Draw center dividing line separating Od from Id
    dcInspOblq.SelectObject(&penBlack1);

    dcInspOblq.MoveTo(2, 100);
    dcInspOblq.LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    dcInspOblq.MoveTo(2, 0);
    dcInspOblq.LineTo(m_nScale-2, 0);

    m_bDrawProgressS2Once = FALSE;
}


void CInspect::InspOblq2Erase()
{
    CRect InspOblqRect;
    CClientDC dcInspOblq(&m_cbInspOblq2);       // get drawing context for Sono Graph 
	int nBias = 0;

    /****** Obliques Graph Area Erase  ******/
    m_cbInspOblq2.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();
    dcInspOblq.SetViewportOrg( 0, InspOblqRect.Height());
    dcInspOblq.SetMapMode(MM_ANISOTROPIC);

#if (SYSTEM_ID == RAW_WALL_SYS)
	dcInspOblq.SetWindowExt(m_nScale,-40);   // define size of window in logical units
	nBias = 20;
#else
    dcInspOblq.SetWindowExt(m_nScale,-200);   // define size of window in logical units
	nBias = 100;
#endif
    dcInspOblq.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());

    // White out the button
    dcInspOblq.FillSolidRect(1,-1,m_nScale,nBias*2,RGB(255,255,255));
    
    m_bDrawTicks = TRUE;
    m_ptLastQ2od = m_ptLastQ2id = (0,0);

    
    // Erase previous tholds if they exist
    dcInspOblq.SelectObject(&penWhite2);
    if ( m_nTholdQ2odLast > 0)
    {
        dcInspOblq.MoveTo(2, m_nTholdQ2odLast + nBias);
        dcInspOblq.LineTo(m_nScale-2, m_nTholdQ2odLast + nBias);
    }

    if ( m_nTholdQ2idLast > 0)
    {
        dcInspOblq.MoveTo(2, m_nTholdQ2idLast);
        dcInspOblq.LineTo(m_nScale-2, m_nTholdQ2idLast);
    }


    m_nTholdQ2idLast = ConfigRec.UtRec.TholdLong[3][0];
    m_nTholdQ2odLast = ConfigRec.UtRec.TholdLong[3][1];

    // Draw OD line as solid blue
    dcInspOblq.SelectObject(&penBlue1);

    dcInspOblq.MoveTo(2, m_nTholdQ2odLast + nBias);
    dcInspOblq.LineTo(m_nScale-2, m_nTholdQ2odLast + nBias);

    // Draw ID line as red
    dcInspOblq.SelectObject(&penRed1);
    dcInspOblq.MoveTo(2, m_nTholdQ2idLast);
    dcInspOblq.LineTo(m_nScale-2, m_nTholdQ2idLast);

    // Draw center dividing line separating Od from Id
    dcInspOblq.SelectObject(&penBlack1);

    dcInspOblq.MoveTo(2, nBias);
    dcInspOblq.LineTo(m_nScale-2, nBias);

    // Draw a solid base line at bottom of graph
    dcInspOblq.MoveTo(2, 0);
    dcInspOblq.LineTo(m_nScale-2, 0);

    m_bDrawProgressObq2Once = FALSE;
}


void CInspect::InspOblq3Erase()
{
    CRect InspOblqRect;
    CClientDC dcInspOblq(&m_cbInspOblq3);       // get drawing context for Sono Graph 

    /****** Obliques Graph Area Erase  ******/
    m_cbInspOblq3.GetClientRect(&InspOblqRect);
    InspOblqRect.NormalizeRect();
    dcInspOblq.SetViewportOrg( 0, InspOblqRect.Height());
    dcInspOblq.SetMapMode(MM_ANISOTROPIC);

    dcInspOblq.SetWindowExt(m_nScale,-200); // define size of window in logical units
    dcInspOblq.SetViewportExt( InspOblqRect.Width(), InspOblqRect.Height());

    // White out the button
    dcInspOblq.FillSolidRect(1,-1,m_nScale,200,RGB(255,255,255));
    
    m_bDrawTicks = TRUE;
    m_ptLastQ3od = m_ptLastQ3id = (0,0);

    
    // Erase previous tholds if they exist
    dcInspOblq.SelectObject(&penWhite2);
    if ( m_nTholdQ3odLast > 0)
    {
        dcInspOblq.MoveTo(2, m_nTholdQ3odLast + 100);
        dcInspOblq.LineTo(m_nScale-2, m_nTholdQ3odLast + 100);
    }

    if ( m_nTholdQ3idLast > 0)
    {
        dcInspOblq.MoveTo(2, m_nTholdQ3idLast);
        dcInspOblq.LineTo(m_nScale-2, m_nTholdQ3idLast);
    }


    m_nTholdQ3idLast = ConfigRec.UtRec.TholdLong[4][0];
    m_nTholdQ3odLast = ConfigRec.UtRec.TholdLong[4][1];

 
    // Draw OD line as solid blue
    dcInspOblq.SelectObject(&penBlue1);

    dcInspOblq.MoveTo(2, m_nTholdQ3odLast + 100);
    dcInspOblq.LineTo(m_nScale-2, m_nTholdQ3odLast + 100);


    // Draw ID line as red
    dcInspOblq.SelectObject(&penRed1);
    dcInspOblq.MoveTo(2, m_nTholdQ3idLast);
    dcInspOblq.LineTo(m_nScale-2, m_nTholdQ3idLast);

    // Draw center dividing line separating Od from Id
    dcInspOblq.SelectObject(&penBlack1);

    dcInspOblq.MoveTo(2, 100);
    dcInspOblq.LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    dcInspOblq.MoveTo(2, 0);
    dcInspOblq.LineTo(m_nScale-2, 0);

    m_bDrawProgressS1Once = FALSE;
}


void CInspect::InspLaminErase()
{
    CRect InspLaminRect;
    CClientDC dcInspLamin(&m_cbInspLamin);       // get drawing context for Sono Graph 

    /****** Obliques Graph Area Erase  ******/
    m_cbInspLamin.GetClientRect(&InspLaminRect);
    InspLaminRect.NormalizeRect();
    dcInspLamin.SetViewportOrg( 0, InspLaminRect.Height());
    dcInspLamin.SetMapMode(MM_ANISOTROPIC);

    dcInspLamin.SetWindowExt(m_nScale,-200); // define size of window in logical units
    dcInspLamin.SetViewportExt( InspLaminRect.Width(), InspLaminRect.Height());

    // White out the button
    dcInspLamin.FillSolidRect(1,-1,m_nScale,200,RGB(255,255,255));
    
    m_bDrawTicks = TRUE;
    m_ptLastLamod = m_ptLastLamid = (0,0);

    
    // Erase previous tholds if they exist
    dcInspLamin.SelectObject(&penWhite2);
    if ( m_nTholdLamodLast > 0)
    {
        dcInspLamin.MoveTo(2, m_nTholdLamodLast + 100);
        dcInspLamin.LineTo(m_nScale-2, m_nTholdLamodLast + 100);
    }

    if ( m_nTholdLamidLast > 0)
    {
        dcInspLamin.MoveTo(2, m_nTholdLamidLast);
        dcInspLamin.LineTo(m_nScale-2, m_nTholdLamidLast);
    }


    m_nTholdLamidLast = ConfigRec.UtRec.TholdLong[5][0];
    m_nTholdLamodLast = ConfigRec.UtRec.TholdLong[5][1];

 
    // Draw OD line as solid blue
    dcInspLamin.SelectObject(&penBlue1);

    dcInspLamin.MoveTo(2, m_nTholdLamodLast + 100);
    dcInspLamin.LineTo(m_nScale-2, m_nTholdLamodLast + 100);


    // Draw ID line as red
    dcInspLamin.SelectObject(&penRed1);
    dcInspLamin.MoveTo(2, m_nTholdLamidLast);
    dcInspLamin.LineTo(m_nScale-2, m_nTholdLamidLast);

    // Draw center dividing line separating Od from Id
    dcInspLamin.SelectObject(&penBlack1);

    dcInspLamin.MoveTo(2, 100);
    dcInspLamin.LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    dcInspLamin.MoveTo(2, 0);
    dcInspLamin.LineTo(m_nScale-2, 0);

    m_bDrawProgressS1Once = FALSE;
}


void CInspect::OnInspEraseAll()  
{
    // DO NOT change the calling order!!
    InspMapErase();
    InspWallErase();
    InspLongErase();
    InspTranErase();
    InspOblq1Erase();
    InspOblq2Erase();
    InspOblq3Erase();
	InspLaminErase();
    EraseExistPts();
	EraseFlawLists();
    if (m_pFlawReport != NULL)
        (m_pFlawReport->m_LBtext).ResetContent();

    m_nLastProgressS1 = 0;
    m_nLastProgressS2 = 0;
    m_nProgressS1 = 0;
    m_nProgressS2 = 0;
    m_nLastProgressTran = 0;
    m_nLastProgressObq2 = 0;
    m_nProgressTran = 0;
    m_nProgressObq2 = 0;
	//  return TRUE;
}

void CInspect::OnMotion() 
{
    // TODO: Add your control notification handler code here
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnMotion();
    if (m_nID != 0)
        CheckRadioButton(IDC_MOTION, IDC_TIME, IDC_MOTION);

    m_nTimeMotion = INSPECT_MOTION;
    ConfigRec.bMotionTime = (ConfigRec.bMotionTime & 0xFE) | ((BYTE) m_nTimeMotion);
    if ( ((m_nControlSel == INSPECT_RUN) || (m_nControlSel == INSPECT_RECORD)) && (m_nID == 0) )
    {
        SendMsg(RUN_MODE);
        m_pTcpThreadRxList->SendSlaveMsg(RUN_MODE, (WORD) m_nTimeMotion,0,0,0,0,0);
		pCTscanDlg->EnableInstrumentPanels();
    }
}


void CInspect::OnPlay() 
{
    // TODO: Add your control notification handler code here
    if (GetCheckedRadioButton(IDC_STOP, IDC_RECORD) != IDC_PLAY)
        return;

    CString s, t, sFileName;
    DWORD len, readSize;
    int nResult;
    I_MSG_RUN   *pImsg01;
    time_t  tReplayTime;


    if (m_nControlSel != INSPECT_STOP)
    {
        m_nControlSel = m_nControlSelLast;
        UpdateData(FALSE);
        return;
    }
    
    StopTimer();
    SendMsg(NOP_MODE);
    m_pTcpThreadRxList->SendSlaveMsg(NOP_MODE, 0,0,0,0,0,0);

    InitWallStatistics();   // prep for Exxon statistics
    ReplayRec.LastJoint = 0;   // not allowed.  start of new file
    ReplayRec.Pos = 0;

	//    m_nControlSelLast = m_nControlSel = INSPECT_PLAY;
    UpdateData(FALSE);  // Copy variables to screen

    if ( m_pDataFile)
    {   // close and remove old file handle
        m_pDataFile->Close();
        delete m_pDataFile;
        m_pDataFile = NULL;
    }

    if ( m_pDataIndexFile)
    {   // close and remove old file handle
        m_pDataIndexFile->Close();  // get exception if canceled in beginning
        delete m_pDataIndexFile;
        m_pDataIndexFile = NULL;
    }

    if ( m_pDataCsvFile)
    {   // close and remove old file handle
        m_pDataCsvFile->Close();    // get exception if canceled in beginning
        delete m_pDataCsvFile;
        m_pDataCsvFile = NULL;
    }

    TCHAR szFilter[] = _T("Data Files(*.dat) | *.dat||");
    CFileDialog dlg (TRUE, _T("dat"), _T("*.dat"),NULL, 
                 szFilter);

	s = pCTscanDlg->m_szDefDataDir;
    if (s.GetLength()) 
		dlg.m_ofn.lpstrInitialDir = pCTscanDlg->m_szDefDataDir;
	else
		dlg.m_ofn.lpstrInitialDir = _T("C:\\PhasedArray");

    nResult = dlg.DoModal();

    if ( nResult == IDOK)
    {
        CString s;
        s = dlg.GetPathName();
		sFileName = dlg.GetFileName();
        m_DataPathName = s;

        CFile file (s, CFile::modeRead|CFile::shareDenyNone);    // file is on stack in OnPlay
        m_pDataFile = (CFile *)file.Duplicate();    // persistent file
        file.Close();
 
        if (CReplay::m_pDlg != NULL)
        CReplay::m_pDlg->OnRpQuit();
        sconfig = ConfigRec.JobRec.CfgFile;

		pCTscanDlg->SaveOriginalConfigRec();
        readSize = (DWORD) m_pDataFile->Read(&ConfigRec, sizeof(ConfigRec));
        len = (DWORD) m_pDataFile->Seek(CONFIG_REC_SIZE, CFile::begin);  
    }
    else    // must be cancel
    {
        OnStop();
        return;
    }

    // Chop off the '.dat' extension and add '.idx'
    s = m_DataPathName;
    char tmp[120];
	CstringToChar(s,tmp);
    //strcpy(tmp,s);
    len = strlen(tmp);
    if ( len > 4) tmp[len-3] = 0;   // put null after period
    strcat(tmp,"idx");
    s = tmp;
	CstringToChar(sFileName, tmp);
    len = strlen(tmp);
    if ( len > 4) tmp[len-3] = 0;   // put null after period
    strcat(tmp,"idx");
    sFileName = tmp;

	TCHAR cDriveLetter;
	cDriveLetter = s.GetAt(0);
	t.Format(_T("%c:"),cDriveLetter);
	if ( GetDriveType(t) == DRIVE_CDROM )
	{
		s.Format(_T("C:\\Temp\\%s"),sFileName);
	}

    // Open or create the index file.
    CWaitCursor cursor; // display hour glass until thru with building
                        // replay window
    nResult = 0;    // used here as flag to call build indx routine
    try
    {
        // assume it already exists
        CFile Ifile (s, CFile::modeRead);
        if ( Ifile.GetLength() < 10)
        {
            nResult = 1;
            m_pDataIndexFile = NULL;    // No exitsing file
            Ifile.Close();
        }
        else
        {
			if ( GetDriveType(t) != DRIVE_CDROM )
			{
				m_pDataIndexFile = (CFile *)Ifile.Duplicate();  // persistent file
			}
			else
			{
				nResult = 1;
				m_pDataIndexFile = NULL;    // No exitsing file
				Ifile.Close();
				Ifile.Remove(s);
			}
        }
    }
    catch (CFileException* e)
    {
        e->Delete();
        nResult = 1;    // file doesn't exist
        m_pDataIndexFile = NULL;    // No exitsing file
    }


    if ( nResult)
    {   // need to create and rebuild index file
        try
        {
            CFile Ifile (s, CFile::modeCreate | CFile::modeReadWrite);
            m_pDataIndexFile = (CFile *)Ifile.Duplicate();  // persistent file
			//          Ifile.Close();
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            nResult = 0;    // file still doesn't exist
            m_pDataIndexFile = NULL;    // No exitsing file
            return;
        }
        if ( nResult)
        {
            CBldIndx BldDlg;
            BldDlg.DoModal();
        }
    }
    m_nControlSelLast = m_nControlSel = INSPECT_PLAY;


    GetConfigRecValues();       // update member variables with config.rec
    pCTscanDlg->ConfigToStatScreen();
    DrawThold(0);   // wall
    DrawThold(1);   // long
    DrawThold(2);   // tran
    DrawThold(3);   // 0blq1
    DrawThold(4);   // 0blq2
    DrawThold(5);   // 0blq3
    pImsg01 = new I_MSG_RUN;
    m_pDataFile->Seek(CONFIG_REC_SIZE, CFile::begin);  
    m_pDataFile->Read(pImsg01, sizeof(I_MSG_RUN));  // read & rewind to start of joint
    m_dwCurrentJoint = (DWORD) pImsg01->InspHdr.JointNumber;
    tReplayTime = pImsg01->InspHdr.time;
    delete pImsg01;

    if ( pCTscanDlg)
    {
        //pCTscanDlg->SetJointNumber( m_dwCurrentJoint);
        if (pCTscanDlg->UpdateTimeDate(&tReplayTime))
        {
            AfxMessageBox(_T("Bad data, Cannot display !"));
            OnStop();
            return;
        }
    }


    ShowDlgTitle();
    // Force Replay dlg to select starting joint number
    m_dwCurrentJoint = 0xffff;

    // Get Data from file instead of Ethernet
    // Loop thru file taking data out until file ends
    m_pDataFile->Seek(CONFIG_REC_SIZE, CFile::begin);   // rewind to start of joint

#if REPLAY_IS_MODELESS

    if (CReplay::m_pDlg == NULL)
    {
        CReplay::m_pDlg = new CReplay;
        if (CReplay::m_pDlg) CReplay::m_pDlg->Create(IDD_REPLAY);
    }
#endif

	pCTscanDlg->EnableInstrumentPanels();
	//  ::PostMessage(m_hWnd,WM_USER_PLAY_ONE_PIPE,0,0);
}


void CInspect::OnRecord() 
{
	CString s;
    if (GetCheckedRadioButton(IDC_STOP, IDC_RECORD) != IDC_RECORD)
        return;

    // TODO: Add your control notification handler code here
    DWORD len;

    if (m_nControlSel != INSPECT_STOP)
    {
        m_nControlSel = m_nControlSelLast;
        UpdateData(FALSE);
        return;
    }

    OnInspEraseAll();

    InitWallStatistics();   // prep for Exxon statistics
    if (m_pDataFile) 
		return;    // already recording

	m_DataPathName = _T("");

    m_nControlSel = INSPECT_STOP;

    int write_cnt = CONFIG_REC_SIZE;  //0x2000; // 8k space for config file
    // assume config file less than 8k always

    TCHAR szFilter[] = _T("Data Files(*.dat) | *.dat||");
    CFileDialog dlg (FALSE, _T("dat"), _T("*.dat"),NULL, 
                 szFilter);
	CString szTitle = _T ("Record Data to Hard Disk");
	dlg.m_ofn.lpstrTitle = szTitle;
	s = pCTscanDlg->m_szDefDataDir;
    if (s.GetLength()) 
		dlg.m_ofn.lpstrInitialDir = pCTscanDlg->m_szDefDataDir;
	else
		dlg.m_ofn.lpstrInitialDir = _T("C:\\PhasedArray");

    if ( dlg.DoModal() == IDOK)
    {   
		// file open dialog returned OK
        CString s, t, sFileName;
		TCHAR cDriveLetter;
        s = dlg.GetPathName();
		sFileName = dlg.GetFileName();
		cDriveLetter = s.GetAt(0);
		t.Format(_T("%c:"),cDriveLetter);
		if ( GetDriveType(t) != DRIVE_FIXED )
		{
			AfxMessageBox(_T("This is NOT a hard disk."));
			CheckRadioButton(IDC_STOP, IDC_RECORD, IDC_STOP);
			//OnStop();
			return;
		}

        try
        {
            CFile file (s, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite);

			if (file.GetLength()>10)  // existing file
				FindMaxJointNum(&file);

            // PREFIX THE file with the current config record
            while ( write_cnt > 0)
            {
				file.SeekToBegin();
                file.Write(&ConfigRec, CONFIG_REC_SIZE );
                write_cnt = -1;
            }
            // when this procedure closes, it will close the open file

            // duplicate this file into a handle which is persistent
            m_pDataFile = (CFile *)file.Duplicate();    // persistent file
			m_DataPathName = s;
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
			CreateRecordFileOnCD(sFileName);
#endif
            if (pCTscanDlg->m_pInspectDlg2)
                pCTscanDlg->m_pInspectDlg2->CreateRecordFile(m_DataPathName);
			//          file.Close();
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            m_pDataFile = NULL; // No exitsing file
            return;
        }

        ShowDlgTitle();

        //If index file already exists, delete it to force new build
        char tmp[120];
		CstringToChar(s,tmp);
        //strcpy(tmp,s);
        len = strlen(tmp);
        if ( len > 4) tmp[len-3] = 0;   // put null after period
        strcat(tmp,"idx");
        s = tmp;
        try
        {
            // assume it already exists
            CFile Ifile (s, CFile::modeReadWrite);
            try
            {
                Ifile.Close();  //necessary!
                Ifile.Remove(s);
            }
            catch (CFileException* e)
            {
                e->ReportError();
                e->Delete();
                m_pDataIndexFile = NULL;    // No exitsing file
                t = _T("Can not delete index file ");
                t += s;
                MessageBox(t);
            }
        }
        catch (CFileException* e)
        {
			//          e->ReportError();
            e->Delete();
            m_pDataIndexFile = NULL;    // No exitsing file
        }


        m_nControlSel = INSPECT_RECORD;
        m_nControlSelLast = m_nControlSel;
        SendMsg(RUN_MODE);
        if (m_nID == 0)
        {
            m_pTcpThreadRxList->SendSlaveMsg(RUN_MODE, (WORD) m_nTimeMotion,0,0,0,0,0);
            //m_pTcpThreadRxList->StartTcpAcqDataThread();
			pCTscanDlg->EnableInstrumentPanels();
        }

        // Open a csv file if wall statistics being generated
        if  ( !ConfigRec.JobRec.WallStatFlag) return;   //skip wall stats

        //strcpy(tmp,s);
		CstringToChar(s,tmp);
        len = strlen(tmp);
        if ( len > 4) tmp[len-3] = 0;   // put null after period
        strcat(tmp,"csv");
        s = tmp;
        try
        {
            CFile Csvfile (s, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite);
            // duplicate this file into a handle which is persistent
            m_pDataCsvFile = (CFile *)Csvfile.Duplicate();  // persistent file
			//          file.Close();
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            m_pDataCsvFile = NULL;  // No exitsing file
        }

        try
        {
            len = (DWORD) m_pDataCsvFile->GetLength();
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            return;
        }
        if ( len == 0)
        {   // beginning of file... add ascii column labels
            switch(ConfigRec.JobRec.WallStatFlag)
            {
				case WALL_OPT_NONE:
					default:
					return;

				case WALL_OPT_EXXON:
					s.Format(_T("Work Order: %s\r\n\r\n"), ConfigRec.JobRec.WO);
					s += _T("Joint, Minimum, Maximum, Average, Minimum, Maximum, Delta, Tally, Date, Time\r\n");
					s +=_T(", Wall, Wall, Wall, Moving, Moving, , , , \r\n");
					s +=_T(", , , , Average, Average, , , ,\r\n\r\n");
					break;
				case WALL_OPT_TUBO:
					s.Format(_T("Work Order: %s\r\n\r\n"), ConfigRec.JobRec.WO);
					s += _T("Joint,Minimum,Minimum,Average,Minimum,Minimum,Maximum,Eccentricity\r\n");
					s += _T("Number,Wall,Wall,Wall,Average,Average,Wall,\r\n");
					s += _T(",,Location,,,Location,,\r\n\r\n");
					break;
            }  //end switch
            m_pDataCsvFile->Write(s,s.GetLength());
        }
    }   // end file open dialog returned OK
	else
	{
		//OnStop();
		CheckRadioButton(IDC_STOP, IDC_RECORD, IDC_STOP);
	}
}


void CInspect::OnRun() 
{
    // TODO: Add your control notification handler code here
    if (m_nControlSel != INSPECT_STOP)
    {
        m_nControlSel = m_nControlSelLast;
        UpdateData(FALSE);
        return;
    }

    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnRun();

    if (m_nID != 0)
        CheckRadioButton(IDC_STOP, IDC_RECORD, IDC_RUN);

    OnInspEraseAll();
    m_DataPathName = _T(" ");
    m_nControlSelLast = m_nControlSel = INSPECT_RUN;
    SendMsg(RUN_MODE);
    InitWallStatistics();   // prep for Exxon statistics
    if (m_nID == 0)
    {
        m_pTcpThreadRxList->SendSlaveMsg(RUN_MODE, (WORD) m_nTimeMotion,0,0,0,0,0);
        //m_pTcpThreadRxList->StartTcpAcqDataThread();
		pCTscanDlg->EnableInstrumentPanels();
    }
}


void CInspect::OnScale50() 
{
    // TODO: Add your control notification handler code here
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnScale50();
    if (m_nID != 0)
        CheckRadioButton(IDC_SCALE50, IDC_SCALE75, IDC_SCALE50);

    m_nScaleSel = INSPECT_SCALE_50;
    m_nScale = 50*12;       // scale size in 1 INCH increments
    OnInspEraseAll();
    DrawXTicks();

	m_pTcpThreadRxList->SendSlaveMsg(SET_X_SCALE, 600,0,0,0,0,0);
}

void CInspect::OnScale75() 
{
    // TODO: Add your control notification handler code here
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnScale75();
    if (m_nID != 0)
        CheckRadioButton(IDC_SCALE50, IDC_SCALE75, IDC_SCALE75);

    m_nScaleSel = INSPECT_SCALE_75;
    m_nScale = 75*12;       // scale size in 1 INCH increments
    OnInspEraseAll();
    DrawXTicks();

	m_pTcpThreadRxList->SendSlaveMsg(SET_X_SCALE, 900,0,0,0,0,0);
    
}

void CInspect::StopTimer(void)
{   // helper function to stop timer with one call
    if (m_uIpxTimer)
        {
        KillTimer(m_uIpxTimer);
        m_uIpxTimer = 0;
        }
    EnterNopMode();
}

void CInspect::StartTimer(void)
{   // helper function to start timer with one call
    ExitNopMode();
    if (m_uIpxTimer)    return; // already running

    // 7 ticks per second
    //if (m_nID == 0)
    {
        m_uIpxTimer = SetTimer(IDT_IPX_TIMER, 330, NULL);
        if (!m_uIpxTimer) MessageBox(_T("Failed to start IPX timer"));
    }
}

void CInspect::OnStop() 
{
    // TODO: Add your control notification handler code here
    m_nControlSel =  INSPECT_STOP;
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnStop();
	//if (m_nID != 0)
    CheckRadioButton(IDC_STOP, IDC_RECORD, IDC_STOP);

	//AfxMessageBox(("OnStop"));

    if (m_nID == 0)
    {
        m_pTcpThreadRxList->SendSlaveMsg(NOP_MODE, 0,0,0,0,0,0);
        if (CReplay::m_pDlg != NULL)
        {
            CReplay::m_pDlg->OnRpQuit();
        }

		pCTscanDlg->EnableInstrumentPanels();
    }

    //m_pTcpThreadRxList->StopTcpAcqDataThread();
        ::Sleep(100);
    SetDlgItemText (IDC_EDIT_JOINTNUM, NULL);
//    SetFocus();
    StopTimer();
//    m_nControlSel = m_nControlSelLast = INSPECT_STOP;
//  CheckRadioButton(IDC_STOP, IDC_RECORD, IDC_STOP);
//    UpdateData(FALSE);
    SendMsg(NOP_MODE);

    //if (m_pFlawReport) 
		//m_pFlawReport->KillMe();

    InitWallStatistics();   // prep for Exxon statistics
    if (m_nID == 0)
    {
        if (m_pDataFile)
        {
            m_pDataFile->Close();
            delete m_pDataFile;
            m_pDataFile = NULL;
        }

        if (m_pDataFileCD)
        {
            m_pDataFileCD->Close();
            delete m_pDataFileCD;
            m_pDataFileCD = NULL;
        }

        if ( m_pDataIndexFile)
        {   // close and remove old file handle
            m_pDataIndexFile->Close();  // get exception if canceled in beginning
            delete m_pDataIndexFile;
            m_pDataIndexFile = NULL;
        }

        if ( m_pDataCsvFile)
        {   // close and remove old file handle
            m_pDataCsvFile->Close();    // get exception if canceled in beginning
            delete m_pDataCsvFile;
            m_pDataCsvFile = NULL;
        }
	}
	else if (m_nID == 1)
	{
		m_pDataFile = NULL;
		m_pDataFileCD = NULL;
		m_pDataIndexFile = NULL;
		m_pDataCsvFile = NULL;
	}
    StartTimer();

    pCTscanDlg->m_bInstAutoRun = TRUE;

	if (m_bRunCalJoint)
		UnCheckCalRun();
}


void CInspect::OnTime() 
{
    // TODO: Add your control notification handler code here
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnTime();
    if (m_nID != 0)
        CheckRadioButton(IDC_MOTION, IDC_TIME, IDC_TIME);

    m_nTimeMotion = INSPECT_TIME;
    ConfigRec.bMotionTime = (ConfigRec.bMotionTime & 0xFE) | ((BYTE) m_nTimeMotion);
    if ( (m_nControlSel == INSPECT_RUN) || (m_nControlSel == INSPECT_RECORD) )
    {
        SendMsg(RUN_MODE);
        if (m_nID == 0)
		{
            m_pTcpThreadRxList->SendSlaveMsg(RUN_MODE, (WORD) m_nTimeMotion,0,0,0,0,0);
			pCTscanDlg->EnableInstrumentPanels();
		}
    }
}


void CInspect::OnCkLong() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
    
}


void CInspect::OnCkOblq1() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
    
}


void CInspect::OnCkOblq2() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
    
}


void CInspect::OnCkOblq3() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
    
}


void CInspect::OnCkTran() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
    
}


void CInspect::OnCkWall() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
    
}


void CInspect::OnIdCheck() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
}


void CInspect::OnOdCheck() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
}



HBRUSH CInspect::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
    // See Prosise p 376

    HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
    
    // TODO: Change any attributes of the DC here
    // Intercept message to paint for ID/OD check boxes and 
    // Change color of text
        if ( (pWnd->m_hWnd == GetDlgItem(IDC_SCALE50)->m_hWnd) )
        {   // ID check text is RED
            pDC->SetTextColor(RGB(255,0,0));
        }

    if ( nCtlColor == CTLCOLOR_STATIC)
    {

        if ( (pWnd->m_hWnd == GetDlgItem(IDC_ID_CHECK)->m_hWnd) )
        {   // ID check text is RED
            pDC->SetTextColor(RGB(255,0,0));
        }
        else if ( (pWnd->m_hWnd == GetDlgItem(IDC_OD_CHECK)->m_hWnd) )
        {   // OD check ext is blue
            pDC->SetTextColor(RGB(0,0,255));
        }
    }
    
    // TODO: Return a different brush if the default is not desired
    return hbr;
}


void CInspect::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    // TODO: Add your message handler code here
    CMenu Menu;
    CPoint pt;
    CRect rect;

    // p 117, Teach Yourself VC++ 6 in 21 days & p238
    // p238 Prosise

    // Preserve the system menu properties
    pt = point;
    GetClientRect(&rect);
    ScreenToClient(&pt);

    // Was the mouse clicked on the client area or system area?
    if ( rect.PtInRect (pt) )
    {   // client area
        Menu.LoadMenu(IDR_MENU_INSPECT);

        CMenu *pContextMenu = Menu.GetSubMenu(0);
        pContextMenu->TrackPopupMenu( TPM_LEFTALIGN |
                        TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                        point.x, point.y, this, NULL);
    }
    else 
	{
		CWnd::OnContextMenu(pWnd,point);   // system area
	}
    
}


/************** Context Menu Commands *********************/
/************** Acal.cpp has its own set of menu cmnds ****/

void CInspect::OnTholds() 
{
    // TODO: Add your command handler code here
    // 1-21-00  Display thold modeless dialog to set tholds for
    // Inspection/graphs/map

    CTholds dlg;
    dlg.DoModal();

}


void CInspect::OnNcnx() 
{
    // TODO: Add your command handler code here
    // 07-28-00 Display NcNX modeless dialog to set Nc & Nx for
    // Wall & flaw averaging 

    CNc dlg;
    dlg.DoModal();
    
}


void CInspect::OnIpxstats() 
{
    // TODO: Add your command handler code here
    // 07-28-00 Display NcNX modeless dialog to set Nc & Nx for
    // Wall & flaw averaging 

    if (CIpxStat::m_pDlg == NULL)
    {
        CIpxStat::m_pDlg = new CIpxStat;
        if (CIpxStat::m_pDlg) 
			CIpxStat::m_pDlg->Create(IDD_IPX_STATS);
    }

    // If this window gets covered up by inspect, kill it
    // then the next attempt to show it will succeed.
    // Always on top may not be good since we would be tempted to 
    // do that with all the context menu selections which could
    // not have all of them on top.

    else 
	{
		CIpxStat::m_pDlg->KillMe();    // kill the window
	}
    
}


void CInspect::OnChartAssign() 
{
    // TODO: Add your command handler code here
    // 07-28-00 Display NcNX modeless dialog to set Nc & Nx for
    // Wall & flaw averaging 

    if (CStrpChnl::m_pDlg == NULL)
    {
        CStrpChnl::m_pDlg = new CStrpChnl;
        if (CStrpChnl::m_pDlg) 
			CStrpChnl::m_pDlg->Create(IDD_STRIP_CHNLS);
    }

    // If this window gets covered up by inspect, kill it
    // then the next attempt to show it will succeed.
    // Always on top may not be good since we would be tempted to 
    // do that with all the context menu selections which could
    // not have all of them on top.

    else 
	{
		CStrpChnl::m_pDlg->KillMe();   // kill the window
	}
    
}


/**********************************************************/
/** COMPUTE RECT of each graph window relative to containing
*** Inspect Dlg window.  Used to tell which control button
*** (graph window) the mouse is over        ***************/

void CInspect::MakeMouseRect(void) 
{
    CRect Rect;     // temp rect

    m_cbMap.GetClientRect(&Rect);   // rect of map control button
    m_MouseMapRect = Rect;
    // Find out where Image map is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbMap.m_hWnd, m_hWnd, (LPPOINT) &m_MouseMapRect, 2);

    // Wall Graph Button to InspDlg coords
    m_cbInspWall.GetClientRect(&Rect);  // rect of map control button
    m_MouseFlawRect[0] = Rect;
    // Find out where Wall Graph is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbInspWall.m_hWnd, m_hWnd, (LPPOINT) &m_MouseFlawRect[0], 2);

    // Long Graph Button to InspDlg coords
    m_cbInspLong.GetClientRect(&Rect);  // rect of map control button
    m_MouseFlawRect[1] = Rect;
    // Find out where Long Graph is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbInspLong.m_hWnd, m_hWnd, (LPPOINT) &m_MouseFlawRect[1], 2);

    // TranGraph Button to InspDlg coords
    m_cbInspTran.GetClientRect(&Rect);  // rect of map control button
    m_MouseFlawRect[2] = Rect;
    // Find out where Tran Graph is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbInspTran.m_hWnd, m_hWnd, (LPPOINT) &m_MouseFlawRect[2], 2);

    // Oblq1 Graph Button to InspDlg coords
    m_cbInspOblq1.GetClientRect(&Rect); // rect of map control button
    m_MouseFlawRect[3] = Rect;
    // Find out where Oblq Graph is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbInspOblq1.m_hWnd, m_hWnd, (LPPOINT) &m_MouseFlawRect[3], 2);

    // Oblq2 Graph Button to InspDlg coords
    m_cbInspOblq2.GetClientRect(&Rect); // rect of map control button
    m_MouseFlawRect[4] = Rect;
    // Find out where Oblq Graph is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbInspOblq2.m_hWnd, m_hWnd, (LPPOINT) &m_MouseFlawRect[4], 2);

    // Oblq1 Graph Button to InspDlg coords
    m_cbInspOblq3.GetClientRect(&Rect); // rect of map control button
    m_MouseFlawRect[5] = Rect;
    // Find out where Oblq Graph is in InspDlg window coords
    // win32 call  m_hWnd is the inspect dlg window handle
    ::MapWindowPoints(m_cbInspOblq3.m_hWnd, m_hWnd, (LPPOINT) &m_MouseFlawRect[5], 2);

}


void CInspect::OnMouseMove(UINT nFlags, CPoint point) 
{
    // TODO: Add your message handler code here and/or call default

    // Display screen coord for now
    CPoint pt;
    CString s;
    int dx, dy;     // range of x and y in graph rect.
    int y;
    float fx, fy, fdy;
    BOOL bPercent;
    int i;


    pt = point;     // point is in InspectDlg window coord's

    bPercent = TRUE;

    // Which Rect is this point in?
    // Try the map
    if (m_MouseMapRect.PtInRect(pt) )
    {   
		// Image Map
        pt.x -= m_MouseMapRect.left;
        pt.y = m_MouseMapRect.bottom - pt.y;    // -1;
        dx = m_MouseMapRect.right - m_MouseMapRect.left;
        dy = m_MouseMapRect.bottom - m_MouseMapRect.top;
#if IN_DEGREES
        y = (360*pt.y + dy/2)/ dy;      // full scale is 360 degrees
#else
        y = (12*pt.y + dy/2)/ dy;       // full scale is 12 clock
        if ( y == 0) y = 12;
#endif
        bPercent = FALSE;
        goto MOUSE_END;
    }


    // still not found
    for ( i = 0; i < N_FLAW_TYPES; i++)
    {
         if (m_MouseFlawRect[i].PtInRect(pt) )
         {   
			 // Long/Tran/Oblq graph
            pt.x -= m_MouseFlawRect[i].left;
            pt.y = m_MouseFlawRect[i].bottom - pt.y;    // -1;
            dx = m_MouseFlawRect[i].right - m_MouseFlawRect[i].left;
            dy = m_MouseFlawRect[i].bottom - m_MouseFlawRect[i].top;
            fdy = (float) dy;
            fy = (float) pt.y;
            if ( i == 0)    // wall
            {
                fdy /= 2.0f;  // from base line to mid scale
                fy = (fy - fdy)/ fdy; // fract of scale up or down from center
                if ( fy < 0.0f) y = (int) ( (float) MAX_DELTA_WALL* fy - 0.5f);
                else y = (int) ( (float) MAX_DELTA_WALL* fy + 0.5f);
            }

            else
            {
                y = (int) (200.0f*fy/fdy + 0.5f);   // top to bottom is 200%.  Od in top 100%
                if ( y >= 100) y -= 100;
            }
            goto MOUSE_END;
        }
    }


//  else
    {   
		// we don't know blank screen areas
		s.Format(_T("       "));
		m_ceCursorX.SetWindowText(s);
		m_ceCursorY.SetWindowText(s);
		CDialog::OnMouseMove(nFlags, point);
		return;
    }

MOUSE_END:
    if ( m_bMetric)
    {
        fx = ((float) pt.x )/(float) dx * (float)m_nScale / 12.0f;
        fx *= 0.3048f;
        s.Format(_T("%4.2f"), fx);
    }
    else    //English
    {
        fx = ((float) pt.x )/(float) dx * (float)m_nScale / 12.0f;
        s.Format(_T("%4.1f"), fx);
    }
    m_ceCursorX.SetWindowText(s);
    
    if (bPercent) 
		s.Format(_T("%3d %c"), y, '%');
    else 
		s.Format(_T("%3d"), y);

    m_ceCursorY.SetWindowText(s);
    
    CDialog::OnMouseMove(nFlags, point);
}


void CInspect::ShowDlgTitle()
{
    // show the config file name and TruImage moniker
    CString s,t;

    //s = _T("TruScan Inspection     Cfg File = ");
    s.Format(_T("%s Display    Cfg File = "), SYSTEM_NAME);
	t = ConfigRec.JobRec.CfgFile;
    if ( t.GetLength() < 128)
    {
        t = ConfigRec.JobRec.CfgFile;
        s += t;
    }
    if (m_pDataFile)
    {
        s += _T("    Record File = ");
        s += m_DataPathName;
    }
    SetWindowText(s);

}


BOOL CInspect::SendMsg(int MsgNum)
{   
	// wrapper so we don't have to reference msg sender
    // in Asidlg window.
    if (pCTscanDlg == NULL) 
		return FALSE;
    
    return  pCTscanDlg->SendMsg(MsgNum);
}


void CInspect::OnCkMetric() 
{

    m_bMetric=IsDlgButtonChecked(IDC_CK_METRIC);
    ConfigRec.bEnglishMetric = m_bMetric & 1;
    if (pCTscanDlg) 
	{
		pCTscanDlg->m_bMetric = m_bMetric;
		pCTscanDlg->UpdateTitleBar();
	}

    OnCkMetric1();
//        UpdateData(FALSE);
}


void CInspect::OnCkMetric1() 
{
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
         pCTscanDlg->m_pInspectDlg2->OnCkMetric1();
    UpdateData(TRUE);   // Copy screen to variables
    OnInspEraseAll();
    m_bMetric= ConfigRec.bEnglishMetric;
    if (pCTscanDlg) 
	{
		pCTscanDlg->m_bMetric = m_bMetric;
		pCTscanDlg->UpdateTitleBar();
	}

    if (m_bMetric)
    {   // metric scales 15/22 meters
        CheckDlgButton( IDC_CK_METRIC,1);
        GetDlgItem(IDC_SCALE50)->SetWindowText(_T("15"));
        GetDlgItem(IDC_SCALE75)->SetWindowText(_T("22"));
    }
    else
    {
        CheckDlgButton( IDC_CK_METRIC,0);
        GetDlgItem(IDC_SCALE50)->SetWindowText(_T("50"));
        GetDlgItem(IDC_SCALE75)->SetWindowText(_T("75"));
    }

    DrawXTicks();

}


void CInspect::GetNextFlaw(FLAW_REC *pF, int i)
{   
	// return a flaw record from one of the linked lists
    // if no element in list, create one with x loc = 20,000
    // removes element from linked lists

    FLAW_REC *pFlaw;

    switch (i)
    {
		case 0:
			// Wall Id/Od
			if(!m_plistWallFlaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistWallFlaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalWallCnt--;
				return;
            }
			break;

		case 1:
			// LID/LOD
			if(!m_plistLongFlaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistLongFlaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalFlawCnt--;
				return;
            }
			break;

		case 2:
			// TID/TOD
			if(!m_plistTranFlaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistTranFlaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalFlawCnt--;
				return;
			}
			break;

		case 3:
			// QID/QOD
			if(!m_plistOblq1Flaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistOblq1Flaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalFlawCnt--;
				return;
            }
			break;

		case 4:
			// QID/QOD
			if(!m_plistOblq2Flaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistOblq2Flaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalFlawCnt--;
				return;
            }
			break;

		case 5:
			// QID/QOD
			if(!m_plistOblq3Flaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistOblq3Flaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalFlawCnt--;
				return;
            }
			break;

		case 6:
			// QID/QOD
			if(!m_plistLaminFlaw.IsEmpty())
            {
				pFlaw = (FLAW_REC *) m_plistLaminFlaw.RemoveHead();
				memcpy( (void *) pF, (void *) pFlaw, sizeof(FLAW_REC));
				delete pFlaw;
				m_nTotalFlawCnt--;
				return;
            }
			break;

		default:
			break;
    }  //end switch

    // list was empty, return x loc far beyond real pipe length
    pF->xloc = 20000;

}


int CInspect::GetMinXFlaw(FLAW_REC *f1, FLAW_REC *f2, 
                          FLAW_REC *f3, FLAW_REC *f4,
                          FLAW_REC *f5, FLAW_REC *f6,
						  FLAW_REC *f7)
{   
	// ASI scanned 3 flaw cats, UT scans 6
    int x, i;
    x = f1->xloc;
    i = 0;

    if ( x > f2->xloc)
    {
        x = f2->xloc;
        i = 1;
    }

    if ( x > f3->xloc)
    {
        x = f3->xloc;
        i = 2;
    }

    if ( x > f4->xloc)
    {
        x = f4->xloc;
        i = 3;
    }

    if ( x > f5->xloc)
    {
        x = f5->xloc;
        i = 4;
    }

    if ( x > f6->xloc)
    {
        x = f6->xloc;
        i = 5;
    }

    if ( x > f7->xloc)
    {
        x = f7->xloc;
        i = 6;
    }

    return i;   // index of smallest 'x' location flaw 0-3
}


void CInspect::EraseFlawLists()
{
    FLAW_REC *pFlaw;

    while (!m_plistWallFlaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistWallFlaw.RemoveHead();
        delete pFlaw;
    }

    while (!m_plistLongFlaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistLongFlaw.RemoveHead();
        delete pFlaw;
    }

    while (!m_plistTranFlaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistTranFlaw.RemoveHead();
        delete pFlaw;
    }

    // oblq1
    while (!m_plistOblq1Flaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistOblq1Flaw.RemoveHead();
        delete pFlaw;
    }

    // oblq2
    while (!m_plistOblq2Flaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistOblq2Flaw.RemoveHead();
        delete pFlaw;
    }

    // oblq3
    while (!m_plistOblq3Flaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistOblq3Flaw.RemoveHead();
        delete pFlaw;
    }

    // laminar
    while (!m_plistLaminFlaw.IsEmpty())
    {
        pFlaw = (FLAW_REC *) m_plistLaminFlaw.RemoveHead();
        delete pFlaw;
    }

    // apparently none of these are used now

    m_nWallMaxCnt = m_nWallMinCnt = 0;
    m_nLodFlawCnt = m_nLidFlawCnt = 0;
    m_nTodFlawCnt = m_nTidFlawCnt= 0;
    m_nQ1odFlawCnt = m_nQ1idFlawCnt= 0;
    m_nQ2odFlawCnt = m_nQ2idFlawCnt= 0;
    m_nQ3odFlawCnt = m_nQ3idFlawCnt= 0;
	m_nLamodFlawCnt = m_nLamidFlawCnt= 0;
    m_nTotalFlawCnt = m_nTotalWallCnt = 0;

}


void CInspect::OnAutoPrint() 
{
    // TODO: Add your control notification handler code here
    UpdateData(TRUE);   // Copy screen TO variables 
}


void CInspect::UpdateStatusQRTotals()
{
    // Update the quest/reject count per joint and 
    // total number of joints which are quest/rej/ok on the
    // TscanDlg (status) window
#if 0
    CString s;

    s.Format(_T("%d"),m_nTotalFlawCnt);
    pCTscanDlg->SetDlgItemText(IDC_CURRENT_REJ,s);

    s.Format(_T("%d"),m_nTotalWallCnt);
    pCTscanDlg->SetDlgItemText(IDC_CURRENT_QUES,s);
#endif

}


CFile* CInspect::GetIndexFile()
{
    return m_pDataIndexFile;
}


CFile* CInspect::GetDataFile()
{
    return m_pDataFile;
}


BOOL CInspect::GetAutoPrintFlag()
{
    return m_bPrint;
}

void CInspect::OnAutoPrint2()
{   
	// allow Replay dlg to control auto print box on Inspect dlg
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnAutoPrint2();

    m_bPrint ^= 1;
    m_bPrint &= 1;
//    UpdateData(FALSE);  // Copy variables  TO screen
}


void CInspect::OnInspRefresh() 
{
    // TODO: Add your control notification handler code here
	//  if ( m_nControlSel != INSPECT_PLAY) return;
    if (m_pDataFile == NULL) 
		return;
    if ( ReplayRec.Pos < CONFIG_REC_SIZE) 
		return;   // in config file portion

    m_nRefresh = TRUE;
    PlayOnePipe();
    m_nRefresh = FALSE;
}


void CInspect::PlayOnePipe()
{   
	// called from replay screen by sending a windows message
    // now in play one pipe routine
    time_t  tReplayTime;
    I_MSG_RUN *pImsg01;
    int nSize;
    CString s;

    if (!m_pDataFile ) 
		return;

    if (m_pFlawReport != NULL)
    {

        m_pFlawReport->m_LBtext.ResetContent( );
        m_pFlawReport->ShowWindow(SW_SHOW);

    }

    pImsg01 = new I_MSG_RUN;
	//DWORD len = m_pDataFile->GetLength();
	if (ReplayRec.Pos <= 0x7FFFFFFF)
		m_pDataFile->Seek(ReplayRec.Pos,CFile::begin);
	else
	{
		m_pDataFile->Seek(0x7FFFFFFF, CFile::begin);
		m_pDataFile->Seek(ReplayRec.Pos - 0x7FFFFFFF, CFile::current);
	}
    nSize = m_pDataFile->Read(pImsg01, sizeof(I_MSG_RUN));  // read & rewind to start of joint
	if (ReplayRec.Pos <= 0x7FFFFFFF)
		m_pDataFile->Seek(ReplayRec.Pos,CFile::begin);
	else
	{
		m_pDataFile->Seek(0x7FFFFFFF, CFile::begin);
		m_pDataFile->Seek(ReplayRec.Pos - 0x7FFFFFFF, CFile::current);
	}
    pCTscanDlg->m_uJntNum = m_dwCurrentJoint = (DWORD) pImsg01->InspHdr.JointNumber;
    tReplayTime = pImsg01->InspHdr.time;
    delete pImsg01;


    OnInspEraseAll();
    EraseFlawLists();
    InitWallStatistics();   // prep for Exxon statistics
                
    if ( pCTscanDlg)
    {
        //pCTscanDlg->SetJointNumber( m_dwCurrentJoint);
        pCTscanDlg->UpdateTimeDate(&tReplayTime);
    }

    while (1)
    {   
		// there is a data file
        pImsg01 = new I_MSG_RUN;
        nSize = m_pDataFile->Read(pImsg01, sizeof(I_MSG_RUN));

        if (nSize != sizeof(I_MSG_RUN) )
        {   
			
            delete pImsg01;
            DrawXTicks();

            return;
        }   
           // Now have good inspection message from file
        else
        {   
			// read one I_MSG_RUN
            if ( m_dwCurrentJoint != (DWORD) pImsg01->InspHdr.JointNumber)
            {  
				// End of previous pipe

                UpdateStatusQRTotals();
                DrawXTicks();
                delete pImsg01;

                if ( m_nRefresh)
                {
                    m_nRefresh = FALSE; //review does not put up replay dlg
                    return;
                }

                if (CReplay::m_pDlg == NULL)
                {
                    CReplay::m_pDlg = new CReplay;
                    if (CReplay::m_pDlg) CReplay::m_pDlg->Create(IDD_REPLAY);
                }
                // else maximize already existing dialog window
                return;
            }   // End of previous pipe

            m_plistUtData.AddTail( (void *) pImsg01);

#if ( (SYSTEM_ID == RAW_WALL_SYS) || (SYSTEM_SUB_ID == BESSEMER_SYS) )
			if ( (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) == 0 )
			{
				m_nHomeAway = pImsg01->InspHdr.status[2] & 0x4000;
				m_nAwayStopXloc = pImsg01->InspHdr.JointLength;
			}
#endif
			//if (pImsg01->InspHdr.xloc >= 228)
				//TRACE("xloc= %d,  status= 0x%04x, LineStatus= 0x%04x\r\n", pImsg01->InspHdr.xloc, pImsg01->InspHdr.status[1], pImsg01->InspHdr.wLineStatus);

            SetDlgItemInt (IDC_EDIT_JOINTNUM, pImsg01->InspHdr.JointNumber, FALSE);
            UpdateWindow();
			//::Sleep(0);
		    // DO NOT change the calling order of the following functions
			m_bBackward = FALSE;
			m_bPipeJustLeft = FALSE;
            DrawMap();
            if ( m_bWallCheck)  DrawWall();
            if ( m_bLongCheck)  DrawLong();
            if ( m_bTranCheck)  DrawTran();
            if ( m_bOblq1Check) DrawOblq1();
            if ( m_bOblq2Check) DrawOblq2();
            if ( m_bOblq3Check) DrawOblq3();
			if ( m_bLaminCheck) DrawLamin();
			if (m_bBackward)
				RefreshWindow();
			if (m_bPipeJustLeft)
			{
				m_bPipeJustLeft = FALSE;

#if ( (SYSTEM_ID == RAW_WALL_SYS) || (SYSTEM_SUB_ID == BESSEMER_SYS) )
				if (m_nHomeAway == 0)
				{
					ReverseReport((short) m_nAwayStopXloc, (short) SiteDefault.nDefaultXOffset2);
					TRACE("ReverseReport\n");
				}
#endif

				if (m_bPrint)  // autoprint
					PrintReportNow();
			}

            // Update speed, rpm and joint length from file data
            // force inspection msg values into Tscan Dlg variables
            pCTscanDlg->m_nRpm = gnTruscopePeriod;

            if (gnTruscopePeriod > 500)
                pCTscanDlg->m_nFpm = VELOCITY_DX_FACTOR/gnTruscopePeriod; // at least 50 ms to go 4 inches
            else 
				pCTscanDlg->m_nFpm = 0;

            pCTscanDlg->m_nJointLength = pImsg01->InspHdr.JointLength;
            pCTscanDlg->UpdateRpm();    // also displays joint length

            //pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();
    
            //delete pImsg01; 

			g_CriticalSectionChnls.Lock();
			while (!m_plistUtData.IsEmpty() )
			{
				pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();

				if ( (pCTscanDlg->m_pChnlTraceDlg != NULL) && (pImsg01->MstrHdr.MsgId == RUN_MODE) )
					g_pTcpListUtDataChnls.AddTail( (void *) pImsg01 );
				else
					delete pImsg01;
			}
			g_CriticalSectionChnls.Unlock();
        }   // read one I_MSG_RUN

    }   // there is a data file

}


void CInspect::InspEraseMach(WPARAM w, LPARAM lparam)
    {
    // Erase function driven by posting messages
    switch (w)
    {
		case 0:
			// Wall
			InspWallErase();
			break;
		case 1:
			// Long
			InspLongErase();
			break;
		case 2:
			// Tran
			InspTranErase();
			break;
		case 3:
			// Oblq
			InspOblq1Erase();
			break;
		case 4:
			// Map
			InspMapErase();
			break;
		default:      
			break;

    }  //end switch

}


void CInspect::GetConfigRecValues()
{
    // When the config record changes, make sure all member variables
    // used in program reflect the new record

	//  int i, n;

    m_nTimeMotion = ConfigRec.bMotionTime &1;
    m_bMetric = ConfigRec.bEnglishMetric & 1;

    m_nNx    = ConfigRec.UtRec.NxWall[0];
    m_nNcLid = ConfigRec.UtRec.NcLong[0];
    m_nNcLod = ConfigRec.UtRec.NcLong[1];

    m_nNcTid = ConfigRec.UtRec.NcTran[0];
    m_nNcTod = ConfigRec.UtRec.NcTran[1];

    m_nNcQ1id = ConfigRec.UtRec.NcOblq1[0];
    m_nNcQ1od = ConfigRec.UtRec.NcOblq1[1];
    m_nNcQ2id = ConfigRec.UtRec.NcOblq2[0];
    m_nNcQ2od = ConfigRec.UtRec.NcOblq2[1];
    m_nNcQ3id = ConfigRec.UtRec.NcOblq3[0];
    m_nNcQ3od = ConfigRec.UtRec.NcOblq3[1];
    m_nNcLamid = ConfigRec.UtRec.NcLamin[0];
    m_nNcLamod = ConfigRec.UtRec.NcLamin[1];
}


void CInspect::CompressFlawList(CPtrList *pL)
{
    // copy the list into itself keeping only the worst flaw at
    // a given x location

    CPtrList plistTmp;  // copy worst flaws into tmp, then back to original list
    FLAW_REC Worst, Current;    // hold worst flaw and head of list flaw
    FLAW_REC *pF;

    if ( pL->IsEmpty() ) 
		return;    // nothing to do
    if ( pL->GetCount() < 2) 
		return;    // only 1 flaw

    pF = (FLAW_REC *) pL->RemoveHead();
    memcpy( (void *) &Worst, (void *) pF, sizeof(FLAW_REC));
    delete pF;

    while ( !pL->IsEmpty() )
    {
        // copy worst flaw into plistTmp
        pF = (FLAW_REC *) pL->RemoveHead(); // get next flaw in list
        memcpy( (void *) &Current, (void *) pF, sizeof(FLAW_REC));
        delete pF;

        if (IsSameFlaw ( &Worst, &Current) )
        {
            if ( Current.amp > Worst.amp)
                SwapFlaws( &Worst, &Current);   // current biggest
            // Worst now has biggest amp flaw in it
        }
        else
        {   // different flaws
            pF = new FLAW_REC;
            memcpy( (void *) pF, (void *) &Worst, sizeof(FLAW_REC));
            plistTmp.AddTail( (void *) pF); // put worst into tmp list
            SwapFlaws( &Worst, &Current); // current becomes worst at x
        }
    }

    pF = new FLAW_REC;
    memcpy( (void *) pF, (void *) &Worst, sizeof(FLAW_REC));
    plistTmp.AddTail( (void *) pF); // put last flaw into tmp list

    // Now copy tmp list which is on stack into permanent list which
    // was just emptied of all contents

    while ( !plistTmp.IsEmpty())
    {
        pF = (FLAW_REC *) plistTmp.RemoveHead();    // get next flaw in list
        pL->AddTail((void *) pF);   // into permanent list
    }

}


BOOL CInspect::IsSameFlaw(FLAW_REC *p1, FLAW_REC *p2)
{
    // Compare two flaws to see if they are at the "same" location
    if ( p1->xloc == p2->xloc) 
		return TRUE; // same x, don't care about clock

    if ( abs(p1->xloc - p2->xloc) > 1) 
		return FALSE;    // more than 1 inch apart

    // within 1 inch of each other here
    // are they within 4 clocks = 1/3 REV = 30/3 = 10 segments
    if ( abs(p1->radial - p2->radial) < 11) 
		return TRUE;

    return FALSE;
}


void CInspect::SwapFlaws(FLAW_REC *p1, FLAW_REC *p2)
{
    // swap the flaw pointed to by p1 with the one pointed to by p2
    FLAW_REC tmp;

    memcpy ( (void *) &tmp, (void *) p1, sizeof(FLAW_REC));
    memcpy ( (void *) p1, (void *) p2, sizeof(FLAW_REC));
    memcpy ( (void *) p2, (void *) &tmp, sizeof(FLAW_REC));
}


void CInspect::InitExxonMovingAverages()
{
    // Init moving averages for doing wall statistics.
    // Must get 4*OD distance of wall reading before starting
    // wall averaging

    int i;

    mEx.nAvgLen = (int) (4.0f*ConfigRec.JobRec.OD + 0.5);   // samples in average
    if ( mEx.nAvgLen > 128) mEx.nAvgLen = 128;
    if ( mEx.nAvgLen < 2) mEx.nAvgLen = 2;
    mEx.nAvgRounding = mEx.nAvgLen/2;   // rounding factor

    m_nWallNom = (int)(ConfigRec.JobRec.Wall * 1000.0f);
    m_nWall90 = (int)(ConfigRec.JobRec.Wall * 800.0f);
    m_nWall120 = (int)(ConfigRec.JobRec.Wall * 1200.0f);

    mEx.nPassCnt = 0;       // number of times WallAvg called for this pipe
    mEx.nLastX = 0;     // last x location for averaging
    for ( i = 0; i <mEx.nAvgLen; i++)
    {
        mEx.nMinSample[i] = m_nWallNom;
    }
    memcpy ( (void *) &mEx.nAvgSample, (void *) &mEx.nMinSample, 
                sizeof(mEx.nAvgSample));
    memcpy ( (void *) &mEx.nMaxSample, (void *) &mEx.nMinSample, 
                sizeof(mEx.nMaxSample));

    mEx.lSumMin = mEx.nAvgLen*m_nWallNom;   // sum of min wall for each inch
    mEx.lSumMax = mEx.nAvgLen*m_nWallNom;   // sum of max wall for each inch
    //mEx.lSumAvg = mEx.nAvgLen*m_nWallNom;   // sum of avg wall for each inch
    mEx.nMinWall = 0x3fff;  // overall pipe min wall
    mEx.nMinAvgWall = 0x3fff;
    mEx.nMaxWall = 0;
	mEx.nMaxAvgWall = 0;
    mEx.nMaxWallPt = 0;
    mEx.nEcc = 0;               // overall pipe max ecc

	mEx.lSumAvg = 0;
	mEx.nAvgCnt = 0;
}


void CInspect::InitTuboStats()
{
    // Tubos stats are accumulated for length of inspected pipe
    // Except values more than 50% from nominal are thrown out

    m_nWallNom = (int)(ConfigRec.JobRec.Wall * 1000.0f);
    memset ( (void *) &mTubo, 0, sizeof(mTubo));
    mTubo.nMinWall = 0x3fff;    // overall pipe min wall
    mTubo.nAvgWall = 0x3fff;
    mTubo.nMinAvgWall = 0x3fff;    // overall pipe min average wall
}


void CInspect::InitWallStatistics()
{
    // Depending on type of wall statistics, init variables
    switch  ( ConfigRec.JobRec.WallStatFlag)
    {
		case WALL_OPT_NONE:
			default:
			break;

		case WALL_OPT_EXXON:
			InitExxonMovingAverages();
			break;

		case WALL_OPT_TUBO:
			InitTuboStats();
			break;

    }   //end switch
}


void CInspect::AccumulateTuboWallStats(I_MSG_RUN *pImsg01)
    {
    // Stats over full inspected length of pipe.
    // Min, Max, Ecc are most severe reading over length of
    // pipe.
    // Wall reading ignored if not within 50% of nominal
    // Amelia instrument prohibits wall > 125%

    int min, avg, max, ecc;
    int minOK, maxOK;

    // If we are covering new pipe, x is increasing
    // don't run process if we back up
    if ( mTubo.nLastX >= pImsg01->InspHdr.xloc) 
		return;

    mTubo.nLastX = pImsg01->InspHdr.xloc;

    min = pImsg01->UtInsp.MinWall;
    max = pImsg01->UtInsp.MaxWall;
    avg = pImsg01->UtInsp.AvgWall;
    ecc = abs(max - min);   // cheap and dirty
	ecc = pImsg01->UtInsp.MaxEcc;

	//TRACE("x = %d, avg wall = %d\n", pImsg01->InspHdr.xloc, avg);

    if ( ( min > m_nWallNom/2)  && (min < (m_nWallNom*3)/2))
    {
        minOK = 1;
        mTubo.lSumMin += min;
        mTubo.nMinCnt++;
    }
    else  minOK = 0;

    if ( ( max > m_nWallNom/2) && (max < (m_nWallNom*3)/2))  
		maxOK = 1;
    else  
		maxOK = 0;

    // Find minimum values of avg min and avg average
    if ( ( mTubo.nMinWall > min) && minOK)
    {
        mTubo.nMinWall = min;   // new min
        mTubo.nMinWallX = mTubo.nLastX; 
    }

    if ( ( mTubo.nMaxWall < max) && maxOK) 
	{
		mTubo.nMaxWall = max;
		mTubo.nMaxWallX = mTubo.nLastX;
	}

    // cheap and dirty eccentricity
    if ( (mTubo.nEcc < ecc) && minOK && maxOK)
	{
		mTubo.nEcc = ecc;
		mTubo.nEccX = mTubo.nLastX;
	}

    if ( minOK && maxOK && (avg>0) )
    {
        mTubo.lSumAvg += avg;
        mTubo.nAvgCnt++;

		if ( mTubo.nMinAvgWall > avg )
		{
			mTubo.nMinAvgWall = avg;   // new min
			mTubo.nMinAvgWallX = mTubo.nLastX; 
		}
    }
}


void CInspect::ExxonWallMovingAverage(I_MSG_RUN *pImsg01)
{
    // Find moving average of min wall and average wall over
    // 4 OD distance.
    // Each call of function corresponds to 1 inch of motion
    // on the pipe.  Moving average computer over 4*OD inches
    int i, min, max, avg;
	int minOK, maxOK;

    // If we are covering new pipe, x is increasing
    // don't run process if we back up
    if ( mEx.nLastX >= pImsg01->InspHdr.xloc) return;
    mEx.nLastX = pImsg01->InspHdr.xloc;

    i = mEx.nPassCnt++;
    i = i % mEx.nAvgLen;    // circular buffer of wall samples

    // Bail out if either avg or min is more than 10% deviated from nominal
    min = pImsg01->UtInsp.MinWall;
    max = pImsg01->UtInsp.MaxWall;
    avg = pImsg01->UtInsp.AvgWall;

    if ( ( min > m_nWallNom/2)  && (min < (m_nWallNom*3)/2))
        minOK = 1;
    else  
		minOK = 0;

    if ( ( max > m_nWallNom/2) && (max < (m_nWallNom*3)/2))  
		maxOK = 1;
    else  
		maxOK = 0;

    // Find minimum values of avg min and avg average
    if ( ( mEx.nMinWall > min) && minOK)
    {
        mEx.nMinWall = min;   // new min
        mEx.nMinWallX = mEx.nLastX; 
    }

    if ( ( mEx.nMaxWall < max) && maxOK) 
	{
		mEx.nMaxWall = max;
		mEx.nMaxWallX = mEx.nLastX;
	}

    if ( minOK && maxOK && (avg>0) )
    {
        mEx.lSumAvg += avg;
        mEx.nAvgCnt++;
    }

    if ( minOK == 0 ) return;

    if ( avg < m_nWall90 ) return;
    if ( avg > m_nWall120 ) return;

    if ( maxOK == 0 ) return;

    // non averaged but maximum wall ecc and max
    // For NorthStar but not Exxon
    if ( mEx.nMaxWallPt < pImsg01->UtInsp.MaxWall)
         mEx.nMaxWallPt = pImsg01->UtInsp.MaxWall;
    
    if ( mEx.nEcc < pImsg01->UtInsp.MaxEcc)
         mEx.nEcc = pImsg01->UtInsp.MaxEcc;

    // remove oldest member of samples
    mEx.lSumMin -= mEx.nMinSample[i];
    mEx.lSumMax -= mEx.nMaxSample[i];
    //mEx.lSumAvg -= mEx.nAvgSample[i];

    // store the current min, max and average wall for this 1" of pipe
    mEx.nMinSample[i] = avg;
    mEx.nMaxSample[i] = avg;
    mEx.nAvgSample[i] = avg;
    // add newest members to sums
    mEx.lSumMin += mEx.nMinSample[i];
    mEx.lSumMax += mEx.nMaxSample[i];
    //mEx.lSumAvg += mEx.nAvgSample[i];

    // Do we have enough data to start running average?
    if (mEx.nPassCnt < mEx.nAvgLen) return;

    // Compute current averages
    min = (int) ((mEx.lSumMin + mEx.nAvgRounding) / mEx.nAvgLen);
    max = (int) ((mEx.lSumMax + mEx.nAvgRounding) / mEx.nAvgLen);
    //avg = (int) ((mEx.lSumAvg + mEx.nAvgRounding)/ mEx.nAvgLen);

    // Find minimum values of avg min and avg average
    if ( mEx.nMinAvgWall > min)
        mEx.nMinAvgWall = min; // new min moving average wall
    if ( mEx.nMaxAvgWall < max) 
		mEx.nMaxAvgWall = max;
}


void CInspect::UpdateWallStatFile(WORD JointLength)
{
    // Wall statistics go into comma separated Excell file

    CString s;
    DWORD len;
    int nRnd;
	float fJointLen = JointLength / 12.0f;
	float fMinWallX, fMinAvgWallX;

	CTime   theTime = CTime::GetCurrentTime();
	CString Date, Time;
	Date = theTime.Format( "%m/%d/%Y" );
	Time = theTime.Format( "%I:%M %p" );

    switch  ( ConfigRec.JobRec.WallStatFlag)
    {
		case WALL_OPT_NONE:
		default:
			return;

		case WALL_OPT_EXXON:
			if ( mEx.nAvgCnt == 0) mEx.nAvgCnt = 1;
			nRnd = mEx.nAvgCnt/2;
			mEx.nAvgWall = (short) ((mEx.lSumAvg + nRnd) / mEx.nAvgCnt);

			//heat  pipe number, min, minx, avg, max
			s.Format(_T("%7ld, %5d, %5d, %5d, %5d, %5d, %5d, %4.1f, %s, %s\r\n"),
            m_dwJointNum, mEx.nMinWall, mEx.nMaxWall, mEx.nAvgWall,
            mEx.nMinAvgWall,  mEx.nMaxAvgWall, m_nWallDifference, fJointLen, Date, Time);
			break;

		case WALL_OPT_TUBO:
			if ( mTubo.nAvgCnt == 0) mTubo.nAvgCnt = 1;
			nRnd = mTubo.nAvgCnt/2;
			mTubo.nAvgWall = (short) ((mTubo.lSumAvg + nRnd) / mTubo.nAvgCnt);

			if ( mTubo.nMinCnt == 0) mTubo.nMinCnt = 1;
			nRnd = mTubo.nMinCnt/2;
			mTubo.nAvgMinWall = (short) ((mTubo.lSumMin + nRnd) / mTubo.nMinCnt);

			if (m_nHomeAway != 0)  //going away
			{
				fMinWallX = (float) mTubo.nMinWallX / 12.0f;
				fMinAvgWallX = (float) mTubo.nMinAvgWallX / 12.0f;
			}
			else  //going home
			{
				fMinWallX = (float) (m_nAwayStopXloc - mTubo.nMinWallX + SiteDefault.nDefaultXOffset2) / 12.0f;
				fMinAvgWallX = (float) (m_nAwayStopXloc - mTubo.nMinAvgWallX + SiteDefault.nDefaultXOffset2) / 12.0f;
			}
			//work order,  pipe number, min, minx, avg, min avg, min avg x, max, ecc \n
			s.Format(_T("%7ld, %5d, %4.1f, %5d, %5d, %4.1f, %5d, %5d\r\n"),
            m_dwJointNum, mTubo.nMinWall, fMinWallX,
            mTubo.nAvgWall,  mTubo.nMinAvgWall, fMinAvgWallX, mTubo.nMaxWall, mTubo.nEcc);
			break;

    }  //end switch

    try
    {
        len = (DWORD) m_pDataCsvFile->SeekToEnd();
        m_pDataCsvFile->Write(s, s.GetLength());

        // dup the file so we can close it.  May not be necessary
        CFile *pDup = m_pDataFile->Duplicate();
        pDup->Close();
        delete pDup;
    }
    catch (CFileException* e)
    {
        e->ReportError();
        e->Delete();
        m_pDataCsvFile = NULL;  // No exitsing file
    }

}


void CInspect::OnNoClock() 
{
    // TODO: Add your control notification handler code here
    // At Amelia, allow for bad top of pipe photo cell
    // disable clock reading in instrument
    UpdateData(TRUE);   // Copy screen TO variables 
#if 0
    ConfigRec.UtRec.bClockFlag = (m_bNoClock ^ 1) & 1;
    SendMsg(SET_NO_CLOCK);  // Is TOP sensor good or bad?
#endif

}


void CInspect::GetEchoBits(ECHO_BITS *Eb)
{
    // Return bit packed words for xdcr activity.
    // Word 0-3 for 3 shoes, id gate bits and od gate bits
    memcpy ( (void *) Eb, (void *) &(CInspect::m_EchoBits), sizeof(ECHO_BITS));
    memset ( (void *)  &(CInspect::m_EchoBits), 0, sizeof(ECHO_BITS));

}


void CInspect::OnMemBn() 
{
    // TODO: Add your control notification handler code here
    // 12-11-00 debug memory consumption in printing
    MEMORYSTATUS  MemBuf;
    CString s;
    GlobalMemoryStatus( &MemBuf);

    int nPriT = GetThreadPriority(GetCurrentThread());
    int nPriC = GetPriorityClass(GetCurrentProcess());
    s.Format(_T("Free Memory = %ld, Pri = %d"), MemBuf.dwAvailPhys,
        nPriT+nPriC);
    MessageBox(s);
    
}


void CInspect::DelayedErase()
{
    // Delay to allow action to happen.  Callable from other 
    // routines and classes
    //::PostMessage(m_hWnd, WM_USER_INSPECT_ERASE,0,0);
}


void CInspect::EnterNopMode()
{
    // temporarily set instrument/udp to nop mode.
    // on exit, reset mode to previous active mode

    m_wOpModeTmp = ConfigRec.wOpMode;
    SendMsg(NOP_MODE);
}


void CInspect::ExitNopMode()
{
    if ( (m_wOpModeTmp < NOP_MODE) || (m_wOpModeTmp > RUN_MODE) )
        m_wOpModeTmp = RUN_MODE;
    SendMsg(m_wOpModeTmp);
}


int CInspect::GetTotalDefects()
{
    if (m_nTotalFlawCnt < 0) m_nTotalFlawCnt = 0;
    if (m_nTotalWallCnt < 0) m_nTotalWallCnt = 0;
    return (m_nTotalFlawCnt + m_nTotalWallCnt);
}


void CInspect::OnUpdateData()
{
    GetConfigRecValues();
    UpdateData(FALSE);  // Copy variables to screen
}


void CInspect::OnPrintFlw() 
{
    // TODO: Add your control notification handler code here
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnPrintFlw();
    if (m_nID != 0)
        CheckRadioButton(IDC_Print, IDC_PrntFlw, IDC_PrntFlw);

    m_bPrntFlw  = 1;
    m_bAutoPrint = 0;
}


void CInspect::OnPrint() 
{
    if ( (pCTscanDlg->m_pInspectDlg2) && (m_nID == 0) )
        pCTscanDlg->m_pInspectDlg2->OnPrint();
    if (m_nID != 0)
        CheckRadioButton(IDC_Print, IDC_PrntFlw, IDC_Print);

    m_bAutoPrint = 1;   
    m_bPrntFlw  = 0;
}


#if 0
void CInspect::OnPrntScrn() 
{
    // TODO: Add your control notification handler code here
    m_bPrint = 1;   
    
}
#endif


void CInspect::OnPaint() 
{
    CPaintDC dc(this); // device context for painting
    
    // TODO: Add your message handler code here
	SetTimer(REFRESH_TIMER, 50, NULL);
    //RefreshWindow();
    
    // Do not call CDialog::OnPaint() for painting messages
}


void CInspect::RefreshWindow()
{
    // DO NOT change the calling order!!
    InspMapErase();
    InspWallErase();
    InspLongErase();
    InspTranErase();
    InspOblq1Erase();
    InspOblq2Erase();
    InspOblq3Erase();
	InspLaminErase();
    DrawExistMap();
    DrawXTicks();
    DrawExistWall();
    DrawExistLong();
    DrawExistTran();
    DrawExistOblq1();
    DrawExistOblq2();
    DrawExistOblq3();
	DrawExistLamin();
}


void CInspect::EraseExistPts()
{
    int i;
    CPoint ptOd = (0,100);
    EXIST_MAP_RECT *pMapRect;
#if (SYSTEM_ID == RAW_WALL_SYS)
	CPoint ptOdOblq2 = (0,20);
#endif

    while (!m_pListExistMapRect.IsEmpty())
    {
        pMapRect = (EXIST_MAP_RECT *) m_pListExistMapRect.RemoveHead();
        delete pMapRect;
    }

    ptOd.x = 0;
    ptOd.y = 100;
    for (i=0; i<75*12; i++)
    {
        m_ptExistLong[i][0] = (0,0);
        m_ptExistLong[i][1] = ptOd;
        m_ptExistTran[i][0] = (0,0);
        m_ptExistTran[i][1] = ptOd;
        m_ptExistOblq1[i][0] = (0,0);
        m_ptExistOblq1[i][1] = ptOd;
        m_ptExistOblq2[i][0] = (0,0);
#if (SYSTEM_ID == RAW_WALL_SYS)
        m_ptExistOblq2[i][1] = ptOdOblq2;
#else
        m_ptExistOblq2[i][1] = ptOd;
#endif
        m_ptExistOblq3[i][0] = (0,0);
        m_ptExistOblq3[i][1] = ptOd;
        m_ptExistLamin[i][0] = (0,0);
        m_ptExistLamin[i][1] = ptOd;
        m_ptExistWall[i][0] = (0,0);
        m_ptExistWall[i][1] = (0,0);
    }

    m_nNumExistWall = 0;
}


/******************************************************************/

void CInspect::DrawExistLong()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    int i;

    CClientDC dc(&m_cbInspLong);    // get drawing context for  Long graph
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspLong.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());



    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    for (i=0; i<m_nScale; i++)
    {
        // Look at Long  OD
        if ( m_bOdCheck )
        {
            ptNewOd = m_ptExistLong[i][1];
            if (ptNewOd.y > 100)
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);           
                dc.LineTo(ptNewOd);
            }
        }

        // Look at Long  ID
        if ( m_bIdCheck )   
        {
            ptNewId = m_ptExistLong[i][0];
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
            }
//          m_ptLastLId = ptNewId;  // remember last point location
        }

    }   //  End for


    dc.SelectObject(penOld);
    DrawProgressLine(&dc, m_nLastProgressS1, 0, FALSE);
}


void CInspect::DrawExistTran()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    int i;

    CClientDC dc(&m_cbInspTran);    // get drawing context for  Long graph
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspTran.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());



    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    for (i=0; i<m_nScale; i++)
    {
        // Look at Tran  OD
        if ( m_bOdCheck )
        {
            ptNewOd = m_ptExistTran[i][1];
            if (ptNewOd.y > 100)
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);           
                dc.LineTo(ptNewOd);
            }
        }

        // Look at Tran  ID
        if ( m_bIdCheck )   
        {
            ptNewId = m_ptExistTran[i][0];
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
            }
//          m_ptLastLId = ptNewId;  // remember last point location
        }

    }   //  End for


    dc.SelectObject(penOld);

    DrawProgressLine(&dc, m_nLastProgressTran, 2, FALSE);
	m_bDrawProgressTranOnce = TRUE;
}


void CInspect::DrawExistOblq1()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    int i;

    CClientDC dc(&m_cbInspOblq1);   // get drawing context for  Long graph
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspOblq1.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());



    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    for (i=0; i<m_nScale; i++)
    {
        // Look at Long  OD
        if ( m_bOdCheck )
        {
            ptNewOd = m_ptExistOblq1[i][1];
            if (ptNewOd.y > 100)
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);           
                dc.LineTo(ptNewOd);
            }
        }


        // Look at Long  ID
        if ( m_bIdCheck )   
        {
            ptNewId = m_ptExistOblq1[i][0];
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
            }
//          m_ptLastLId = ptNewId;  // remember last point location
        }

    }   //  End for


    dc.SelectObject(penOld);

    DrawProgressLine(&dc, m_nLastProgressS2, 1, FALSE);
	m_bDrawProgressS2Once = TRUE;
}


void CInspect::DrawExistOblq2()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    int i;
	int nBias = 0;

    CClientDC dc(&m_cbInspOblq2);   // get drawing context for  Long graph
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspOblq2.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

#if (SYSTEM_ID == RAW_WALL_SYS)
	dc.SetWindowExt(m_nScale,-40);   // define size of window in logical units
	nBias = 20;
#else
    dc.SetWindowExt(m_nScale,-200);   // define size of window in logical units
	nBias = 100;
#endif
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());



    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    for (i=0; i<m_nScale; i++)
    {
        // Look at OD
        if ( m_bOdCheck )
        {
            ptNewOd = m_ptExistOblq2[i][1];
            if (ptNewOd.y > nBias)
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,nBias);           
                dc.LineTo(ptNewOd);
            }
        }

        // Look at ID
        if ( m_bIdCheck )   
        {
            ptNewId = m_ptExistOblq2[i][0];
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
            }
//          m_ptLastLId = ptNewId;  // remember last point location
        }

    }   //  End for


    dc.SelectObject(penOld);

    DrawProgressLine(&dc, m_nLastProgressObq2, 3, FALSE);
    m_bDrawProgressObq2Once = TRUE;
}


void CInspect::DrawExistOblq3()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    int i;

    CClientDC dc(&m_cbInspOblq3);   // get drawing context for  Long graph
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspOblq3.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());



    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    for (i=0; i<m_nScale; i++)
    {
        // Look at OD
        if ( m_bOdCheck )
        {
            ptNewOd = m_ptExistOblq3[i][1];
            if (ptNewOd.y > 100)
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);           
                dc.LineTo(ptNewOd);
            }
        }


        // Look at ID
        if ( m_bIdCheck )   
        {
            ptNewId = m_ptExistOblq3[i][0];
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
            }
//          m_ptLastLId = ptNewId;  // remember last point location
        }

    }   //  End for


    dc.SelectObject(penOld);

    DrawProgressLine(&dc, m_nLastProgressS1, 0, FALSE);
    //m_bDrawProgressS1Once = TRUE;
}


void CInspect::DrawExistLamin()
{
    CPoint ptNewOd, ptNewId;    // new  values for Sonoscope id/od
    CRect InspLongRect;
    CPen *penOld;
    CPen *penId, *penOd;
    int i;

    CClientDC dc(&m_cbInspLamin);   // get drawing context for  Long graph
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspLamin.GetClientRect(&InspLongRect);
    InspLongRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, InspLongRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    dc.SetWindowExt(m_nScale,-200); // define size of window in logical units
    // 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
    // Od biased by 100%, Id in bottom 100%

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspLongRect.Width(), InspLongRect.Height());



    penOd = &penBlue2;
    penId = &penRed2;

    penOld = dc.SelectObject(penOd);    // OD is blue


    for (i=0; i<m_nScale; i++)
    {
        // Look at OD
        if ( m_bOdCheck )
        {
            ptNewOd = m_ptExistLamin[i][1];
            if (ptNewOd.y > 100)
            {
                dc.SelectObject(penOd);
                dc.MoveTo(ptNewOd.x,100);           
                dc.LineTo(ptNewOd);
            }
        }


        // Look at ID
        if ( m_bIdCheck )   
        {
            ptNewId = m_ptExistLamin[i][0];
            if (ptNewId.y > 0)
            {
                dc.SelectObject(penId);
                dc.MoveTo(ptNewId.x,0);
                dc.LineTo(ptNewId);
            }
//          m_ptLastLId = ptNewId;  // remember last point location
        }

    }   //  End for


    dc.SelectObject(penOld);

    DrawProgressLine(&dc, m_nLastProgressS1, 0, FALSE);
    m_bDrawProgressS1Once = TRUE;
}


void CInspect::DrawExistWall()
{

    CPoint ptNewOd, ptNewId;    // new  values for amalog id/od
    CRect InspWallRect;
    CPen *penOld;
    CPen *penId, *penOd;
    short NomWall;      // Nominal wall in 1/1000th inch
    short WallRange;    // delta wall max-min in 1/1000ths
    int i;

    CClientDC dc(&m_cbInspWall);    // get drawing context for Wall
    //  Set up reference area for graphing

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbInspWall.GetClientRect(&InspWallRect);
    InspWallRect.NormalizeRect();

    // Move the coordinate origin to the center left edge
    dc.SetViewportOrg( 0, InspWallRect.Height()/2);

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);


    NomWall = (short) (1000.0f * ConfigRec.JobRec.Wall + 0.5f);
    WallRange = (short) (20.0f * ConfigRec.JobRec.Wall * 
                            (float) MAX_DELTA_WALL);

    dc.SetWindowExt(m_nScale,-WallRange);   // define size of window in logical units
    // 750  1 INCH  x increments,

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( InspWallRect.Width(), InspWallRect.Height());

    penOd = &penBlue1;
    penId = &penRed1;

    penOld = dc.SelectObject(penOd);    // OD is blue


	if (m_nNumExistWall > 900)
		m_nNumExistWall = 900;

    for (i=1; i<m_nNumExistWall; i++)
    {
        // Look at wall max
        if ( m_bOdCheck )
        {
            dc.SelectObject(penOd);

			if ( (m_ptExistWall[i-1][1].x>=0) && (m_ptExistWall[i][1].x>=0) )
			{
				dc.MoveTo(m_ptExistWall[i-1][1]);           
				dc.LineTo(m_ptExistWall[i][1]);
			}
        }


        // Look at wall min
        if ( m_bIdCheck )   
        {
            dc.SelectObject(penId);

			if ( (m_ptExistWall[i-1][0].x>=0) && (m_ptExistWall[i][0].x>=0) )
			{
				dc.MoveTo(m_ptExistWall[i-1][0]);
				dc.LineTo(m_ptExistWall[i][0]);
			}
        }
    }   //  End for

    if ( m_bOdCheck && (m_nNumExistWall>0) && (m_nNumExistWall<900) )
        m_ptLastWallMax = m_ptExistWall[m_nNumExistWall-1][1];

    if ( m_bIdCheck && (m_nNumExistWall>0) && (m_nNumExistWall<900) )
        m_ptLastWallMin = m_ptExistWall[m_nNumExistWall-1][0];

    dc.SelectObject(penOld);

    DrawProgressLine(&dc, m_nLastProgressS1, 0, TRUE);
}


void CInspect::DrawExistMap()
{
    if (m_pListExistMapRect.IsEmpty())
        return;

    EXIST_MAP_RECT *pMapRect;
    COLORREF clrID = RGB(255,0,0);
    COLORREF clrOD = RGB(0,0,255);
    COLORREF color;
    CRect MapRect;
    CClientDC dc(&m_cbMap); // get drawing context for map 
    int cy;

    // Get the client rectangle boundaries for the Image Map graph (Button)
    m_cbMap.GetClientRect(&MapRect);
    MapRect.NormalizeRect();

    // Move the coordinate origin to the lower left corner
    dc.SetViewportOrg( 0, MapRect.Height());

    // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    dc.SetMapMode(MM_ANISOTROPIC);

    // UT machines operate with N_SEG radial segements.  Scale for twice that many
    // and put Od indications in even seg's, Id indications in odd segs.

    dc.SetWindowExt(m_nScale,-2*N_SEG); // define size of window in logical units
    // 750  1 INCH  x increments, 30 radial locations on y axis

    // tell windows how big this box is physically in pixels
    dc.SetViewportExt( MapRect.Width(), MapRect.Height());

    POSITION rPosition = m_pListExistMapRect.GetHeadPosition();

    while (1)
    {
        pMapRect = (EXIST_MAP_RECT *) m_pListExistMapRect.GetNext(rPosition);

        if (pMapRect->bIdOd == 0)
            color = clrID;
        else
            color = clrOD;

        switch (pMapRect->nType)
        {
			case 0:
			case 1:
				dc.FillSolidRect( (int) pMapRect->x, (int) pMapRect->y, (m_nScale/100),1,color);
				break;
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
				if ( pMapRect->y == 2*(N_SEG - 1))
					cy = -3;
				else
					cy = 3;
				dc.FillSolidRect( (int) pMapRect->x, (int) pMapRect->y,3,cy, color);
				break;
			default:
				break;
        }  //end switch

        if (rPosition == NULL)
            break;
    }
}


void CInspect::DisableControls()
{
    GetDlgItem(IDC_RUN)->EnableWindow(FALSE);
    GetDlgItem(IDC_STOP)->EnableWindow(FALSE);
    GetDlgItem(IDC_PLAY)->EnableWindow(FALSE);
    GetDlgItem(IDC_RECORD)->EnableWindow(FALSE);
    GetDlgItem(IDC_Print)->EnableWindow(FALSE);
    GetDlgItem(IDC_PrntFlw)->EnableWindow(FALSE);
    GetDlgItem(IDC_PrntScrn)->EnableWindow(FALSE);
    GetDlgItem(IDC_NO_CLOCK)->EnableWindow(FALSE);
    GetDlgItem(IDC_MOTION)->EnableWindow(FALSE);
    GetDlgItem(IDC_TIME)->EnableWindow(FALSE);
    GetDlgItem(IDC_SCALE50)->EnableWindow(FALSE);
    GetDlgItem(IDC_SCALE75)->EnableWindow(FALSE);
    GetDlgItem(IDC_CK_METRIC)->EnableWindow(FALSE);
	GetDlgItem(IDC_CHECK_CALRUN)->EnableWindow(FALSE);
}


void CInspect::ShowRcvrStation(short xloc1, short xloc2)
{
    CString s1, s2;

    //TRACE("xloc1 = %d\n", xloc1);

    if (m_bRcvrStation1)
    {
        if ( ((m_nControlSel == INSPECT_RUN) || (m_nControlSel == INSPECT_RECORD)) && !m_bShowStation1 )
        {
            s1.Format(_T("S1:%4.1f"), (float) xloc1/12.0f);
            m_stStation1.SetWindowText(s1);
            m_bShowStation1 = TRUE;
            //TRACE("%s\n\n", s1);
        }
        else
            m_bShowStation1 = FALSE;
        m_bRcvrStation1 = FALSE;
        
    }
    else
    {
        //if (m_bShowStation1 == TRUE)
            m_stStation1.SetWindowText(_T(""));
        m_bShowStation1 = FALSE;
    }

    if (m_bRcvrStation2)
    {
        if ( ((m_nControlSel == INSPECT_RUN) || (m_nControlSel == INSPECT_RECORD)) && !m_bShowStation2 )
        {
            s2.Format(_T("S2:%4.1f"), (float) xloc2/12.0f);
            m_stStation2.SetWindowText(s2);
            m_bShowStation2 = TRUE;
        }
        else
            m_bShowStation2 = FALSE;
        m_bRcvrStation2 = FALSE;
        
    }
    else
    {
        //if (m_bShowStation2 == TRUE)
        m_stStation2.SetWindowText(_T(""));
        m_bShowStation2 = FALSE;
    }
}


void CInspect::UpdateDisplay()
{

    I_MSG_RUN   *pImsg01;
    CString s;
    DWORD len;
    short xloc1=0, xloc2=0;
    static WORD  Period;
    static int VelocityDt;

    // copy inspection data from g_pListUtData to plistUtdata
    I_MSG_RUN *pImsgRun;
    switch (m_nID)
    {
		case 0:  // first inspect window
			g_CriticalSection.Lock();
			while (!g_pTcpListUtData.IsEmpty() )
			{
				pImsgRun = (I_MSG_RUN *) g_pTcpListUtData.RemoveHead();
				m_plistUtData.AddTail((void *) pImsgRun);
				if ( pImsgRun->InspHdr.nStation == 0 )
				{
					m_bRcvrStation1 = TRUE;
					xloc1 = pImsgRun->InspHdr.xloc;
					if (pImsgRun->InspHdr.JointLength > 0)
						m_nJointLength = pImsgRun->InspHdr.JointLength;
				}
				else
				{
					m_bRcvrStation2 = TRUE;
					xloc2 = pImsgRun->InspHdr.xloc;
				}
				Period = pImsgRun->InspHdr.Period;
				VelocityDt = (int) pImsgRun->InspHdr.VelocityDt;
				m_nMotionBus = pImsgRun->InspHdr.status[2];
			}
			g_CriticalSection.Unlock();
			break;

		case 1:  // second inspect window
			g_CriticalSection2.Lock();
			while (!g_pTcpListUtData2.IsEmpty() )
			{
				pImsgRun = (I_MSG_RUN *) g_pTcpListUtData2.RemoveHead();
				m_plistUtData.AddTail((void *) pImsgRun);
				if ( pImsgRun->InspHdr.nStation == 0 )
				{
					m_bRcvrStation1 = TRUE;
					xloc1 = pImsgRun->InspHdr.xloc;
					if (pImsgRun->InspHdr.JointLength > 0)
						m_nJointLength = pImsgRun->InspHdr.JointLength;
				}	
				else
				{
					m_bRcvrStation2 = TRUE;
					xloc2 = pImsgRun->InspHdr.xloc;
				}
				Period = pImsgRun->InspHdr.Period;
				VelocityDt = (int) pImsgRun->InspHdr.VelocityDt;
				m_nMotionBus = pImsgRun->InspHdr.status[2];
			}
			g_CriticalSection2.Unlock();
			break;

		default:
			break;
    }  //end switch

    ShowRcvrStation(xloc1, xloc2);

#if FOR_TEST
    SetDlgItemInt(IDC_EDIT_LOSTIDATA, g_nLostIdataCnt, TRUE);
#endif

    if ( m_nDelayedErase)
    {   
		// allow redraws before erasing
        m_nDelayedErase--;
        if ( m_nDelayedErase == 0) DelayedErase();
    }

//    if ( m_bDrawTicks)
    {
        DrawXTicks();
        m_bDrawTicks = FALSE;
    }

    m_uTimerTick++;
    // Every 8th timer tick, capture the system time
    if ( (m_uTimerTick & 0x7 ) == 0)
    {
        time(&m_tTimeNow);
        if ( m_nControlSel != INSPECT_PLAY)
        {
            pCTscanDlg->UpdateTimeDate(&m_tTimeNow);
            pCTscanDlg->m_nRpm = Period;
            pCTscanDlg->m_nFpm = VelocityDt;
            if (m_nJointLength > 0)
                pCTscanDlg->m_nJointLength = m_nJointLength;
            pCTscanDlg->m_wLineStatus = m_nMotionBus;
            //m_nMotionBus = 0;
#ifdef MAKE_IT_CRASH
            pCTscanDlg->UpdateRpm();    // also displays linear speed, joint length and line status
#endif
#if 0
            if ( m_bHome) s = _T("Home");
            else s = _T("Away");
            GetDlgItem(IDC_HOME_EN)->SetWindowText(s);
#endif
        }
    }



    switch(m_nControlSel)
    {
		case INSPECT_STOP:
			// Empty list and return
			while (!m_plistUtData.IsEmpty())
            {
				pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();
				delete pImsg01;
            }
			return;

		case INSPECT_PLAY:
			// Should not be here if timer really stopped
			StopTimer();
			m_nControlSel = INSPECT_STOP;
			return;


		case INSPECT_RUN:
		case INSPECT_RECORD:
		default:
			if (m_plistUtData.IsEmpty() )
            {   
				// nothing to do here
				return;
            }
			break;
    }  //end switch

    // Find the 1st element of the queue.  Then draw each plot
    //  Complete one plot before moving to the next.
    if (m_plistUtData.IsEmpty() ) return ;

    DrawMap();
    if ( m_bWallCheck)  DrawWall();
    if ( m_bLongCheck)  DrawLong();
    if ( m_bTranCheck)  DrawTran();
    if ( m_bOblq1Check) DrawOblq1();
    if ( m_bOblq2Check) DrawOblq2();
    if ( m_bOblq3Check) DrawOblq3();


    // If recording, do it now
#if 1   
    if ( (m_nControlSel == INSPECT_RECORD) && 
         (m_pDataFile) )
    {
        try
        {
            len = (DWORD) m_pDataFile->SeekToEnd();
            while (!m_plistUtData.IsEmpty())
            {
                pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();
                if ( (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) == PIPE_PRESENT )
                    m_uNoPipeCount = 0;
                else m_uNoPipeCount++;
                // Dont record data when pipe is not there
                if (m_uNoPipeCount < 8)
                {
                    // Put the last OBSERVED time into the data record
                    pImsg01->InspHdr.time = m_tTimeNow;
                    m_pDataFile->Write(pImsg01, sizeof(I_MSG_RUN));
                }
            }

            // dup the file so we can close it.  May not be necessary
            CFile *pDup = m_pDataFile->Duplicate();
            pDup->Close();
            delete pDup;
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            m_pDataFile = NULL; // No exitsing file
            return;
        }

    }
#endif

    // Now that all samples in list have been drawn on all 
    // display areas, empty list.

    int nOnlyOnce = 0;
    while (!m_plistUtData.IsEmpty() )
    {
        pImsg01 = (I_MSG_RUN *)m_plistUtData.RemoveHead();
        if (nOnlyOnce == 0)
        {
            SetDlgItemInt (IDC_EDIT_JOINTNUM, pImsg01->InspHdr.JointNumber, FALSE);
            nOnlyOnce++;
        }
        delete pImsg01;
    }
}


void CInspect::CreateRecordFile(CString sFileName) 
{
    // TODO: Add your control notification handler code here
    //DWORD len;

    if (m_nControlSel != INSPECT_STOP)
    {
        m_nControlSel = m_nControlSelLast;
//        UpdateData(FALSE);
        return;
    }

    CheckRadioButton(IDC_STOP, IDC_RECORD, IDC_RECORD);

    InitWallStatistics();   // prep for Exxon statistics
    if (m_pDataFile) return;    // already recording
    m_pDataFile = pCTscanDlg->m_pInspectDlg1->m_pDataFile;
	m_pDataFileCD = pCTscanDlg->m_pInspectDlg1->m_pDataFileCD;

    int write_cnt = CONFIG_REC_SIZE;  //0x2000; // 8k space for config file
    // assume config file less than 8k always

    TCHAR szFilter[] = _T("Data Files(*.dat) | *.dat||");

    if ( 1)
    {   
		// file open dialog returned OK
        CString s, t;
        s = sFileName;

        write_cnt = -1;

        m_DataPathName = s;
        ShowDlgTitle();

        m_nControlSel = INSPECT_RECORD;
        m_nControlSelLast = m_nControlSel;
        SendMsg(RUN_MODE);
        if (m_nID == 0)
            m_pTcpThreadRxList->SendSlaveMsg(RUN_MODE, 0,0,0,0,0,0);

        // Open a csv file if wall statistics being generated
        if  ( !ConfigRec.JobRec.WallStatFlag) return;   //skip wall stats
		m_pDataCsvFile = pCTscanDlg->m_pInspectDlg1->m_pDataCsvFile;
    }   // file open dialog returned OK
}


void CInspect::OnBtnRefresh() 
{
    // TODO: Add your control notification handler code here
    RefreshWindow();
    DrawXTicks();

}


void CInspect::CopyFlawLists()
{
    FLAW_REC *pFlaw;
    FLAW_REC *pFlawCopy;

    m_nTotalFlawCntCopy = m_nTotalFlawCnt;
    m_nTotalWallCntCopy = m_nTotalWallCnt;

    POSITION rPosition = m_plistWallFlaw.GetHeadPosition();
    while ( rPosition != NULL )
    {
        pFlaw = (FLAW_REC *) m_plistWallFlaw.GetNext(rPosition);
        pFlawCopy = new FLAW_REC;
        memcpy ( (void *) pFlawCopy, (void *) pFlaw, sizeof(FLAW_REC) );
        m_plistWallFlawCopy.AddTail ( (void *) pFlawCopy );
    }

    rPosition = m_plistLongFlaw.GetHeadPosition();
    while ( rPosition != NULL )
    {
        pFlaw = (FLAW_REC *) m_plistLongFlaw.GetNext(rPosition);
        pFlawCopy = new FLAW_REC;
        memcpy ( (void *) pFlawCopy, (void *) pFlaw, sizeof(FLAW_REC) );
        m_plistLongFlawCopy.AddTail ( (void *) pFlawCopy );
    }

    rPosition = m_plistTranFlaw.GetHeadPosition();
    while ( rPosition != NULL )
    {
        pFlaw = (FLAW_REC *) m_plistTranFlaw.GetNext(rPosition);
        pFlawCopy = new FLAW_REC;
        memcpy ( (void *) pFlawCopy, (void *) pFlaw, sizeof(FLAW_REC) );
        m_plistTranFlawCopy.AddTail ( (void *) pFlawCopy );
    }

    rPosition = m_plistOblq1Flaw.GetHeadPosition();
    while ( rPosition != NULL )
    {
        pFlaw = (FLAW_REC *) m_plistOblq1Flaw.GetNext(rPosition);
        pFlawCopy = new FLAW_REC;
        memcpy ( (void *) pFlawCopy, (void *) pFlaw, sizeof(FLAW_REC) );
        m_plistOblq1FlawCopy.AddTail ( (void *) pFlawCopy );
    }

    rPosition = m_plistOblq2Flaw.GetHeadPosition();
    while ( rPosition != NULL )
    {
        pFlaw = (FLAW_REC *) m_plistOblq2Flaw.GetNext(rPosition);
        pFlawCopy = new FLAW_REC;
        memcpy ( (void *) pFlawCopy, (void *) pFlaw, sizeof(FLAW_REC) );
        m_plistOblq2FlawCopy.AddTail ( (void *) pFlawCopy );
    }

    rPosition = m_plistOblq3Flaw.GetHeadPosition();
    while ( rPosition != NULL )
    {
        pFlaw = (FLAW_REC *) m_plistOblq3Flaw.GetNext(rPosition);
        pFlawCopy = new FLAW_REC;
        memcpy ( (void *) pFlawCopy, (void *) pFlaw, sizeof(FLAW_REC) );
        m_plistOblq3FlawCopy.AddTail ( (void *) pFlawCopy );
    }
}


void CInspect::RestoreFlawLists()
{
    FLAW_REC *pFlaw;

    m_nTotalFlawCnt = m_nTotalFlawCntCopy;
    m_nTotalWallCnt = m_nTotalWallCntCopy;

    while ( !m_plistWallFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistWallFlawCopy.RemoveHead();
        m_plistWallFlaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistLongFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistLongFlawCopy.RemoveHead();
        m_plistLongFlaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistTranFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistTranFlawCopy.RemoveHead();
        m_plistTranFlaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistOblq1FlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistOblq1FlawCopy.RemoveHead();
        m_plistOblq1Flaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistOblq2FlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistOblq2FlawCopy.RemoveHead();
        m_plistOblq2Flaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistOblq3FlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistOblq3FlawCopy.RemoveHead();
        m_plistOblq3Flaw.AddTail ( (void *) pFlaw );
    }
}


void  CInspect::MoveReportWindow(int x, int y)
{
    if (m_pFlawReport)
        m_pFlawReport->SetWindowPos (NULL, x, y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
}


void DashLine(CDC *pdc,int hold)
{
	for (int i=3; i<600; )
	{
		pdc->LineTo(i,hold);
		pdc->MoveTo(i+3,hold);
		i += 6;
	}
}


void CInspect::DrawExistWall1()
{

        CRect InspWallRect;

        CClientDC dc(&m_cbInspWall);    // get drawing context for Wall
        //      Set up reference area for graphing

        // Get the client rectangle boundaries for the Image Map graph (Button)
        m_cbInspWall.GetClientRect(&InspWallRect);
        InspWallRect.NormalizeRect();

        PlotExistingWall(&dc, InspWallRect );
}

void CInspect::PlotExistingWall(CDC *pdc, CRect Rect )
{
        CPoint ptNewOd, ptNewId;        // new  values for amalog id/od
//        CPen *penOld;
//        CPen *penId, *penOd;
        short NomWall;          // Nominal wall in 1/1000th inch
        short WallRange,cy;        // delta wall max-min in 1/1000ths
		int i;
		CFont wFont;
        // Move the coordinate origin to the center left edge
        // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
        //pdc->SetViewportOrg( 0, (int)(pageHeight*.371) /*1188 */);
		//PlotMapScales(pdc, InspWallRect );

        pdc->SetMapMode(MM_ANISOTROPIC);
	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height()/2);
            pdc->LineTo(Rect.Width(),Rect.Height()/2);
            pdc->LineTo(Rect.Width(),-Rect.Height()/2);
            pdc->LineTo(00,-Rect.Height()/2);
            pdc->LineTo(0,00);
            pdc->LineTo(Rect.Width(),0);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
		pdc->TextOut(10,130,_T("WALL"));
		pdc->SelectObject(&xFont);

        NomWall = (short) (1000.0f * ConfigRec.JobRec.Wall + 0.5f);
        cy=WallRange = (short) (20.0f * ConfigRec.JobRec.Wall * 
                                                        (float) MAX_DELTA_WALL);

        pdc->SetWindowExt(m_nScale,-WallRange); // define size of window in logical units
        // 750  1 INCH  x increments,

        // tell windows how big this box is physically in pixels
        pdc->SetViewportExt( Rect.Width(), Rect.Height());
//	pdc->SetWindowExt(m_nScale,-cy);	// define size of window in logical units
//	pdc->SetWindowExt(100, -100);	// define size of window in logical units
	// 750  1 INCH  x increments, 30 radial locations on y axis
		//pdc->SetViewportOrg( 0,wallorg/2 /*1330 */);	//wall

	// tell windows how big this box is physically in pixels
//	pdc->SetViewportExt( MapRect.Width(), MapRect.Height());
/*	penOld = pdc->SelectObject(&penBlack2);
		//pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&hFont);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,cy/2);
            pdc->LineTo(m_nScale,cy/2);
            pdc->LineTo(m_nScale,-cy/2);
			pdc->LineTo( 0,-cy/2);
            pdc->LineTo(0,00);
            pdc->LineTo(m_nScale,0);
	    wFont.CreateFont(-23,0,0,0,FW_NORMAL,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));
*/
		wFont.CreatePointFont(55,_T("Arial"), pdc);
		pdc->SelectObject(&wFont);

//		pdc->SelectObject(&xFont);

		pdc->SelectObject(penIdt);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdWall[0]);
		pdc->TextOut(580,ConfigRec.UtRec.TholdWall[0]*NomWall/100+22,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdWall[0]*NomWall/100);
		DashLine(pdc,ConfigRec.UtRec.TholdWall[0]*NomWall/100);
		pdc->SelectObject(penOdt);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdWall[1]);
		pdc->TextOut(580,ConfigRec.UtRec.TholdWall[1]*NomWall/100+22,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdWall[1]*NomWall/100);
		DashLine(pdc,ConfigRec.UtRec.TholdWall[1]*NomWall/100);

        for (i=1; i<m_nNumExistWall; i++)
        {
                // Look at wall max
                if ( m_bOdCheck )
                {
                        pdc->SelectObject(penOdt);
						if ( (m_ptExistWall[i-1][1].x>=0) && (m_ptExistWall[i][1].x>=0) )
						{
							pdc->MoveTo(m_ptExistWall[i-1][1]);                     
							pdc->LineTo(m_ptExistWall[i][1]);
						}
                }


                // Look at wall min
                if ( m_bIdCheck )       
                {
                        pdc->SelectObject(penIdt);
						if ( (m_ptExistWall[i-1][0].x>=0) && (m_ptExistWall[i][0].x>=0) )
						{
							pdc->MoveTo(m_ptExistWall[i-1][0]);
							pdc->LineTo(m_ptExistWall[i][0]);
						}
                }

        }   //  End for

        if ( m_bOdCheck && (m_nNumExistWall>0) && (m_nNumExistWall<900) )
                m_ptLastWallMax = m_ptExistWall[m_nNumExistWall-1][1];

        if ( m_bIdCheck && (m_nNumExistWall>0) && (m_nNumExistWall<900) )
                m_ptLastWallMin = m_ptExistWall[m_nNumExistWall-1][0];

//        pdc->SelectObject(penOld);
		wFont.DeleteObject();
        //DrawProgressLine((CClientDC*)pdc, m_nLastProgressS1, 0, TRUE);
}


void CInspect::SetPdfFileName_Run()
{
	HKEY hKey;
	CString sPdfName = pCTscanDlg->GetDataWO_Folder();		//"C:\\PhasedArray\\Report\\regpdf5.pdf";
	CString sJntNum, sWO;
	sJntNum.Format(_T("_%d"), m_dwJointNum);
	sWO = ConfigRec.JobRec.WO;
	if  ((sWO == _T(".\\")) || (sWO.GetLength() == 0 )) sWO = _T("UNK");
	sPdfName += sWO + sJntNum;
#if 0
	if ( strlen(ConfigRec.JobRec.WO) )
		sPdfName.Format(_T("C:\\PhasedArray\\Report\\%s\\%s_%d.pdf", ConfigRec.JobRec.WO, ConfigRec.JobRec.WO, m_dwJointNum);
	else
		sPdfName.Format(_T("C:\\PhasedArray\\Report\\Unknown\\Unknown_%d.pdf", m_dwJointNum);
#endif

	if ( ::RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Acro Software Inc\\CPW"), 0, KEY_SET_VALUE, &hKey) != ERROR_SUCCESS )
		AfxMessageBox(_T("Failed opening Registry key"));
	else if ( ::RegSetValueEx( hKey, _T("Filename"), 0, REG_SZ, (BYTE *) ((LPCTSTR) sPdfName), sPdfName.GetLength() ) != ERROR_SUCCESS)
		AfxMessageBox(_T("Failed setting Registry value"));
	::RegCloseKey(hKey);
}


#define LABELOFFSET	10

void CInspect::OnINSPreport() 
{
	SetPdfFileName_Run();

#if ( (SYSTEM_ID == RAW_WALL_SYS) || (SYSTEM_SUB_ID == BESSEMER_SYS) )
	if (m_nHomeAway == 0)
		ReverseReport((short) m_nAwayStopXloc, (short) SiteDefault.nDefaultXOffset2);
#endif


	// TODO: Add your control notification handler code here
	CDC dc,*pDC;
        CRect DrawRect(0,0,0,0);
        CRect CalRect(0,0,1000,200);  // where to draw the graph
        CRect MapRect(0,0,1000,400);  
        CPrintDialog dlg(FALSE);
        CTime   theTime = CTime::GetCurrentTime();
        CFont oFont,*pFont;
        LOGFONT lfFont;
        CPoint  returnLocation;
        CSize size;
        CPen  pen(PS_SOLID, 1, RGB(0,0,0));  // BLACK
	CClientDC dcScreen(NULL);		// context of the whole screen
//        int pageWidth,pageHeight;
        int nHeight,RowHeight_h;
        int temp;
        int channel = gChannel;
        int Xoffset = 100;
        int Yoffset = 20;
		TEXTMETRIC tm;					// struct which hold characteristics of screen
        BOOL NewPage = FALSE;
	int cxChar, cyChar;				// char size in pixels
	CPrintDialog dlgp(FALSE);
	dlgp.GetDefaults();		//dlg.GetPrinterDC();
	dc.Attach(dlgp.GetPrinterDC());
	pDC = &dc;

	if ( *pDC == NULL )
	{
		AfxMessageBox(_T("No Default Printer Available, Please Setup a Default Printer."));	
			return;  // no printer or print cancelled
	}
        DOCINFO di;   // setup DOCINFO structure
        ::ZeroMemory(&di, sizeof(DOCINFO));
        di.cbSize = sizeof(DOCINFO);
        di.lpszDocName = _T("Flaw Map");  // need date & wo info here ????
		pageWidth = dc.GetDeviceCaps(HORZRES);
        pageHeight = dc.GetDeviceCaps(VERTRES);
		int color = dc.GetDeviceCaps(NUMCOLORS);
		    penOdp = &penBlue2;
			penIdp = &penRed2;
		if (color > 2) 
		{
		    penOdt = &penBlue2;
			penIdt = &penRed2;
		} else 
		{
		    penOdt= &penBlack2;
			penIdt=&penBlack2;
		    penOdp = &penBlack2;
			penIdp = &penBlack2;

		}


		nHeight = -((pDC->GetDeviceCaps(LOGPIXELSY))/72);
/*	    tFont.CreateFont(nHeight*4,0,0,0,FW_NORMAL,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));
*/        
 	    hFont.CreateFont(-24,0,0,0,FW_BOLD,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));

 	    h1Font.CreateFont(-60,0,0,0,FW_BOLD,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));
	    xFont.CreateFont(-16,0,0,0,FW_NORMAL,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));

/*	    hFont.CreateFont(-40*3200/pageHeight,0,0,0,FW_NORMAL,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));
//        hFont.CreatePointFont(120,"Arial", pDC);
/*        oFont.CreatePointFont(30,"Arial", pDC);
*/  
//       xFont.CreatePointFont(80,"Arial", pDC);
		CopyFlawLists();
		pageWidth = dc.GetDeviceCaps(HORZRES);
        pageHeight = dc.GetDeviceCaps(VERTRES);
//        pDC->SelectObject(&hFont);
        pFont = pDC->GetCurrentFont();
        pFont->GetLogFont( &lfFont );
        RowHeight_h = (int)(1.1 * abs(lfFont.lfHeight));
        CPoint print_origin(Xoffset,Yoffset);
        BOOL bContinue = TRUE;
	pDC->GetTextMetrics (&tm);	// put after setting viewport/window ext
	//xChar = tm.tmAveCharWidth;
	cyChar = 3*(tm.tmHeight + tm.tmExternalLeading)/4;
//	yChar = tm.tmHeight;
	cxChar = 3*tm.tmAveCharWidth/2;
	print_origin.x = pageWidth/20;
	print_origin.y = pageHeight/20 ;
	pCTscanDlg->m_uJntNum = m_dwJointNum;
    if ( pDC->StartDoc(&di) > 0 )
	{ 
/*            for ( int page=2; page < 3;
                  //bContinue && ( channel < MAX_CHANNEL); 
                  page++ )
*/
	   pDC->StartPage();
		pDC->SetMapMode(MM_TEXT );
		pDC->SetTextAlign(TA_LEFT);
	   ss.Format(_T("%s Inspection Report Page 1"), SYSTEM_NAME);
	   temp = CViewcfg::PrintHeading(pDC, print_origin, pageWidth, nHeight, 
						ss, "");
       print_origin.y = temp;

	   AddWallStatsToDib(pDC, cxChar, cyChar, print_origin.y, 4);

/*		pDC->SelectObject(&pen);
//        tFont.CreatePointFont(80,"Arial", pDC);
		pDC->SelectObject(&hFont);
		//pDC->TextOut(10,350,"AAA");
		//pDC->TextOut(10,(int)(pageHeight*.18),"MAP");
*/
        CalRect.SetRect(0,0, pageWidth*9/10, (int)(-pageHeight/13.2) );
        CalRect.NormalizeRect();
        MapRect.SetRect(0,0, pageWidth*9/10, (int)(-pageHeight/9.9));
        MapRect.NormalizeRect();

//         for ( int index=0; index < 4; index ++)
//                    pDC->SetMapMode(MM_LOMETRIC);
                    // Move the coordinate origin to after the heading or previous graph
                    //returnLocation = pDC->SetViewportOrg(0,0 );
                    // Set mapping mode to AnIsotropic, deal in logical units 
//		pDC->SetMapMode(MM_TEXT);
        pDC->SetMapMode(MM_ANISOTROPIC);
        pDC->SetWindowExt(m_nScale,100);   // define size of window in logical units
        // max amp (x) is 50ft*12 inches, 100 units high
        // tell windows how big this box is physically in pixels
		pDC->SelectObject(&pen);
		maporg=(int)(pageHeight*.32);
		//mapoff=(maporg+880)*4/nHeight+440;
		pDC->SelectObject(&xFont);
		pDC->SetViewportOrg( print_origin.x,maporg+(int)(pageHeight*.004) /*980*/+PRINTERFACTOR/*MapRect.Height()*/);
		PlotMapScales(pDC, MapRect );
			// 12/01/00 Put clock ticks on far right side

		pDC->SelectObject(&xFont);
		pDC->SetViewportOrg( print_origin.x,maporg);
			PlotExistingMap(pDC, MapRect ); 

		wallorg	= (int)(pageHeight*.38);
		//walloff = wallorg *4/nHeight +450;	
		pDC->SetViewportOrg( print_origin.x,wallorg+(int)(pageHeight*.041)  /*1330 */);	//wall
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,wallorg  /*1330 */);	//wall
			PlotExistingWall(pDC, CalRect );

		longorg	= (int)(pageHeight*.51);
		pDC->SetViewportOrg( print_origin.x,longorg+(int)(pageHeight*.003)  /*1330 */);	//long
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,longorg);
            PlotExistingLong(pDC, CalRect );

		tranorg	= (int)(pageHeight*.60);
		pDC->SetViewportOrg( print_origin.x,tranorg+(int)(pageHeight*.003)  /*1330 */);	//tran
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,tranorg);
            PlotExistingTran(pDC, CalRect );

		q1org	= (int)(pageHeight*.69);
		pDC->SetViewportOrg( print_origin.x,q1org+(int)(pageHeight*.003)  /*1330 */);	//q1
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,q1org);
            PlotExistingObq1(pDC, CalRect );

		q2org	= (int)(pageHeight*.78);
		pDC->SetViewportOrg( print_origin.x,q2org+(int)(pageHeight*.003)  /*1330 */);	//q2
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,q2org);
            PlotExistingObq2(pDC, CalRect );

		q3org	= (int)(pageHeight*.87);
		pDC->SetViewportOrg( print_origin.x,q3org+(int)(pageHeight*.003)  /*1330 */);	//q3
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,q3org);
            PlotExistingObq3(pDC, CalRect );

		lamorg	= (int)(pageHeight*.96);
		pDC->SetViewportOrg( print_origin.x,lamorg+(int)(pageHeight*.003)  /*1330 */);	//q3
		PlotMapScales(pDC, CalRect );
		pDC->SetViewportOrg( print_origin.x,lamorg);
            PlotExistingLamin(pDC, CalRect );

		pDC->SelectObject(&hFont);
		returnLocation = pDC->SetViewportOrg(0,0 );
		//pDC->TextOut(10,-495,"MAP");//500
/*		pDC->TextOut(10,-maporg+(int)((pageHeight*(-8/nHeight)-1444)*.2825),"MAP");//500
		pDC->TextOut(10,-wallorg+(int)((pageHeight*(-8/nHeight)-1444)*.3125),"WALL");//870
		pDC->TextOut(10,-longorg+(int)((pageHeight*(-8/nHeight)-1444)*.452),"LONG");//1165
		pDC->TextOut(10,-tranorg+(int)((pageHeight*(-8/nHeight)-1444)*.5322),"TRAN");//1340
		pDC->TextOut(10,-q1org+(int)((pageHeight*(-8/nHeight)-1444)*.595),"OBQ1");//1700
		pDC->TextOut(10,-q2org+(int)((pageHeight*(-8/nHeight)-1444)*.675),"OBQ2");//1952
		pDC->TextOut(10,-q3org+(int)((pageHeight*(-8/nHeight)-1444)*.75),"LAMN");//2250
*/
          pDC->EndPage();

//            char nDefects = GetTotalDefects();
            //pDC->SelectObject(&xFont);
            pDC->SelectObject(&pen);

			//nDefects -= nDefectsPrinted;
//			if (nDefects < 0) nDefects = 0;
			int nPageCnt = 2;	// already printed inspect screen
						char nDefectsPrinted = AddFlawTextToDib(pDC, Xoffset,
                    Yoffset, nHeight, 0,nPageCnt);	// 55 rows

	}
		pDC->EndDoc();
		dc.Detach();
		xFont.DeleteObject();
		hFont.DeleteObject();
		h1Font.DeleteObject();
		tFont.DeleteObject();
		RestoreFlawLists();
}	

void CInspect::PlotExistingMap(CDC *pdc, CRect Rect)
{
	EXIST_MAP_RECT *pMapRect;

	COLORREF clrID = RGB(255,0,0);
	COLORREF clrOD = RGB(0,0,255);
	COLORREF color;
	CString s;
	CFont mFont,wFont;

//	CRect MapRect;
//	CClientDC dc(&m_cbMap);	// get drawing context for map 
	int cy;

	// Get the client rectangle boundaries for the Image Map graph (Button)
/*	m_cbMap.GetClientRect(&MapRect);
*/	
	Rect.NormalizeRect();

	// Move the coordinate origin to the lower left corner
//	pdc->SetViewportOrg( 0, MapRect.Height());
       //pdc->SetViewportOrg( 0,(int)(pageHeight*.305)/*976*/ +PRINTERFACTOR );

        // Set mapping mode to AnIsotropic, deal in logical units rather than pixels
    pdc->SetMapMode(MM_ANISOTROPIC);
	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height());
            pdc->LineTo(Rect.Width(),Rect.Height());
            pdc->LineTo(Rect.Width(),00);
            pdc->LineTo(0,00);
//			pdc->MoveTo( 0,Rect.Height()/2);
//            pdc->LineTo(Rect.Width(),Rect.Height()/2);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
		pdc->TextOut(10,230,_T("MAP"));
		pdc->SelectObject(&xFont);

	// UT machines operate with N_SEG radial segements.  Scale for twice that many
	// and put Od indications in even seg's, Id indications in odd segs.
	// tell windows how big this box is physically in pixels
	    mFont.CreateFont(-6,0,0,0,FW_BOLD,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));
//	penOld = pdc->SelectObject(&penBlack1);
		//
//		mFont.CreatePointFont(80,"Arial", pdc);
	    wFont.CreateFont(-6,0,0,0,FW_NORMAL,0,0,0,
			DEFAULT_CHARSET,OUT_CHARACTER_PRECIS,CLIP_CHARACTER_PRECIS,
			DEFAULT_QUALITY,DEFAULT_PITCH | FF_DONTCARE,  _T("Arial"));
/*		pdc->SelectObject(&wFont);
		pdc->SetViewportOrg( 0,maporg);
		pdc->TextOut(10,350,"MAP");
*/
	cy=2*N_SEG;
	pdc->SetWindowExt(m_nScale,-cy);	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
		pdc->SelectObject(&wFont);
		pdc->SelectObject(&penBlack1);
//	pdc->SelectObject(penOld);
	for (char i = 5; i < cy; i += 5)
		{
		pdc->MoveTo(m_nScale - 4, i);
		pdc->LineTo(m_nScale, i);
		if ( (i % 15) == 0)
			{
			s.Format(_T("%d"), i/5);
			pdc->TextOut(m_nScale -10/*(xChar)*/, i/1+3,s);
			}
		}
	if (m_pListExistMapRect.IsEmpty())
		return;

	POSITION rPosition = m_pListExistMapRect.GetHeadPosition();

	while (1)
	{
		pMapRect = (EXIST_MAP_RECT *) m_pListExistMapRect.GetNext(rPosition);

		if (pMapRect->bIdOd == 0)
			color = clrID;
		else
			color = clrOD;

		switch (pMapRect->nType)
		{
		case 0:
		case 1:
			pdc->FillSolidRect( (int) pMapRect->x, (int) pMapRect->y, (m_nScale/100),1,color);
			break;
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			if ( pMapRect->y == 2*(N_SEG - 1))
				cy = -3;
			else
				cy = 3;
			pdc->FillSolidRect( (int) pMapRect->x, (int) pMapRect->y,3,cy, color);
			break;
		default:
			break;
		}

		if (rPosition == NULL)
			break;
	}
	mFont.DeleteObject();
	wFont.DeleteObject();
}

void CInspect::PlotMapScales(CDC *pdc, CRect MapRect)

{
		// x axis ticks drawn on bottom of image map
//	CRect MapRect;
	CPen *penOld;
	CPen penBlue(PS_SOLID,2, RGB(0,0,255));
//	TEXTMETRIC tm;

//	CClientDC dc(&m_cbMap);	// get drawing context for 

	int i,m;
//	int xChar;
//	int yChar;
	CString s;
	float fmeter;
	CFont	mFont;


//	m_cbMap.GetClientRect(&MapRect);
	MapRect.NormalizeRect();

	// Move the coordinate origin to the lower left corner
//	pdc->SetViewportOrg( 0, (int)(pageHeight*.32)/*947*/+PRINTERFACTOR/*MapRect.Height()*/);
	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);
//	pdc->SetMapMode(MM_TEXT);
 
	pdc->SetWindowExt(m_nScale,-8/3*N_SEG-28);	// define size of window in logical units
	// 750 in 1 INCH x increments, 120 percent y scale
	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( MapRect.Width(), MapRect.Height());
/*
	pdc->GetTextMetrics (&tm);	// put after setting viewport/window ext
	//xChar = tm.tmAveCharWidth;
	yChar = 3*(tm.tmHeight + tm.tmExternalLeading)/4;
//	yChar = tm.tmHeight;
	xChar = 3*tm.tmAveCharWidth/2;
*/
	penOld = pdc->SelectObject(&penBlack1);
	mFont.CreatePointFont(80,_T("Arial"), pdc);
//	pdc->SelectObject(&xFont);
	pdc->SelectObject(&mFont);

	switch (m_bMetric & 1)
		{
	case 0:
		// English
		// draw ticks and number every 10 ft., ie., 10, 20, 30 etc
		for ( i = 120; i < m_nScale; i += 120)
			{
			pdc->MoveTo(i,0);
			pdc->LineTo(i,7);
			pdc->SetBkMode(TRANSPARENT);
			s.Format(_T("%2d"), i/12);
			pdc->TextOut( i+2, 0/*yChar*/ ,s);
			}
		// draw 2 ft marks
		for ( i = 24; i < m_nScale; i += 24)
			{
			pdc->MoveTo(i,0);
			pdc->LineTo(i,3);
			}
		break;

	case 1:
		// Metric
		// draw ticks and number every 5 meters ... still 50 or 75 ft scale
		fmeter = 5.0f;
		m = 5;
		i = (int) (fmeter * 39.37f  + 0.5f);
		while ( i < m_nScale)
			{
			pdc->MoveTo(i,0);
			pdc->LineTo(i,7);
			s.Format(_T("%2d"), m);
			if ( i < (m_nScale - 30) )
				{
				pdc->SetBkMode(TRANSPARENT);
				pdc->TextOut( i+2, 0,s);
				}
			fmeter += 5.0f;
			m += 5;
			i = (int) (fmeter * 39.37f  + 0.5f);
			}

		// draw 1 meter marks
		fmeter = 1.0f;
		m = 1;
		i = (int) (fmeter * 39.37f  + 0.5f);
		while ( i < m_nScale)
			{
			pdc->MoveTo(i,0);
			pdc->LineTo(i,3);
			fmeter += 1.0f;
			m += 1;
			i = (int) (fmeter * 39.37f  + 0.5f);
			}
		break;

	default:
		break;
		}
/*
	// 12/01/00 Put clock ticks on far right side
	for ( i = 10; i < 120; i += 10)
		{
		pdc->MoveTo(m_nScale - 4, i);
		pdc->LineTo(m_nScale, i);
		if ( (i % 30) == 0)
			{
			s.Format(_T("%d"), i/10);
			pdc->TextOut(m_nScale -(xChar+4), i-10,s);
			}
		}
*/

	pdc->SelectObject(penOld);

}

void CInspect::PlotExistingLong(CDC *pdc, CRect Rect)
{
	CPoint ptNewOd, ptNewId;	// new  values for Sonoscope id/od
//	CRect InspLongRect;
	CPen *penOld;
	CPen *penId, *penOd;
	int i;
	Rect.NormalizeRect();
        //pdc->SetViewportOrg( 0, (int)(pageHeight*.55) /*1760 */);
		//PlotMapScales(pdc, Rect );

// Move the coordinate origin to the lower left corner

	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);

	// tell windows how big this box is physically in pixels
	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height());
            pdc->LineTo(Rect.Width(),Rect.Height());
            pdc->LineTo(Rect.Width(),00);
            pdc->LineTo(0,00);
			pdc->MoveTo( 0,Rect.Height()/2);
            pdc->LineTo(Rect.Width(),Rect.Height()/2);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
		//pdc->TextOut(10,900,"MAP");
		//pdc->TextOut(10,500,"WALL");
		pdc->TextOut(10,230,_T("LONG"));
		pdc->SelectObject(&xFont);

        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[0][1]);
		pdc->SelectObject(penOdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[0][1]+118,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[0][1]+100);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[0][1]+100);
		//pdc->LineTo(600,ConfigRec.UtRec.TholdLong[0][0]+100);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[0][0]);
		pdc->SelectObject(penIdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[0][0]+18,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[0][0]);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[0][0]);

	penOd = &penBlue2;
	penId = &penRed2;

//	penOld = pdc->SelectObject(penOd);	// OD is blue


	for (i=0; i<m_nScale; i++)
	{
		// Look at Long  OD
		if ( m_bOdCheck )
		{
			ptNewOd = m_ptExistLong[i][1];
			if (ptNewOd.y > 100)
			{
				pdc->SelectObject(penOdp);
				pdc->MoveTo(ptNewOd.x,100);			
				pdc->LineTo(ptNewOd);
			}
		}


		// Look at Long  ID
		if ( m_bIdCheck )	
		{
			ptNewId = m_ptExistLong[i][0];
			if (ptNewId.y > 0)
			{
				pdc->SelectObject(penIdp);
				pdc->MoveTo(ptNewId.x,0);
				pdc->LineTo(ptNewId);
			}
//			m_ptLastLId = ptNewId;	// remember last point location
		}

	}   //  End for


	pdc->SelectObject(penOld);

//	DrawProgressLine(&dc, m_nLastProgressS1, 0, FALSE);
}
void CInspect::PlotExistingTran(CDC *pdc, CRect Rect)
{
	CPoint ptNewOd, ptNewId;	// new  values for Sonoscope id/od
//	CRect InspLongRect;
	CPen *penOld;
	CPen *penId, *penOd;
	int i;
	Rect.NormalizeRect();
//        pdc->SetViewportOrg( 0, (int)(pageHeight*.6656) /*2130 */);
//		PlotMapScales(pdc, Rect );

// Move the coordinate origin to the lower left corner
//	pdc->SetViewportOrg( 0,(int) (pageHeight*.639)/*2045*/+PRINTERFACTOR);
//	PlotMapScales(pdc, Rect );
//	pdc->SetViewportOrg( 0, (int)(pageHeight*.635)/*2032*/+PRINTERFACTOR);

	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);

	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height());
            pdc->LineTo(Rect.Width(),Rect.Height());
            pdc->LineTo(Rect.Width(),00);
            pdc->LineTo(0,00);
			pdc->MoveTo( 0,Rect.Height()/2);
            pdc->LineTo(Rect.Width(),Rect.Height()/2);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
		pdc->TextOut(10,230,_T("TRAN"));
		pdc->SelectObject(&xFont);

        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[1][1]);
		pdc->SelectObject(penOdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[1][1]+118,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[1][1]+100);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[1][1]+100);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[1][0]);
		pdc->SelectObject(penIdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[1][0]+18,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[1][0]);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[1][0]);

	penOd = &penBlue2;
	penId = &penRed2;

	penOld = pdc->SelectObject(penOd);	// OD is blue


	for (i=0; i<m_nScale; i++)
	{
		// Look at Long  OD
		if ( m_bOdCheck )
		{
			ptNewOd = m_ptExistTran[i][1];
			if (ptNewOd.y > 100)
			{
				pdc->SelectObject(penOdp);
				pdc->MoveTo(ptNewOd.x,100);			
				pdc->LineTo(ptNewOd);
			}
		}


		// Look at Long  ID
		if ( m_bIdCheck )	
		{
			ptNewId = m_ptExistTran[i][0];
			if (ptNewId.y > 0)
			{
				pdc->SelectObject(penIdp);
				pdc->MoveTo(ptNewId.x,0);
				pdc->LineTo(ptNewId);
			}
//			m_ptLastLId = ptNewId;	// remember last point location
		}

	}   //  End for


//	pdc->SelectObject(penOld);

//	DrawProgressLine(&dc, m_nLastProgressS1, 0, FALSE);
}


void CInspect::PlotExistingObq1(CDC *pdc, CRect Rect)
{
	CPoint ptNewOd, ptNewId;	// new  values for Sonoscope id/od
//	CRect InspLongRect;
	CPen *penOld;
	CPen *penId, *penOd;
	int i;
	Rect.NormalizeRect();
//        pdc->SetViewportOrg( 0, (int)(pageHeight*.7813) /*2500 */);
//		PlotMapScales(pdc, Rect );

// Move the coordinate origin to the lower left corner
//	pdc->SetViewportOrg( 0,(int) (pageHeight*.752)/*2408*/+PRINTERFACTOR);
	//PlotMapScales(pdc, Rect );
//	pdc->SetViewportOrg( 0,(int) (pageHeight*.7482)/*2395*/+PRINTERFACTOR);

	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);

	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height());
            pdc->LineTo(Rect.Width(),Rect.Height());
            pdc->LineTo(Rect.Width(),00);
            pdc->LineTo(0,00);
			pdc->MoveTo( 0,Rect.Height()/2);
            pdc->LineTo(Rect.Width(),Rect.Height()/2);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
		pdc->TextOut(10,230,ConfigRec.JobRec.Oblq1Name);
		pdc->SelectObject(&xFont);

        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[2][1]);
		pdc->SelectObject(penOdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[2][1]+118,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[2][1]+100);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[2][1]+100);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[2][0]);
		pdc->SelectObject(penIdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[2][0]+18,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[2][0]);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[2][0]);

	penOd = &penBlue2;
	penId = &penRed2;

	penOld = pdc->SelectObject(penOd);	// OD is blue


	for (i=0; i<m_nScale; i++)
	{
		// Look at Long  OD
		if ( m_bOdCheck )
		{
			ptNewOd = m_ptExistOblq1[i][1];
			if (ptNewOd.y > 100)
			{
				pdc->SelectObject(penOdp);
				pdc->MoveTo(ptNewOd.x,100);			
				pdc->LineTo(ptNewOd);
			}
		}


		// Look at Long  ID
		if ( m_bIdCheck )	
		{
			ptNewId = m_ptExistOblq1[i][0];
			if (ptNewId.y > 0)
			{
				pdc->SelectObject(penIdp);
				pdc->MoveTo(ptNewId.x,0);
				pdc->LineTo(ptNewId);
			}
//			m_ptLastLId = ptNewId;	// remember last point location
		}

	}   //  End for

}

void CInspect::PlotExistingObq2(CDC *pdc, CRect Rect)
{
	CPoint ptNewOd, ptNewId;	// new  values for Sonoscope id/od
//	CRect InspLongRect;
	CPen *penOld;
	CPen *penId, *penOd;
	int i;
	int nBias = 0;
	Rect.NormalizeRect();
//        pdc->SetViewportOrg( 0, (int)(pageHeight*.8963) /*2868 */);
//		PlotMapScales(pdc, Rect );

// Move the coordinate origin to the lower left corner
//	pdc->SetViewportOrg( 0, (int)(pageHeight*.8656)/*2770*/+PRINTERFACTOR);
	//PlotMapScales(pdc, Rect );
//	pdc->SetViewportOrg( 0, (int)(pageHeight*.8628)/*2760*/+PRINTERFACTOR);

	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);

	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height());
            pdc->LineTo(Rect.Width(),Rect.Height());
            pdc->LineTo(Rect.Width(),00);
            pdc->LineTo(0,00);
			pdc->MoveTo( 0,Rect.Height()/2);
            pdc->LineTo(Rect.Width(),Rect.Height()/2);
#if (SYSTEM_ID == RAW_WALL_SYS)
	nBias = 5;
#else
	nBias = 1;
#endif
    pdc->SetWindowExt(m_nScale,-200);   // define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
#if (SYSTEM_ID == RAW_WALL_SYS)
		pdc->TextOut(10,230,_)T("NCSA"));
#else
		pdc->TextOut(10,230,ConfigRec.JobRec.Oblq2Name);
#endif
		pdc->SelectObject(&xFont);

        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[3][1]);
		pdc->SelectObject(penOdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[3][1]*nBias+118,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[3][1]*nBias+100);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[3][1]*nBias+100);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[3][0]);
		pdc->SelectObject(penIdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[3][0]*nBias+18,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[3][0]*nBias);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[3][0]*nBias);

	penOd = &penBlue2;
	penId = &penRed2;

	penOld = pdc->SelectObject(penOd);	// OD is blue


	for (i=0; i<m_nScale; i++)
	{
		// Look at Long  OD
		if ( m_bOdCheck )
		{
			ptNewOd = m_ptExistOblq2[i][1];
			ptNewOd.y *= nBias;
			if (ptNewOd.y > 100)
			{
				pdc->SelectObject(penOdp);
				pdc->MoveTo(ptNewOd.x,100);			
				pdc->LineTo(ptNewOd);
			}
		}


		// Look at Long  ID
		if ( m_bIdCheck )	
		{
			ptNewId = m_ptExistOblq2[i][0];
			ptNewId.y *= nBias;
			if (ptNewId.y > 0)
			{
				pdc->SelectObject(penIdp);
				pdc->MoveTo(ptNewId.x,0);
				pdc->LineTo(ptNewId);
			}
//			m_ptLastLId = ptNewId;	// remember last point location
		}

	}   //  End for

}


void CInspect::PlotExistingObq3(CDC *pdc, CRect Rect)
{
	CPoint ptNewOd, ptNewId;	// new  values for Sonoscope id/od
//	CRect InspLongRect;
	CPen *penOld;
	CPen *penId, *penOd;
	int i;
	Rect.NormalizeRect();
//        pdc->SetViewportOrg( 0, (int)(pageHeight*3990/4000) /*2868 */);
//		PlotMapScales(pdc, Rect );

// Move the coordinate origin to the lower left corner
//	pdc->SetViewportOrg( 0, (int)(pageHeight*3918/4000)/*4400*/+PRINTERFACTOR);
	//PlotMapScales(pdc, Rect );
//	pdc->SetViewportOrg( 0, (int)(pageHeight*3904/4000)/*4400*/+PRINTERFACTOR);

	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);

	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
		pdc->SelectObject(&penBlack3);
		pdc->SelectObject(&h1Font);
   			pdc->MoveTo( 0,00);
            pdc->LineTo(0,Rect.Height());
            pdc->LineTo(Rect.Width(),Rect.Height());
            pdc->LineTo(Rect.Width(),00);
            pdc->LineTo(0,00);
			pdc->MoveTo( 0,Rect.Height()/2);
            pdc->LineTo(Rect.Width(),Rect.Height()/2);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

		pdc->SelectObject(&hFont);
		pdc->TextOut(10,230,ConfigRec.JobRec.Oblq3Name);
		pdc->SelectObject(&xFont);

        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[4][1]);
		pdc->SelectObject(penOdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[4][1]+118,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[4][1]+100);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[4][1]+100);
        ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[4][0]);
		pdc->SelectObject(penIdt);
		pdc->TextOut(580,ConfigRec.UtRec.TholdLong[4][0]+18,ss);
		pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[4][0]);
		DashLine(pdc,ConfigRec.UtRec.TholdLong[4][0]);


	penOd = &penBlue2;
	penId = &penRed2;

	penOld = pdc->SelectObject(penOd);	// OD is blue


	for (i=0; i<m_nScale; i++)
	{
		// Look at Long  OD
		if ( m_bOdCheck )
		{
			ptNewOd = m_ptExistOblq3[i][1];
			if (ptNewOd.y > 100)
			{
				pdc->SelectObject(penOdp);
				pdc->MoveTo(ptNewOd.x,100);			
				pdc->LineTo(ptNewOd);
			}
		}


		// Look at Long  ID
		if ( m_bIdCheck )	
		{
			ptNewId = m_ptExistOblq3[i][0];
			if (ptNewId.y > 0)
			{
				pdc->SelectObject(penIdp);
				pdc->MoveTo(ptNewId.x,0);
				pdc->LineTo(ptNewId);
			}
//			m_ptLastLId = ptNewId;	// remember last point location
		}

	}   //  End for

}


void CInspect::PlotExistingLamin(CDC *pdc, CRect Rect)
{
	CPoint ptNewOd, ptNewId;	// new  values for Sonoscope id/od
//	CRect InspLongRect;
	CPen *penOld;
	CPen *penId, *penOd;
	int i;
	Rect.NormalizeRect();

	// Set mapping mode to AnIsotropic, deal in logical units rather than pixels
	pdc->SetMapMode(MM_ANISOTROPIC);

	pdc->SetWindowExt(Rect.Width(), -Rect.Height());	// define size of window in logical units
	pdc->SetViewportExt( Rect.Width(), Rect.Height());
	penOld = pdc->SelectObject(&penBlack1);
	pdc->SelectObject(&penBlack3);
	pdc->SelectObject(&h1Font);
   	pdc->MoveTo( 0,00);
    pdc->LineTo(0,Rect.Height());
    pdc->LineTo(Rect.Width(),Rect.Height());
    pdc->LineTo(Rect.Width(),00);
    pdc->LineTo(0,00);
	pdc->MoveTo( 0,Rect.Height()/2);
    pdc->LineTo(Rect.Width(),Rect.Height()/2);
	pdc->SetWindowExt(m_nScale,-200/*-pageHeight/13.2*/);	// define size of window in logical units
	// 750  1 INCH  x increments, 200 % on y axis.  Od in top 100%, ie.
	// Od biased by 100%, Id in bottom 100%

	// tell windows how big this box is physically in pixels
	pdc->SetViewportExt( Rect.Width(), Rect.Height());

	pdc->SelectObject(&hFont);
	pdc->TextOut(10,230,_T("LAMN"));
	pdc->SelectObject(&xFont);

    ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[5][1]);
	pdc->SelectObject(penOdt);
	pdc->TextOut(580,ConfigRec.UtRec.TholdLong[5][1]+118,ss);
	pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[5][1]+100);
	DashLine(pdc,ConfigRec.UtRec.TholdLong[5][1]+100);
    ss.Format(_T("%2d"),ConfigRec.UtRec.TholdLong[5][0]);
	pdc->SelectObject(penIdt);
	pdc->TextOut(580,ConfigRec.UtRec.TholdLong[5][0]+18,ss);
	pdc->MoveTo(0,ConfigRec.UtRec.TholdLong[5][0]);
	DashLine(pdc,ConfigRec.UtRec.TholdLong[5][0]);


	penOd = &penBlue2;
	penId = &penRed2;

	penOld = pdc->SelectObject(penOd);	// OD is blue


	for (i=0; i<m_nScale; i++)
	{
		// Look at Long  OD
		if ( m_bOdCheck )
		{
			ptNewOd = m_ptExistLamin[i][1];
			if (ptNewOd.y > 100)
			{
				pdc->SelectObject(penOdp);
				pdc->MoveTo(ptNewOd.x,100);			
				pdc->LineTo(ptNewOd);
			}
		}


		// Look at Long  ID
		if ( m_bIdCheck )	
		{
			ptNewId = m_ptExistLamin[i][0];
			if (ptNewId.y > 0)
			{
				pdc->SelectObject(penIdp);
				pdc->MoveTo(ptNewId.x,0);
				pdc->LineTo(ptNewId);
			}
//			m_ptLastLId = ptNewId;	// remember last point location
		}

	}   //  End for

}


int CInspect::AddFlawTextToDib(CDC *pDC, int cxChar, int cyChar, int height, int nGraphics, int PageNum)
{
	// Called from TscanDlg print dib function.  Put here to access
	// flaw pointer lists which are built and deleted in this class
	// TAKEN FROM UTRON-2 CODE 04/11/02

	// returns the number of defects added to dib as of 4/24/02


	// 04/25/01 add flag to determine whether printing only text on 2nd
	// 3rd etc pages or text with graphics on top on 1st page.  
	// Could have used dy != 0
	// but separate flag more readable/maintainable

	int TitleLoop;

	CString dash=_T("-  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  ");
	CString Q1Id, Q1Od, Q2Id, Q2Od, Q3Id, Q3Od;
	Q1Id.Format(_T("%s ID"), ConfigRec.JobRec.Oblq1Name);
	Q1Od.Format(_T("%s OD"), ConfigRec.JobRec.Oblq1Name);
	Q2Id.Format(_T("%s ID"), ConfigRec.JobRec.Oblq2Name);
	Q2Od.Format(_T("%s OD"), ConfigRec.JobRec.Oblq2Name);
	Q3Id.Format(_T("%s ID"), ConfigRec.JobRec.Oblq3Name);
	Q3Od.Format(_T("%s OD"), ConfigRec.JobRec.Oblq3Name);

#if (SYSTEM_ID == RAW_WALL_SYS)
	CString szHead[]={"Feet","LONG ID","LONG OD", "TRAN ID", "TRAN OD", 
					  Q1Id, Q1Od,"NCSA WN", "NCSA WK",Q3Id, Q3Od,
					  "LAM 1", "LAM 2", "WALL Thin","WALL Thick"}; 
#else
	CString szHead[]={_T("Feet"),_T("LONG ID"),_T("LONG OD"), _T("TRAN ID"), _T("TRAN OD"), 
					  Q1Id, Q1Od,Q2Id, Q2Od,Q3Id, Q3Od,
					  _T("LAM 1"), _T("LAM 2"), _T("WALL Thin"),_T("WALL Thick")}; 
#endif

	if (m_bMetric)
		szHead[0] = _T("Meter");

	CString szReport, szChnl, szLocClk, szTmp;
	CPtrList plistUtDefects;	// 'merged' list of qr flaws
	FLAW_REC *pF;
	float x, fwall;
	int amp, rad, nx;
	int i,j, nBottomLine;
	int LineNumber = 0,nLinesPerPage;	// with graphics, 25, w/o 60
	int nMaxFlaws;		// 75 with graphics, 180 w/o
	TEXTMETRIC tm;					// struct which hold characteristics of screen
/*
	POSITION pos;
	pos=m_plistTranFlaw.GetHeadPosition();
	while (pos != NULL)
		{
		pF = (FLAW_REC *) m_plistTranFlaw.GetNext(pos);
					if ( (pF->xloc>=30) && (pF->xloc<=36) && (pF->ChnlType==IS_TRAN_ID) )
						TRACE("x=%d, Chnl=%d, amp=%d\n", pF->xloc, pF->ChnlNum+1, pF->amp);
		}
*/
	// This code allows for up to 75 flaws to be printed.  More than
	// that, you've got pipe with setup problems.
	// 04/25/01 go to 75 on 1st page, 180 ( 3 col, 60 lines) on next pages


	FLAW_REC UtDefect[601];		// put 75 UT defect slots on the stack
	// reserve one extra slot for a stopper of the compare process


	// merge sort the wall and flaw info into UtDefect.
	// They will be sorted by  x location.  
	// print in such a way that they are monotonic in 'x'


	// temporary working space for flaws
	FLAW_REC FlawTmp[N_FLAW_TYPES];
	// wall = 0, long = 1, tran = 2, q1= 3, Q2 = 4, Q3 = 5

	int nLastDefect;			// total defects printed
	int nDefectCnt;			// how many defects already in report
	int imin;			// index of defect with min location
	CPoint print_origin;
	int pageWidth, pageHeight; 

//	SelectObject(*pDC, GetStockObject(SYSTEM_FIXED_FONT));
    //pDC->StartPage();
	// If text only page w/o strip chart dialog above
//	if(nGraphics == 0)
		pageWidth = pDC->GetDeviceCaps(HORZRES);
        pageHeight = pDC->GetDeviceCaps(VERTRES);
		{	// text only on this page

//		dy = cyChar;	// for text only, dy starts as 0;
		}	// text only on this page
/*
	else
		{	// strip chart graphic on top, text below
		print_origin.x = 10;
		print_origin.y = dy+2*cyChar;
		dy = print_origin.y+CViewcfg::PrintHeading(pDC, print_origin, pageWidth, pageHeight,
						szTmp, "");
		nLinesPerPage = 35;	// with graphics, 25, w/o 60
		nMaxFlaws = 35;		// 75 with graphics, 180 w/o
		}
*/
	  tFont.CreatePointFont(pageHeight/41,_T("Arial"), pDC);
//    xFont.CreatePointFont(80,"Arial", pDC);
		pDC->SelectObject(&tFont);

		nLinesPerPage = (pageHeight*(-8/height)-1100)/72 -8;		//54/42;
		nMaxFlaws = nLinesPerPage*5/6;		//pageHeight/120;			//45/35;

	//                  1         2         3         4         5         6         7         8         9         0         1         2         3         4			5		  6			7		  8			9		  0	
	//         12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
//	szHead = _T("Feet	   Long Id		Long Od		 Tran Id      Tran Od	   Obliq1 ID    Obliq1 OD    Obliq2 ID    Obliq2 OD    Obliq3 ID    Obliq3 OD    Feet         Wall Thn     Wall Thk");
	
	nLastDefect = 	 m_nTotalFlawCnt+ m_nTotalWallCnt;
	if ( nLastDefect > 600 ) nLastDefect = 600 ;   // change limit of flaws to 600 from 180 by YG
/*
	if (nLastDefect == 0)
		{	// No flaw to report on this page... we are done
		AddWallStatsToDib(pDC, cxChar, cyChar, dy, 1);
		return 0;		// nothing to do
		}
*/

//	if ( nLastDefect >= nMaxFlaws)		
//		nLastDefect = nMaxFlaws;

// init with flaw from each machine.. Removed from list
	for ( i = 0; i < N_FLAW_TYPES; i++) 
		GetNextFlaw( &FlawTmp[i], i);


	// Build a flaw list based on flaw location from front end
	for ( nDefectCnt = 0; nDefectCnt < nLastDefect; nDefectCnt++)
	{
		imin = GetMinXFlaw(&FlawTmp[0], &FlawTmp[1],
						&FlawTmp[2], &FlawTmp[3],
						&FlawTmp[4], &FlawTmp[5],
						&FlawTmp[6]);
		memcpy( (void *) &UtDefect[nDefectCnt],
			 (void *) &FlawTmp[imin], sizeof(FLAW_REC));

		if ( UtDefect[nDefectCnt].xloc > 10000) 
			break;	// no more valid entries
		plistUtDefects.AddTail( (void *) &UtDefect[nDefectCnt]);
		GetNextFlaw(&FlawTmp[imin], imin);	// removes from list
	}

	// We can quit the above loop with elements in FlawTmp which have
	// not been put into UtDefect.  If there are valid elements left
	// in FlawTmp, put them back into the correct list at the head
//    for (i=0; i<nLastDefect; i++)
	for ( i = 0; i < N_FLAW_TYPES; i++)
		{
		if ( FlawTmp[i].xloc < 20000)
			{	// reinsert flaw reading
			pF = new FLAW_REC;
			memcpy ( (void *) pF, (void *) &FlawTmp[i], sizeof(FLAW_REC));

			switch (i)
				{
			case 0:
				m_plistWallFlaw.AddHead( (void *) pF);
				m_nTotalWallCnt++;
				break;

			case 1:
				m_plistLongFlaw.AddHead( (void *) pF);
				m_nTotalFlawCnt++;
				break;
			case 2:
				m_plistTranFlaw.AddHead( (void *) pF);
				m_nTotalFlawCnt++;
				break;
			case 3:
				m_plistOblq1Flaw.AddHead( (void *) pF);
				m_nTotalFlawCnt++;
				break;
			case 4:
				m_plistOblq2Flaw.AddHead( (void *) pF);
				m_nTotalFlawCnt++;
				break;
			case 5:
				m_plistOblq3Flaw.AddHead( (void *) pF);
				m_nTotalFlawCnt++;
				break;
			case 6:
				m_plistLaminFlaw.AddHead( (void *) pF);
				m_nTotalFlawCnt++;
				break;
				}
			}

		}

	//POSITION pos;
/*
	pos=m_plistTranFlaw.GetHeadPosition();
	while (pos != NULL)
		{
		pF = (FLAW_REC *) m_plistTranFlaw.GetNext(pos);
					if ( (pF->xloc>=30) && (pF->xloc<=36) && (pF->ChnlType==IS_TRAN_ID) )
						TRACE("x=%d, Chnl=%d, amp=%d\n", pF->xloc, pF->ChnlNum+1, pF->amp);
		}
*/

	// Format the flaw list for printing
	nBottomLine = 0;
	nDefectCnt = 0;		// number printed on this page
	pDC->GetTextMetrics( &tm);
	cyChar = tm.tmHeight + tm.tmExternalLeading;
	cxChar = tm.tmAveCharWidth;

	for ( j = 0; j < 12; j++)   // change # of pages to 12 from 6 by YG
	{	// column j loop
		SelectObject(*pDC, GetStockObject(SYSTEM_FIXED_FONT));
		szTmp.Format(_T("%s Inspection Report Page %d"), SYSTEM_NAME, j+2);


		int dy = 0;		// no graphics, use whole context for text
        pDC->StartPage();
		pDC->SetMapMode(MM_TEXT );
		pDC->SetTextAlign(TA_LEFT);

		print_origin.x = pageWidth/20;
		print_origin.y = pageHeight/20+dy+cyChar;
		dy = print_origin.y + CViewcfg::PrintHeading(pDC, print_origin, pageWidth, height,
						szTmp, "");

		pDC->SelectObject(&tFont);

		pDC->GetTextMetrics( &tm);
		cyChar = tm.tmHeight + tm.tmExternalLeading;
		cxChar = tm.tmAveCharWidth;

		float LastX=0;
		int count=-1;
		int offset;
		int SlotFull[14],SlotNumber;
		BOOL NewLine;
		pDC->TextOut(print_origin.x+cxChar*2, dy+cyChar, _T("Note:       xx yy-zz               xx - amplitude, yy - clock location, zz - transducer number." ));
		dy += 2*cyChar;
	//                  1         2         3         4         5         6         7         8         9         0         1         2         3         4			5		  6			7		  8			9		  0	
	//         12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
//	szHead = _T("Feet	Long Id		    Long Od		 Tran Id      Tran Od	   Obliq1 ID    Obliq1 OD    Obliq2 ID    Obliq2 OD    Obliq3 ID    Obliq3 OD    Laminr ID    Laminr OD     Wall Thn     Wall Thk");

		//print title labels
		pDC->TextOut(print_origin.x+cxChar*1, dy+ cyChar,szHead[0]);
		for ( TitleLoop=1; TitleLoop<13; TitleLoop++)
			pDC->TextOut(print_origin.x+cxChar*(TitleLoop*13), dy+cyChar,
					szHead[TitleLoop]);
		pDC->TextOut(print_origin.x+cxChar*13*13-cxChar, dy+cyChar,szHead[13]);
		pDC->TextOut(print_origin.x+cxChar*14*13, dy+cyChar,szHead[14]);

		//print vertical separation lines
		pDC->MoveTo(print_origin.x+cxChar*10, dy+cyChar);
		pDC->LineTo(print_origin.x+cxChar*10, dy+cyChar+4650);
		for ( TitleLoop=1; TitleLoop<13; TitleLoop++)
		{
			pDC->MoveTo(print_origin.x+cxChar*(TitleLoop*13+11), dy+cyChar);
			pDC->LineTo(print_origin.x+cxChar*(TitleLoop*13+11), dy+cyChar+4650);
		}
		pDC->MoveTo(print_origin.x+cxChar*(13*13+13)-cxChar, dy+cyChar);
		pDC->LineTo(print_origin.x+cxChar*(13*13+13)-cxChar, dy+cyChar+4650);

		dy += 2*cyChar;
		pDC->SetTextAlign(TA_RIGHT);

		for ( i = 0,LineNumber=0; LineNumber < nLinesPerPage; i++)
		{	//Output a line in a column
			
			if (!plistUtDefects.IsEmpty())
			{
				if ( nBottomLine < i) 
					nBottomLine = i;

				pF = (FLAW_REC *) plistUtDefects.RemoveHead();


				// when list exhausted of real value, ie on reprint
				if ( pF->xloc > 10000) 
					return nDefectCnt;	// abort this operation
//				if ((m_bHome) || (m_nControlSel == INSPECT_PLAY) )
				nx = pF->xloc;	// from home or always on replay
				nDefectCnt++;

				x =  ((float)nx) / 12.0f;	// feet
				if ( m_bMetric) 
					x *= 0.3048f;	// meters
				amp =  (BYTE)pF->amp;
				if ( amp > 100) 
					amp = 100;	// no over range allowed
				rad = (BYTE)pF->radial*12/N_SEG;
				if ( rad == 0) 
					rad = 12;

				if ( LastX != x )
				{
					dy += cyChar+4;
					LastX=x;
					LineNumber++;
					count++;
					if ( (count % 5)==0 )
					{
						LineNumber++;
						pDC->TextOut(print_origin.x+194*cxChar,dy,dash);
						
						dy += cyChar+4;
						count=0;
					}

					szReport.Format(_T("%5.2f"), x);
					pDC->TextOut(print_origin.x+6*cxChar,dy,szReport);	//feet
					//pDC->TextOut(print_origin.x+150*cxChar,dy,szReport);
					NewLine = FALSE;
					for (int j=0; j<14; j++)
						SlotFull[j]=0;
				}
				offset = 178;
				switch (pF->ChnlType)
					{
				case IS_WALL_MAX:
					offset += 15;		//190;
					if (SlotFull[13]++ > 0 )
						NewLine=TRUE;
					goto wallmin;
				case IS_WALL_MIN:
					//offset = 178;
					if (SlotFull[12]++ > 0 )
						NewLine=TRUE;
					// wall
wallmin:
					fwall = (float)pF->wall;
					fwall /= 1000.0f;	// to inches
					if (m_bMetric)
						{
						fwall *= 25.4f;	// to millimeters
						szTmp.Format(_T("%6.2f"), fwall);
						}
					else	// English
						szTmp.Format(_T("%6.3f"), fwall);

					szReport = szTmp;
					break;

				case IS_LONG_ID:
					SlotNumber = 0;
					if (SlotFull[0]++ > 0 )
						NewLine=TRUE;
					offset = 21;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_LONG_OD:
					SlotNumber = 1;
					// flaw
					if (SlotFull[1]++ > 0 )
						NewLine=TRUE;
					offset = 21;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_TRAN_ID:
					SlotNumber = 2;
					if (SlotFull[2]++ > 0 )
						NewLine=TRUE;
					offset = 46;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_TRAN_OD:
					SlotNumber = 3;
					// flaw
					if (SlotFull[3]++ > 0 )
						NewLine=TRUE;
					offset = 46;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_OBQ1_ID:
					SlotNumber = 4;
					if (SlotFull[4]++ > 0 )
						NewLine=TRUE;
					offset = 73;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_OBQ1_OD:
					SlotNumber = 5;
					// flaw
					if (SlotFull[5]++ > 0 )
						NewLine=TRUE;
					offset = 73;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_OBQ2_ID:
					SlotNumber = 6;
					if (SlotFull[6]++ > 0 )
						NewLine=TRUE;
					offset = 99;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_OBQ2_OD:
					SlotNumber = 7;
					// flaw
					if (SlotFull[7]++ > 0 )
						NewLine=TRUE;
					offset = 99;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_OBQ3_ID:
					SlotNumber = 8;
					if (SlotFull[8]++ > 0 )
						NewLine=TRUE;
					offset = 125;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_OBQ3_OD:
					SlotNumber = 9;
					// flaw
					if (SlotFull[9]++ > 0 )
						NewLine=TRUE;
					offset = 125;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_LAM_LOG:
					SlotNumber = 10;
					if (SlotFull[10]++ > 0 )
						NewLine=TRUE;
					offset = 151;
					szReport.Format(_T("%3d"), amp);
					break;
				case IS_LAM_AMP:
					SlotNumber = 11;
					// flaw
					if (SlotFull[11]++ > 0 )
						NewLine=TRUE;
					offset = 151;
					szReport.Format(_T("%3d"), amp);
					break;
				default:
					break;
					}

				szTmp.Format(_T(" %2d-%02d"), rad,pF->ChnlNum+1);
				szReport += szTmp;

				if (pF->ChnlType >= IS_LONG)
					{
					if (pF->ChnlType & 1) 
						offset += 13;
					}
				if ( NewLine == TRUE )
				{
					dy += cyChar+4;
					LastX=x;
					LineNumber++;
					count++;
					if ( (count % 5)==0 )
					{
						LineNumber++;
						pDC->TextOut(print_origin.x+194*cxChar,dy,dash);
						
						dy += cyChar+4;
						count=0;
					}
					szTmp.Format(_T("%5.2f"), x);				//feet
					pDC->TextOut(print_origin.x+6*cxChar,dy,szTmp);
					//pDC->TextOut(print_origin.x+150*cxChar,dy,szTmp);
					NewLine = FALSE;
					for (int j=0; j<14; j++)
					{
						if (SlotFull[j] > 0)
							SlotFull[j]--;
					}
				}
	

			pDC->TextOut(print_origin.x+(offset+2) * cxChar, dy,
				szReport, szReport.GetLength());

			}	// of list not empty
			else
			{
				pDC->EndPage();
				tFont.DeleteObject();
//				break;
				return nDefectCnt;

			}
		}	//Output a line in a column.. i loop

		if ( pDC->EndPage() <= 0 )
		{
			pDC->AbortDoc();
		}


	}	// column j loop

	tFont.DeleteObject();
	return nDefectCnt;

}

void CInspect::AddWallStatsToDib(CDC *pDC, int cxChar, int cyChar, 
								 int dy, int LineNum)
{	// ONLY called from AddFlawTextToDib !!!

	CString s, t, units;
	float fwall, fx;
	float fmetWall, fmetX;	// metric scale factors for wall, x
	int nRnd;				// integer divide rounding
	short nMinWall, nMinWallX, nAvgWall, nMinAvgWall, nMinAvgWallX, nMaxWall, nEcc;

#if 0 //(SYSTEM_ID == RAW_WALL_SYS)
	/*
	switch (m_nWallClassification)
	{
	case 1:
		s.Format(_T("Customer Wall Classification: Super-premium");
		break;
	case 2:
		s.Format(_T("Customer Wall Classification: Premium");
		break;
	case 3:
		s.Format(_T("Customer Wall Classification: Good");
		break;
	case 4:
		s.Format(_T("Customer Wall Classification: Fair");
		break;
	case 5:
		s.Format(_T("Customer Wall Classification: Bad");
		break;
	default:
		s.Format(_T("Customer Wall Classification: Super-premium");
		break;
	}
	*/
	if ( m_nWallClassification>0.0f )
		s.Format(_T("Customer Wall Classification: %6.1f"), m_nWallClassification);
	else
		s.Format(_T("Customer Wall Classification: INVALID");

	pDC->TextOut(pDC->GetDeviceCaps(HORZRES)/20, dy+ cyChar*(LineNum + 0), s, strlen(s));
#endif

	if (m_bMetric)
		{	// metric
		fmetWall = 25.4f;	// inch to mm;
		fmetX = 0.0254f;	// inch to meters
		units = _T(" Metric");
		}
	else
		{	// english
		fmetWall = 1.0f;	// inch to inch
		fmetX = (1.0f)/(12.0f);	// inch to ft
		units = _T(" English");
		}

	switch (ConfigRec.JobRec.WallStatFlag)
		{
	case WALL_OPT_NONE:
	default:
		return;

	case WALL_OPT_EXXON:
		if ( mEx.nAvgCnt == 0) mEx.nAvgCnt = 1;
		nRnd = mEx.nAvgCnt/2;
		mEx.nAvgWall = (short) ((mEx.lSumAvg + nRnd) / mEx.nAvgCnt);

		// Reality check for the real world, prevent embarrasments
		if ( (mEx.nMinAvgWall < 0) ||
			 (mEx.nMinAvgWall > 2000) ||	// 2 inch limit
			 (mEx.nAvgWall > 2000) ||
			 (mEx.nMaxAvgWall > 2000) ||
			 (mEx.nMinWall < 0) ||
			 (mEx.nMinWall > 2000) ||
			 (mEx.nMaxWall < 0) ||
			 (mEx.nMaxWall > 2000) 
			) return;

		nMinWall = mEx.nMinWall;
		nMinWallX = mEx.nMinWallX;
		nAvgWall = mEx.nAvgWall;
		nMaxWall = mEx.nMaxWall;
		nEcc = mEx.nEcc;

		units += _T("-MA");
		break;

	case WALL_OPT_TUBO:
		if ( mTubo.nAvgCnt == 0) mTubo.nAvgCnt = 1;
		nRnd = mTubo.nAvgCnt/2;
		mTubo.nAvgWall = (short) ((mTubo.lSumAvg + nRnd) / mTubo.nAvgCnt);

		if ( mTubo.nMinCnt == 0) mTubo.nMinCnt = 1;
		nRnd = mTubo.nMinCnt/2;
		mTubo.nAvgMinWall = (short) ((mTubo.lSumMin + nRnd) / mTubo.nMinCnt);
		// Reality check for the real world, prevent embarrasments
		/*
		if ( (mTubo.nAvgWall < 0) ||
			 (mTubo.nAvgWall > 2000) ||	// 2 inch limit
			 (mTubo.nMinWall < 0) ||
			 (mTubo.nMinWall > 2000) ||
			 (mTubo.nMaxWall < 0) ||
			 (mTubo.nMaxWall > 2000) 
			) return;
		*/
		nMinWall = mTubo.nMinWall;
		nMinWallX = mTubo.nMinWallX;
		nAvgWall = mTubo.nAvgWall;
		nMinAvgWall = mTubo.nMinAvgWall;
		nMinAvgWallX = mTubo.nMinAvgWallX;
		nMaxWall = mTubo.nMaxWall;
		nEcc = mTubo.nEcc;

		units += "-T";
		break;

		}


	fwall = ((float) nMinWall ) * fmetWall / 1000.0f;
	fx = ( (float) nMinWallX ) * fmetX;
	if ( (nMinWall >= 0) && (nMinWall <=2000) )
		s.Format(_T("Wall Stats: [Min = %6.3f(%5.2f)]"), fwall, fx);
	else
		s.Format(_T("Wall Stats: [Min = Out of Range]"));

	fwall = ((float) nMaxWall) * fmetWall / 1000.0f;
	fx = ( (float) mTubo.nMaxWallX ) * fmetX;
	if ( (nMaxWall >= 0) && (nMaxWall <=2000) )
	{
		if ( ConfigRec.JobRec.WallStatFlag == WALL_OPT_TUBO )
			t.Format(_T(" [Max = %6.3f(%5.2f)]"), fwall, fx);
		else
			t.Format(_T(" [Max = %6.3f]"), fwall);
	}
	else
		t.Format(_T(" [Max = Out of Range]"));
	s += t;

	fwall = ((float) nAvgWall) * fmetWall / 1000.0f;
	if ( (nAvgWall >= 0) && (nAvgWall <=2000) )
		t.Format(_T(" [Avg = %6.3f]"), fwall);
	else
		t.Format(_T(" [Avg = Out of Range]"));
	s += t;

	if ( ConfigRec.JobRec.WallStatFlag == WALL_OPT_TUBO )
	{
		fwall = ((float) nMinAvgWall ) * fmetWall / 1000.0f;
		fx = ( (float) nMinAvgWallX ) * fmetX;
		if ( (nMinAvgWall >= 0) && (nMinAvgWall <=2000) )
			t.Format(_T(" [MinAvg = %6.3f(%5.2f)]"), fwall, fx);
		else
			t.Format(_T(" [MinAvg = Out of Range]"));
		s += t;
	}
	else
	{
		fwall = ((float) mEx.nMinAvgWall ) * fmetWall / 1000.0f;
		if ( (mEx.nMinAvgWall >= 0) && (mEx.nMinAvgWall <=2000) )
			t.Format(_T(" [MinAvg = %6.3f]"), fwall);
		else
			t.Format(_T(" [MinAvg = Out of Range]"));
		s += t;
		fwall = ((float) mEx.nMaxAvgWall ) * fmetWall / 1000.0f;
		if ( (mEx.nMaxAvgWall >= 0) && (mEx.nMaxAvgWall <=2000) )
			t.Format(_T(" [MaxAvg = %6.3f]"), fwall);
		else
			t.Format(_T(" [MaxAvg = Out of Range]"));
		s += t;
	}


	fx = ( (float) mTubo.nEccX ) * fmetX;
	if (ConfigRec.JobRec.WallStatFlag == WALL_OPT_TUBO) 
		t.Format(_T(" [Ecc = %2d(%5.2f)]"), nEcc, fx);
	else
		t.Format(_T(" [Ecc = %2d]"), nEcc);
	s += t;

	fwall = ((float) m_nWallDifference) * fmetWall / 1000.0f;
	if (ConfigRec.JobRec.ShowWallDiff) 
	{
		t.Format(_T(" [Delta = %6.3f]"), fwall);
		s += t;
	}
	s += units;
	pDC->TextOut(pDC->GetDeviceCaps(HORZRES)/20, dy+ cyChar*(LineNum + 1), s, s.GetLength());
}


void CInspect::OnButtonErase()
{
	CString s;

	s = _T("Do you really want to erase all the inspection data?");

	if ( MessageBox(s, _T("Erase Inspection Data"),MB_YESNO)== IDNO )
		return;

	OnInspEraseAll();
}


void CInspect::BackwardEraseMap(CDC *pDC, int nXlocS1, int nXlocS2)
{
   POSITION pos1, pos2;
   EXIST_MAP_RECT *pMapRect = NULL;
   int   nXloc = 2000;
   int   cy;
   COLORREF color;
   color = RGB(255,255,255);
   int dxTran = ConfigRec.UtRec.Shoe[1].Ch[0].cXOffset - ConfigRec.UtRec.Shoe[3].Ch[0].cXOffset;
   int dxObq2 = ConfigRec.UtRec.Shoe[5].Ch[0].cXOffset - ConfigRec.UtRec.Shoe[7].Ch[0].cXOffset;

   for( pos1 = m_pListExistMapRect.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pMapRect = (EXIST_MAP_RECT *) m_pListExistMapRect.GetNext(pos1);
	   switch(pMapRect->nType)
	   {
	   case 3:
	   case 4:
#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
		   nXloc = nXlocS2;
		   break;
#endif
	   case 0:
	   case 1:
	   case 2:
	   case 5:
	   case 6:
		   nXloc = nXlocS1;
		   break;
	   default:
		   nXloc = 2000;
		   break;
	   }

#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
	   switch(pMapRect->nType)
	   {
	   case 2:
		   nXloc += 1 - dxTran;
		   break;
	   case 4:
		   nXloc += 1 - dxObq2;
		   break;
	   default:
		   break;
	   }
#endif

       if( pMapRect->x > nXloc )
       {
			switch (pMapRect->nType)
			{
				case 0:
				case 1:
					pDC->FillSolidRect( (int) pMapRect->x, (int) pMapRect->y, (m_nScale/100),1,color);
					break;
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
					if ( pMapRect->y == 2*(N_SEG - 1))
						cy = -3;
					else
						cy = 3;
					pDC->FillSolidRect( (int) pMapRect->x, (int) pMapRect->y,3,cy, color);
					break;
				default:
					break;
			}  //end switch
            m_pListExistMapRect.RemoveAt( pos2 );
            delete pMapRect; // Deletion avoids memory leak.
       }
   }

}


void CInspect::BackwardEraseWall(CDC *pDC, int nXloc)
{
	int i, j;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;
	int nNumExistWallOld = m_nNumExistWall;

	penWhite.CreatePen(PS_SOLID,1, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

	for (i=0; i<m_nScale; i++)
	{
		if (m_ptExistWall[i][0].x > nXloc)
		{
			m_nNumExistWall = i;
			if (i>0)
			{
				m_ptLastWallMin = m_ptExistWall[i-1][0];
				m_ptLastWallMax = m_ptExistWall[i-1][1];
			}
			else
			{
				m_ptLastWallMin = (0,0);
				m_ptLastWallMax = (0,0);
			}

			for (j=m_nNumExistWall; j<nNumExistWallOld; j++)
			{
				if (j>0)
				{
					pDC->MoveTo(m_ptExistWall[j-1][0]);
					pDC->LineTo(m_ptExistWall[j][0]);

					pDC->MoveTo(m_ptExistWall[j-1][1]);
					pDC->LineTo(m_ptExistWall[j][1]);

					if (j>m_nNumExistWall)
					{
						m_ptExistWall[j-1][0] = (0,0);
						m_ptExistWall[j-1][1] = (0,0);
					}
				}
			}
/*
			if ( (m_nNumExistWall>0) && (m_nNumExistWall<m_nScale) )
			{
				// Draw black nominal wall line in center of graph
				pDC->SelectObject(&penBlack1);
				pDC->MoveTo(m_ptExistWall[m_nNumExistWall-1][0].x, 0);
				pDC->LineTo(m_nScale-2, 0);


				// Draw OD line as solid blue
				pDC->SelectObject(&penBlue1);

				pDC->MoveTo(m_ptExistWall[m_nNumExistWall-1][0].x, m_nTholdWodLast);
				pDC->LineTo(m_nScale-2, m_nTholdWodLast);

				// Draw ID as red line
				pDC->SelectObject(&penRed1);
				pDC->MoveTo(m_ptExistWall[m_nNumExistWall-1][0].x, m_nTholdWidLast);
				pDC->LineTo(m_nScale-2, m_nTholdWidLast);
			}
*/
			break;
		}
	}

	pDC->SelectObject(pOld);

   for( pos1 = m_plistWallFlaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistWallFlaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistWallFlaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::BackwardEraseLong(CDC *pDC, int nXloc)
{
	int i;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;

	penWhite.CreatePen(PS_SOLID,2, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

	for (i=nXloc+1; i<m_nScale; i++)
	{
		if (m_ptExistLong[i][0].y>0)   // ID
		{
			pDC->MoveTo(m_ptExistLong[i][0].x, 0);
			pDC->LineTo(m_ptExistLong[i][0]);
			m_ptExistLong[i][0].x = 0;
			m_ptExistLong[i][0].y = 0;
		}

		if (m_ptExistLong[i][1].y>100)   // OD
		{
			pDC->MoveTo(m_ptExistLong[i][1].x, 100);
			pDC->LineTo(m_ptExistLong[i][1]);
			m_ptExistLong[i][1].x = 0;
			m_ptExistLong[i][1].y = 100;
		}
	}
/*
    // Draw OD line as solid blue
    pDC->SelectObject(&penBlue1);

    pDC->MoveTo(2, m_nTholdLodLast + 100);
    pDC->LineTo(m_nScale-2, m_nTholdLodLast + 100);

    // Draw ID line as red
    pDC->SelectObject(&penRed1);
    pDC->MoveTo(2, m_nTholdLidLast);
    pDC->LineTo(m_nScale-2, m_nTholdLidLast);

    // Draw center dividing line separating Od from Id
    pDC->SelectObject(&penBlack1);

    pDC->MoveTo(2, 100);
    pDC->LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    pDC->MoveTo(2, 0);
    pDC->LineTo(m_nScale-2, 0);
*/
	pDC->SelectObject(pOld);

   for( pos1 = m_plistLongFlaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistLongFlaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistLongFlaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::BackwardEraseTran(CDC *pDC, int nXloc)
{
	int i;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;
    int dxTran = ConfigRec.UtRec.Shoe[1].Ch[0].cXOffset - ConfigRec.UtRec.Shoe[3].Ch[0].cXOffset;

	penWhite.CreatePen(PS_SOLID,2, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
	nXloc += 1 - dxTran;
	if (nXloc < 0) nXloc = 0;
#endif

	for (i=nXloc+1; i<m_nScale; i++)
	{
		if (m_ptExistTran[i][0].y>0)   // ID
		{
			pDC->MoveTo(m_ptExistTran[i][0].x, 0);
			pDC->LineTo(m_ptExistTran[i][0]);
			m_ptExistTran[i][0].x = 0;
			m_ptExistTran[i][0].y = 0;
		}

		if (m_ptExistTran[i][1].y>100)   // OD
		{
			pDC->MoveTo(m_ptExistTran[i][1].x, 100);
			pDC->LineTo(m_ptExistTran[i][1]);
			m_ptExistTran[i][1].x = 0;
			m_ptExistTran[i][1].y = 100;
		}
	}
/*
    // Draw OD line as solid blue
    pDC->SelectObject(&penBlue1);

    pDC->MoveTo(2, m_nTholdTodLast + 100);
    pDC->LineTo(m_nScale-2, m_nTholdTodLast + 100);

    // Draw ID line as red
    pDC->SelectObject(&penRed1);
    pDC->MoveTo(2, m_nTholdTidLast);
    pDC->LineTo(m_nScale-2, m_nTholdTidLast);

    // Draw center dividing line separating Od from Id
    pDC->SelectObject(&penBlack1);

    pDC->MoveTo(2, 100);
    pDC->LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    pDC->MoveTo(2, 0);
    pDC->LineTo(m_nScale-2, 0);
*/
	pDC->SelectObject(pOld);

   for( pos1 = m_plistTranFlaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistTranFlaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistTranFlaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::BackwardEraseOblq1(CDC *pDC, int nXloc)
{
	int i;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;

	penWhite.CreatePen(PS_SOLID,2, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

	for (i=nXloc+1; i<m_nScale; i++)
	{
		if (m_ptExistOblq1[i][0].y>0)   // ID
		{
			pDC->MoveTo(m_ptExistOblq1[i][0].x, 0);
			pDC->LineTo(m_ptExistOblq1[i][0]);
			m_ptExistOblq1[i][0].x = 0;
			m_ptExistOblq1[i][0].y = 0;
		}

		if (m_ptExistOblq1[i][1].y>100)   // OD
		{
			pDC->MoveTo(m_ptExistOblq1[i][1].x, 100);
			pDC->LineTo(m_ptExistOblq1[i][1]);
			m_ptExistOblq1[i][1].x = 0;
			m_ptExistOblq1[i][1].y = 100;
		}
	}
/*
    // Draw OD line as solid blue
    pDC->SelectObject(&penBlue1);

    pDC->MoveTo(2, m_nTholdQ1odLast + 100);
    pDC->LineTo(m_nScale-2, m_nTholdQ1odLast + 100);

    // Draw ID line as red
    pDC->SelectObject(&penRed1);
    pDC->MoveTo(2, m_nTholdQ1idLast);
    pDC->LineTo(m_nScale-2, m_nTholdQ1idLast);

    // Draw center dividing line separating Od from Id
    pDC->SelectObject(&penBlack1);

    pDC->MoveTo(2, 100);
    pDC->LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    pDC->MoveTo(2, 0);
    pDC->LineTo(m_nScale-2, 0);
*/
	pDC->SelectObject(pOld);

   for( pos1 = m_plistOblq1Flaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistOblq1Flaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistOblq1Flaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::BackwardEraseOblq2(CDC *pDC, int nXloc)
{
	int i;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;
    int dxObq2 = ConfigRec.UtRec.Shoe[5].Ch[0].cXOffset - ConfigRec.UtRec.Shoe[7].Ch[0].cXOffset;

	penWhite.CreatePen(PS_SOLID,2, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

#if ( (SYSTEM_ID == LORAINE_SYS) && (SYSTEM_SUB_ID == LORAINE_SYS) )
	nXloc += 1 - dxObq2;
	if (nXloc < 0) nXloc = 0;
#endif

	for (i=nXloc+1; i<m_nScale; i++)
	{
		if (m_ptExistOblq2[i][0].y>0)   // ID
		{
			pDC->MoveTo(m_ptExistOblq2[i][0].x, 0);
			pDC->LineTo(m_ptExistOblq2[i][0]);
			m_ptExistOblq2[i][0].x = 0;
			m_ptExistOblq2[i][0].y = 0;
		}

		if (m_ptExistOblq2[i][1].y>100)   // OD
		{
			pDC->MoveTo(m_ptExistOblq2[i][1].x, 100);
			pDC->LineTo(m_ptExistOblq2[i][1]);
			m_ptExistOblq2[i][1].x = 0;
			m_ptExistOblq2[i][1].y = 100;
		}
	}
/*
    // Draw OD line as solid blue
    pDC->SelectObject(&penBlue1);

    pDC->MoveTo(2, m_nTholdQ2odLast + 100);
    pDC->LineTo(m_nScale-2, m_nTholdQ2odLast + 100);

    // Draw ID line as red
    pDC->SelectObject(&penRed1);
    pDC->MoveTo(2, m_nTholdQ2idLast);
    pDC->LineTo(m_nScale-2, m_nTholdQ2idLast);

    // Draw center dividing line separating Od from Id
    pDC->SelectObject(&penBlack1);

    pDC->MoveTo(2, 100);
    pDC->LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    pDC->MoveTo(2, 0);
    pDC->LineTo(m_nScale-2, 0);
*/
	pDC->SelectObject(pOld);

   for( pos1 = m_plistOblq2Flaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistOblq2Flaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistOblq2Flaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::BackwardEraseOblq3(CDC *pDC, int nXloc)
{
	int i;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;

	penWhite.CreatePen(PS_SOLID,2, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

	for (i=nXloc+1; i<m_nScale; i++)
	{
		if (m_ptExistOblq3[i][0].y>0)   // ID
		{
			pDC->MoveTo(m_ptExistOblq3[i][0].x, 0);
			pDC->LineTo(m_ptExistOblq3[i][0]);
			m_ptExistOblq3[i][0].x = 0;
			m_ptExistOblq3[i][0].y = 0;
		}

		if (m_ptExistOblq3[i][1].y>100)   // OD
		{
			pDC->MoveTo(m_ptExistOblq3[i][1].x, 100);
			pDC->LineTo(m_ptExistOblq3[i][1]);
			m_ptExistOblq3[i][1].x = 0;
			m_ptExistOblq3[i][1].y = 100;
		}
	}
/*
    // Draw OD line as solid blue
    pDC->SelectObject(&penBlue1);

    pDC->MoveTo(2, m_nTholdQ3odLast + 100);
    pDC->LineTo(m_nScale-2, m_nTholdQ3odLast + 100);

    // Draw ID line as red
    pDC->SelectObject(&penRed1);
    pDC->MoveTo(2, m_nTholdQ3idLast);
    pDC->LineTo(m_nScale-2, m_nTholdQ3idLast);

    // Draw center dividing line separating Od from Id
    pDC->SelectObject(&penBlack1);

    pDC->MoveTo(2, 100);
    pDC->LineTo(m_nScale-2, 100);

    // Draw a solid base line at bottom of graph
    pDC->MoveTo(2, 0);
    pDC->LineTo(m_nScale-2, 0);
*/
	pDC->SelectObject(pOld);

   for( pos1 = m_plistOblq3Flaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistOblq3Flaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistOblq3Flaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::BackwardEraseLamin(CDC *pDC, int nXloc)
{
	int i;
	CPen penWhite;
	CPen *pOld;
	POSITION pos1, pos2;
	FLAW_REC *pFlaw;

	penWhite.CreatePen(PS_SOLID,2, RGB(255,255,255));
	pOld = pDC->SelectObject(&penWhite);

	for (i=nXloc+1; i<m_nScale; i++)
	{
		if (m_ptExistLamin[i][0].y>0)   // ID
		{
			pDC->MoveTo(m_ptExistLamin[i][0].x, 0);
			pDC->LineTo(m_ptExistLamin[i][0]);
			m_ptExistLamin[i][0].x = 0;
			m_ptExistLamin[i][0].y = 0;
		}

		if (m_ptExistLamin[i][1].y>100)   // OD
		{
			pDC->MoveTo(m_ptExistLamin[i][1].x, 100);
			pDC->LineTo(m_ptExistLamin[i][1]);
			m_ptExistLamin[i][1].x = 0;
			m_ptExistLamin[i][1].y = 100;
		}
	}

	pDC->SelectObject(pOld);

   for( pos1 = m_plistLaminFlaw.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
   {
	   pFlaw = (FLAW_REC *) m_plistLaminFlaw.GetNext(pos1);

       if( pFlaw->xloc > nXloc)
       {
            m_plistLaminFlaw.RemoveAt( pos2 );
            delete pFlaw; // Deletion avoids memory leak.
       }
   }
}


void CInspect::WriteJointToFile()
{
	DWORD len, len2;
	I_MSG_RUN *pImsg01;

    if ( (m_nControlSel == INSPECT_RECORD) && 
         (m_pDataFile) )
    {
        try
        {
            len = (DWORD) m_pDataFile->SeekToEnd();
			if (m_pDataFileCD)
				len2 = (DWORD) m_pDataFileCD->SeekToEnd();
            while (!m_plistUtDataFile.IsEmpty())
            {
                pImsg01 = (I_MSG_RUN *) m_plistUtDataFile.RemoveHead();
                if ( (pImsg01->InspHdr.wLineStatus & PIPE_PRESENT) == PIPE_PRESENT )
                    m_uNoPipeCount = 0;
                else m_uNoPipeCount++;
                // Dont record data when pipe is not there
                if (m_uNoPipeCount < 8)
                {
                    m_pDataFile->Write(pImsg01, sizeof(I_MSG_RUN));
					if (m_pDataFileCD)
						m_pDataFileCD->Write(pImsg01, sizeof(I_MSG_RUN));
                }

				delete pImsg01;
            }

            // dup the file so we can close it.  May not be necessary
            CFile *pDup = m_pDataFile->Duplicate();
            pDup->Close();
            delete pDup;
			if (m_pDataFileCD)
			{
				CFile *pDup2 = m_pDataFileCD->Duplicate();
				pDup2->Close();
				delete pDup2;
			}
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            m_pDataFile = NULL; // No exitsing file
			m_pDataFileCD = NULL; // No exitsing file
            return;
        }

		if (m_pDataFileCD)
			CheckFreeSpaceOnCD();
    }
	else
	{
        while (!m_plistUtDataFile.IsEmpty())
        {
            pImsg01 = (I_MSG_RUN *) m_plistUtDataFile.RemoveHead();
			delete pImsg01;
		}
	}
}


void CInspect::CreateRecordFileOnCD(CString sFileName) 
{
	ULARGE_INTEGER nFreeSpace;
	ULARGE_INTEGER nTotalSpace;
	ULARGE_INTEGER nTotalFreeSpace;
	DWORD  nFreeMegBytes;
	CString str;
/*
	switch(GetDriveType("E:"))
	{
	case DRIVE_FIXED:
		GetDiskFreeSpaceEx("C:", &nFreeSpace, &nTotalSpace, &nTotalFreeSpace);
		nFreeMegBytes = (DWORD) (nFreeSpace.QuadPart/1048576L);
		str.Format(_T("Hard disk free space = %d MB", nFreeMegBytes);
		AfxMessageBox(str);
		break;
	case DRIVE_CDROM:
		GetDiskFreeSpaceEx("E:", &nFreeSpace, &nTotalSpace, &nTotalFreeSpace);
		nFreeMegBytes = (DWORD) (nFreeSpace.QuadPart/1048576L);
		str.Format(_T("CD free space = %d MBytes", nFreeMegBytes);
		AfxMessageBox(str);
		break;
	default:
		AfxMessageBox(_T("Unknown Drive"));
		break;
	}
*/

    // TODO: Add your control notification handler code here
    int write_cnt = CONFIG_REC_SIZE;  //0x2000; // 8k space for config file
    // assume config file less than 8k always

    TCHAR szFilter[] = _T("Data Files(*.dat) | *.dat||");
    CFileDialog dlg (FALSE, _T("dat"), sFileName,NULL, 
                 szFilter);
	CString szTitle = _T("Record Data to CD-ROM");
	dlg.m_ofn.lpstrTitle = szTitle;
	dlg.m_ofn.lpstrInitialDir = _T("D:");

    if ( dlg.DoModal() == IDOK)
    {   
		// file open dialog returned OK
        CString s, t;
		TCHAR cDriveLetter;
        s = dlg.GetPathName();
		cDriveLetter = s.GetAt(0);
		t.Format(_T("%c:"),cDriveLetter);
		if ( GetDriveType(t) != DRIVE_CDROM )
		{
			AfxMessageBox(_T("This is NOT a CD drive."));
			return;
		}
		else
		{
			if ( GetDiskFreeSpaceEx(t, &nFreeSpace, &nTotalSpace, &nTotalFreeSpace) )
			{
				nFreeMegBytes = (DWORD) (nFreeSpace.QuadPart/1048576L);
				str.Format(_T("There is %d MB free space on the CD."), nFreeMegBytes);
				AfxMessageBox(str);
			}
		}

        try
        {
            CFile file (s, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite);
            // PREFIX THE file with the current config record
            while ( write_cnt > 0)
            {
                file.Write(&ConfigRec, CONFIG_REC_SIZE );
                write_cnt = -1;
            }
            // when this procedure closes, it will close the open file

            // duplicate this file into a handle which is persistent
            m_pDataFileCD = (CFile *)file.Duplicate();    // persistent file
        }
        catch (CFileException* e)
        {
            e->ReportError();
            e->Delete();
            m_pDataFile = NULL; // No exitsing file
            return;
        }

		m_DataPathName += _T(" & ");
        m_DataPathName += s;
        //ShowDlgTitle();
    }   // end file open dialog returned OK
}


void CInspect::CheckFreeSpaceOnCD()
{
	ULARGE_INTEGER nFreeSpace;
	ULARGE_INTEGER nTotalSpace;
	ULARGE_INTEGER nTotalFreeSpace;
	DWORD  nFreeMegBytes;
	CString str;

	int nIndex = m_DataPathName.Find(_T(" & "));
	if (nIndex == -1)
		return;

    CString t;
	TCHAR cDriveLetter;
	cDriveLetter = m_DataPathName.GetAt(nIndex+3);
	t.Format(_T("%c:"),cDriveLetter);
	if ( GetDriveType(t) == DRIVE_CDROM )
	{
		if ( GetDiskFreeSpaceEx(t, &nFreeSpace, &nTotalSpace, &nTotalFreeSpace) )
		{
			nFreeMegBytes = (DWORD) (nFreeSpace.QuadPart/1048576L);
			if ( nFreeMegBytes<10 )
			{
				str.Format(_T("Free space on the CD is low.\nThere is only %d MB available."), nFreeMegBytes);
				AfxMessageBox(str);
			}
		}
	}
}

/************************************************************
* Find maximum joint number from a recorded data file for both
* real joint and calibration joint.
*/
BOOL CInspect::FindMaxJointNum(CFile *pDataFile) 
{
	DWORD len;
	int nSize;
	I_MSG_RUN	*pImsg01;
	DWORD CurrentJoint;
	DWORD MaxRealJoint = 0;
	DWORD MaxCalJoint = 0;

	CWaitCursor WaitCursor;

	// skip header
	len = (DWORD) pDataFile->Seek(CONFIG_REC_SIZE, CFile::begin); 

	pImsg01 = new I_MSG_RUN;
	nSize = pDataFile->Read(pImsg01, sizeof(I_MSG_RUN));
	CurrentJoint = pImsg01->InspHdr.JointNumber;

	while (nSize == sizeof(I_MSG_RUN) )
	{
		if (pImsg01->InspHdr.status[1] & CALIBRATION_JOINT)  // cal run
		{
			if ( CurrentJoint>MaxCalJoint )
				MaxCalJoint = CurrentJoint;
		}
		else
		{
			if ( CurrentJoint>MaxRealJoint )
				MaxRealJoint = CurrentJoint;
		}

		while ( (CurrentJoint == pImsg01->InspHdr.JointNumber) &&
				(nSize == sizeof(I_MSG_RUN) ) )
		{
			nSize = pDataFile->Read(pImsg01, sizeof(I_MSG_RUN));
		}
		CurrentJoint = pImsg01->InspHdr.JointNumber;
	}

	TRACE("Max Real Joint = %d\n", MaxRealJoint);
	TRACE("Max cal Joint  = %d\n", MaxCalJoint);

	delete pImsg01;

	pDataFile->SeekToBegin();

	if (MaxRealJoint == 0)
		MaxRealJoint = 0;
	if (MaxCalJoint == 0)
		MaxCalJoint = 5000;

	m_pTcpThreadRxList->SendLastJointNum(MaxRealJoint, MaxCalJoint);

	return TRUE;
}

void CInspect::OnCheckCalRun() 
{
	CString s;

	if ( !m_bRunCalJoint && (m_nControlSel != INSPECT_RECORD) )
	{
		AfxMessageBox(_T("Please set inspection control to reCord first."));
		((CButton *) GetDlgItem(IDC_CHECK_CALRUN))->SetCheck(0);
		return;
	}

	s = _T("Do you really want to change this?");

	if ( MessageBox(s, _T("CalRun"),MB_YESNO)== IDNO )
	{
		if (m_bRunCalJoint)
			((CButton *) GetDlgItem(IDC_CHECK_CALRUN))->SetCheck(1);
		else
			((CButton *) GetDlgItem(IDC_CHECK_CALRUN))->SetCheck(0);
		return;
	}

	// TODO: Add your control notification handler code here
	m_bRunCalJoint ^= 1;

	if (m_nID == 0)
		m_pTcpThreadRxList->SendCalRunMsg(m_bRunCalJoint);
}


void CInspect::UnCheckCalRun() 
{
	m_bRunCalJoint = FALSE;

	((CButton *) GetDlgItem(IDC_CHECK_CALRUN))->SetCheck(0);

	if (m_nID == 0)
		m_pTcpThreadRxList->SendCalRunMsg(m_bRunCalJoint);
}


void CInspect::PrintReportNow()
{
#if ( (SYSTEM_ID == RAW_WALL_SYS) || (SYSTEM_SUB_ID == BESSEMER_SYS) )
	if (m_nHomeAway == 0)
		ReverseReport((short) m_nAwayStopXloc, (short) SiteDefault.nDefaultXOffset2);
#endif

	if ( m_bPrntFlw && (m_nTotalFlawCnt == 0) && (m_nTotalWallCnt == 0) )
		return;

    if (m_nControlSel != INSPECT_PLAY)
    {
        StopTimer();
        m_nControlSelLast = m_nControlSel;
        m_nControlSel = INSPECT_STOP;

        //if (m_nID == 0)
            //pCTscanDlg->OnFilePrintscreen();
        //else if (m_nID == 1)
            //pCTscanDlg->OnFilePrintscreen2();
		OnINSPreport();
        StartTimer();
        m_nControlSel = m_nControlSelLast;
    }
    else
    {
        //if (m_nID == 0)
            //pCTscanDlg->OnFilePrintscreen();
        //else if (m_nID == 1)
            //pCTscanDlg->OnFilePrintscreen2();
		OnINSPreport();
    }
}


void CInspect::ReverseReport(short nReverseOffset, short nAwayOffset)
{
	ReverseExistMap(nReverseOffset, nAwayOffset);
	ReverseExistWall(nReverseOffset, nAwayOffset);
	ReverseExistLong(nReverseOffset, nAwayOffset);
	ReverseExistTran(nReverseOffset, nAwayOffset);
	ReverseExistOblq1(nReverseOffset, nAwayOffset);
	ReverseExistOblq2(nReverseOffset, nAwayOffset);
	ReverseExistOblq3(nReverseOffset, nAwayOffset);
	ReverseExistLamin(nReverseOffset, nAwayOffset);
	ReverseFlawLists(nReverseOffset, nAwayOffset);
	ReverseWallStats(nReverseOffset, nAwayOffset);

	RefreshWindow();

	m_nHomeAway = 1;
}


void CInspect::ReverseExistMap(short nReverseOffset, short nAwayOffset)
{
	EXIST_MAP_RECT *pMapRect;

    POSITION rPosition = m_pListExistMapRect.GetHeadPosition();

    while (rPosition != NULL)
    {
        pMapRect = (EXIST_MAP_RECT *) m_pListExistMapRect.GetNext(rPosition);

		pMapRect->x = nReverseOffset - (pMapRect->x-1) + nAwayOffset + 1;
	}
}


void CInspect::ReverseExistWall(short nReverseOffset, short nAwayOffset)
{
	int i;

    for (i=0; i<m_nNumExistWall; i++)
    {
        m_ptExistWall[i][1].x = nReverseOffset -  m_ptExistWall[i][1].x + nAwayOffset;          

        m_ptExistWall[i][0].x = nReverseOffset -  m_ptExistWall[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseExistLong(short nReverseOffset, short nAwayOffset)
{
	int i;

    for (i=0; i<m_nScale; i++)
    {
		if (m_ptExistLong[i][1].y > 100)
			m_ptExistLong[i][1].x = nReverseOffset - m_ptExistLong[i][1].x + nAwayOffset;

		if (m_ptExistLong[i][0].y > 0)
			m_ptExistLong[i][0].x = nReverseOffset - m_ptExistLong[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseExistTran(short nReverseOffset, short nAwayOffset)
{
	int i;

    for (i=0; i<m_nScale; i++)
    {
		if (m_ptExistTran[i][1].y > 100)
			m_ptExistTran[i][1].x = nReverseOffset - m_ptExistTran[i][1].x + nAwayOffset;

		if (m_ptExistTran[i][0].y > 0)
			m_ptExistTran[i][0].x = nReverseOffset - m_ptExistTran[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseExistOblq1(short nReverseOffset, short nAwayOffset)
{
	int i;

    for (i=0; i<m_nScale; i++)
    {
		if (m_ptExistOblq1[i][1].y > 100)
			m_ptExistOblq1[i][1].x = nReverseOffset - m_ptExistOblq1[i][1].x + nAwayOffset;

		if (m_ptExistOblq1[i][0].y > 0)
			m_ptExistOblq1[i][0].x = nReverseOffset - m_ptExistOblq1[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseExistOblq2(short nReverseOffset, short nAwayOffset)
{
	int i;
	int nBias = 0;

#if (SYSTEM_ID == RAW_WALL_SYS)
	nBias = 20;
#else
	nBias = 100;
#endif

    for (i=0; i<m_nScale; i++)
    {
		if (m_ptExistOblq2[i][1].y > nBias)
			m_ptExistOblq2[i][1].x = nReverseOffset - m_ptExistOblq2[i][1].x + nAwayOffset;

		if (m_ptExistOblq2[i][0].y > 0)
			m_ptExistOblq2[i][0].x = nReverseOffset - m_ptExistOblq2[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseExistOblq3(short nReverseOffset, short nAwayOffset)
{
	int i;

    for (i=0; i<m_nScale; i++)
    {
		if (m_ptExistOblq3[i][1].y > 100)
			m_ptExistOblq3[i][1].x = nReverseOffset - m_ptExistOblq3[i][1].x + nAwayOffset;

		if (m_ptExistOblq3[i][0].y > 0)
			m_ptExistOblq3[i][0].x = nReverseOffset - m_ptExistOblq3[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseExistLamin(short nReverseOffset, short nAwayOffset)
{
	int i;

    for (i=0; i<m_nScale; i++)
    {
		if (m_ptExistLamin[i][1].y > 100)
			m_ptExistLamin[i][1].x = nReverseOffset - m_ptExistLamin[i][1].x + nAwayOffset;

		if (m_ptExistLamin[i][0].y > 0)
			m_ptExistLamin[i][0].x = nReverseOffset - m_ptExistLamin[i][0].x + nAwayOffset;
    }   //  End for
}


void CInspect::ReverseFlawLists(short nReverseOffset, short nAwayOffset)
{
	CPtrList plistWallFlawCopy;
	CPtrList plistLongFlawCopy;
	CPtrList plistTranFlawCopy;	
	CPtrList plistOblq1FlawCopy;
	CPtrList plistOblq2FlawCopy;
	CPtrList plistOblq3FlawCopy;
	CPtrList plistLaminFlawCopy;

    FLAW_REC *pFlaw;

    while ( !m_plistWallFlaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistWallFlaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistWallFlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistWallFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistWallFlawCopy.RemoveHead();
        m_plistWallFlaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistLongFlaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistLongFlaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistLongFlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistLongFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistLongFlawCopy.RemoveHead();
        m_plistLongFlaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistTranFlaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistTranFlaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistTranFlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistTranFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistTranFlawCopy.RemoveHead();
        m_plistTranFlaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistOblq1Flaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistOblq1Flaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistOblq1FlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistOblq1FlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistOblq1FlawCopy.RemoveHead();
        m_plistOblq1Flaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistOblq2Flaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistOblq2Flaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistOblq2FlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistOblq2FlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistOblq2FlawCopy.RemoveHead();
        m_plistOblq2Flaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistOblq3Flaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistOblq3Flaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistOblq3FlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistOblq3FlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistOblq3FlawCopy.RemoveHead();
        m_plistOblq3Flaw.AddTail ( (void *) pFlaw );
    }

    while ( !m_plistLaminFlaw.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) m_plistLaminFlaw.RemoveTail();
		pFlaw->xloc = nReverseOffset - pFlaw->xloc + nAwayOffset;
        plistLaminFlawCopy.AddTail ( (void *) pFlaw );
    }
    while ( !plistLaminFlawCopy.IsEmpty() )
    {
        pFlaw = (FLAW_REC *) plistLaminFlawCopy.RemoveHead();
        m_plistLaminFlaw.AddTail ( (void *) pFlaw );
    }
}


void CInspect::ReverseWallStats(short nReverseOffset, short nAwayOffset)
{
	switch (ConfigRec.JobRec.WallStatFlag)
		{
	case WALL_OPT_NONE:
	default:
		return;

	case WALL_OPT_EXXON:
		mEx.nMinWallX = nReverseOffset - mEx.nMinWallX + nAwayOffset;
		mEx.nMaxWallX = nReverseOffset - mEx.nMaxWallX + nAwayOffset;
		break;

	case WALL_OPT_TUBO:
		mTubo.nMinWallX = nReverseOffset - mTubo.nMinWallX + nAwayOffset;
		mTubo.nMaxWallX = nReverseOffset - mTubo.nMaxWallX + nAwayOffset;
		mTubo.nMinAvgWallX = nReverseOffset - mTubo.nMinAvgWallX + nAwayOffset;
		break;
	}
}


void CInspect::ShowInvalidWallClassification()
{
	switch (m_nInvalidWallTimer%3)
	{
	case 0:
	case 2:
		m_stStation2.SetWindowText(_T("INVALID"));
		break;
	case 1:
	default:
		m_stStation2.SetWindowText(_T(""));
		break;
	}

	m_nInvalidWallTimer--;
}



void CInspect::OnAllFlaw() 
{
	// TODO: Add your control notification handler code here
	m_bAllFlaw = !m_bAllFlaw;
	TRACE("m_bAllFlaw = %d\n", m_bAllFlaw);
}

void CInspect::OnCkLamin() 
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);   // Copy screen TO variables 
}


void  CInspect::SetOblqName()
{
	CString s;
	s = ConfigRec.JobRec.Oblq1Name;
	SetDlgItemText(IDC_STATIC_Q1, s);
	s = ConfigRec.JobRec.Oblq2Name;
	SetDlgItemText(IDC_STATIC_Q2, s);
	s = ConfigRec.JobRec.Oblq3Name;
	SetDlgItemText(IDC_STATIC_Q3, s);
}

void CInspect::OnCheckRealTimeReport() 
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
}
